using System;
using Kernel_alpha.x86.Intrinsic;
using Kernel_alpha.Drivers.ACPI;
using misc = Kernel_alpha.Drivers.ACPI.misc;

namespace Kernel_alpha.Drivers
{

    /// <summary>
    /// Acpi.
    /// </summary>
    public unsafe class acpi
    {
        // New Port I/O
        private IOPort smiIO, pm1aIO, pm1bIO;

        // ACPI variables
        private int* SMI_CMD;
        private byte ACPI_ENABLE;
        private byte ACPI_DISABLE;
        private int* PM1a_CNT;
        private int* PM1b_CNT;
        private short SLP_TYPa;
        private short SLP_TYPb;
        private short SLP_EN;
        private short SCI_EN;
        private byte PM1_CNT_LEN;

        // FACP
        private byte* Facp = null;

        public acpi(bool initialize = true, bool enable = true)
        {
            if (initialize)
                Init ();

            if (enable)
                Enable ();
        }

        // Shutdown
        public void Shutdown ()
        {
            if (PM1a_CNT == null)
                Init ();

            pm1aIO.Word = (ushort)(SLP_TYPa | SLP_EN);

            if (PM1b_CNT != null)
                pm1bIO.Word = (ushort)(SLP_TYPb | SLP_EN);

            Native.Halt ();
        }

        // Reboot
        public void Reboot ()
        {
            IOPort port = new IOPort (0x64);
            byte good = 0x02;

            while ((good & 0x02) != 0)
                good = port.Byte;

            port.Byte = 0xFE;

            // Halt CPU
            Native.Halt ();
        }

        // Initializazion
        private bool Init()
        {
            byte* ptr = (byte*)RSDPAddress();
            int addr = 0;

            for (int i = 19; i >= 16; i--)
            {
                addr += (*(ptr + i));
                addr = (i == 16) ? addr : addr << 8;
            }

            ptr = (byte*)addr;
            ptr += 4; addr = 0;

            for (int i = 3; i >= 0; i--)
            {
                addr += (*(ptr + i));
                addr = (i == 0) ? addr : addr << 8;
            }

            int length = addr;
            ptr -= 4;

            if (ptr != null && misc.acpiCheckHeader(ptr, "RSDT") == 0)
            {
                addr = 0;
                int entrys = length;
                entrys = (entrys - 36) / 4;
                ptr += 36;
                byte* yeuse;

                while (0 < entrys--)
                {
                    for (int i = 3; i >= 0; i--)
                    {
                        addr += (*(ptr + i));
                        addr = (i == 0) ? addr : addr << 8;
                    }

                    yeuse = (byte*)addr;
                    Facp = yeuse;

                    if (misc.Compare("FACP", Facp) == 0)
                    {
                        if (misc.acpiCheckHeader((byte*)facpget(0), "DSDT") == 0)
                        {
                            byte* S5Addr = (byte*)facpget(0) + 36;
                            int dsdtLength = *(facpget(0) + 1) - 36;

                            while (0 < dsdtLength--)
                            {
                                if (misc.Compare("_S5_", S5Addr) == 0)
                                    break;
                                S5Addr++;
                            }

                            if (dsdtLength > 0)
                            {
                                if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)
                                {
                                    S5Addr += 5;
                                    S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;
                                    if (*S5Addr == 0x0A)
                                        S5Addr++;
                                    SLP_TYPa = (short)(*(S5Addr) << 10);
                                    S5Addr++;
                                    if (*S5Addr == 0x0A)
                                        S5Addr++;
                                    SLP_TYPb = (short)(*(S5Addr) << 10);
                                    SMI_CMD = facpget(1);
                                    ACPI_ENABLE = facpbget(0);
                                    ACPI_DISABLE = facpbget(1);
                                    PM1a_CNT = facpget(2);
                                    PM1b_CNT = facpget(3);
                                    PM1_CNT_LEN = facpbget(3);
                                    SLP_EN = 1 << 13;
                                    SCI_EN = 1;

                                    smiIO = new IOPort((ushort)SMI_CMD);
                                    pm1aIO = new IOPort((ushort)PM1a_CNT);
                                    pm1bIO = new IOPort((ushort)PM1b_CNT);

                                    return true;
                                }
                            }
                        }
                    }

                    ptr += 4;
                }
            }

            return false;
        }

        // Enable ACPI
        private bool Enable ()
        {
            if (pm1aIO.Word == 0)
            {
                if (SMI_CMD != null && ACPI_ENABLE != 0)
                {
                    smiIO.Word = ACPI_ENABLE;

                    int i;
                    for (i = 0; i < 300; i++)
                    {
                        if ((pm1aIO.Word & 1) == 1)
                            break;
                    }

                    if (PM1b_CNT != null)
                    {
                        for (; i < 300; i++)
                        {
                            if ((pm1bIO.Word & 1) == 1)
                                break;
                        }
                    }

                    if (i < 300) return true;
                    return false;
                }
                return false;
            }
            return true;
        }

        // Disable ACPI
        public void Disable ()
        {
            smiIO.Byte = ACPI_DISABLE;
        }

        // Retrieve the RSDP address
        private unsafe uint RSDPAddress()
        {
            for (uint addr = 0xE0000; addr < 0x100000; addr += 4)
                if (misc.Compare("RSD PTR ", (byte*)addr) == 0)
                    if (misc.Check_RSD(addr))
                        return addr;

            uint ebda_address = *((uint*)0x040E);
            ebda_address = (ebda_address * 0x10) & 0x000fffff;

            for (uint addr = ebda_address; addr < ebda_address + 1024; addr += 4)
                if (misc.Compare("RSD PTR ", (byte*)addr) == 0)
                    return addr;

            return 0;
        }

        // RSDT Table
        private uint* acpiCheckRSDPtr(uint* ptr)
        {
            string sig = "RSD PTR ";
            RSDPtr* rsdp = (RSDPtr*)ptr;

            byte* bptr;
            byte check = 0;
            int i;

            if (misc.Compare(sig, (byte*)rsdp) == 0)
            {
                bptr = (byte*)ptr;

                for (i = 0; i < 20; i++)
                {
                    check += *bptr;
                    bptr++;
                }

                if (check == 0)
                {
                    misc.Compare("RSDT", (byte*)rsdp->RsdtAddress);

                    if (rsdp->RsdtAddress != 0)
                        return (uint*)rsdp->RsdtAddress;
                }
            }

            return null;
        }

        // FACP Table
        private byte facpbget (int number)
        {
            switch (number)
            {
            case 0:
                return *(Facp + 52);
            case 1:
                return *(Facp + 53);
            case 2:
                return *(Facp + 89);
            default:
                return 0;
            }
        }

        private int* facpget (int number)
        {
            switch (number)
            {
            case 0:
                return (int*)*((int*)(Facp + 40));
            case 1:
                return (int*)*((int*)(Facp + 48));
            case 2:
                return (int*)*((int*)(Facp + 64));
            case 3:
                return (int*)*((int*)(Facp + 68));
            default:
                return null;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          FAT Helper
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.IO.FileSystem.FAT.Find
{
    internal class Any : Comparison
    {
        internal Any() { }

        internal override bool Compare(byte[] data, int offset, FatType type)
        {
            switch ((FileNameAttribute)data[offset + (uint)Entry.DOSName])
            {
                case FileNameAttribute.LastEntry:
                case FileNameAttribute.Deleted:
                case FileNameAttribute.Escape:
                case FileNameAttribute.Dot:
                    return false;
                default:
                    return true;
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;
using Atomix.Assembler;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.mscorlib
{
    public static class ArrayImpl
    {
        [Assembly(true), Plug("System_Void_System_Array_Copy_System_Array__System_Int32__System_Array__System_Int32__System_Int32__System_Boolean_")]
        public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable)
        {
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EBP, DestinationIndirect = true, DestinationDisplacement = 0x1C });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceRef = "0xC", Size = 32 }); // pointer is at the element size
            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EAX, SourceIndirect = true }); // element size
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EBX, SourceReg = Registers.EBP, SourceIndirect = true, SourceDisplacement = 0x18 });
            Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.EBX });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EAX, SourceRef = "0x10" });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.EBP, SourceIndirect = true, SourceDisplacement = 0x1C });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESI, SourceReg = Registers.EAX }); // source ptr
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EBP, DestinationIndirect = true, DestinationDisplacement = 0x14 });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceRef = "0xC", Size = 32 }); // pointer is at element size
            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EAX, SourceIndirect = true });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EBP, SourceIndirect = true, SourceDisplacement = 0x10 });
            Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ECX });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EAX, SourceRef = "0x10" });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.EBP, SourceIndirect = true, SourceDisplacement = 0x14 });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EDI, SourceReg = Registers.EAX });

            // calculate byte count to copy
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EBP, SourceIndirect = true, SourceDisplacement = 0x14 });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EAX, SourceRef = "0xC" });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EAX, SourceIndirect = true });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.EBP, SourceIndirect = true, SourceDisplacement = 0xC });
            Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.EDX });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
            Core.AssemblerCode.Add(new Literal("rep movsb"));
        }
    }
}
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Atomix.mscorlib")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Hewlett-Packard")]
[assembly: AssemblyProduct("Atomix.mscorlib")]
[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("20410a5a-acdb-448b-8c68-c73b0dec4f3a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          add x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Add : DestinationSourceSize
    {
        public Add()
            : base("add") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          addss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Addss : DestinationSource
    {
        public Addss()
            : base("addss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          adc x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class AddWithCarry : DestinationSourceSize
    {
        public AddWithCarry()
            : base("adc") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          and x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class And : DestinationSourceSize
    {
        public And()
            : base("and") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Application Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomix.CompilerExt.Attributes
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
    public class ApplicationAttribute : Attribute
    {
        public readonly CPUArch CPUArch;

        public ApplicationAttribute(CPUArch aCpuArch = CPUArch.x86)
        {
            CPUArch = aCpuArch;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Literal Assembly Handling class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.IO;
using System.Linq;

namespace Atomix.Assembler
{
    public class AsmData
    {
        public readonly string Name;
        public readonly string Value;
        public readonly bool IsBssData;

        public AsmData(string aName, string aValue)
        {
            Name = aName;
            Value = aValue;
        }

        public AsmData(string aName, uint aLength)
        {
            Name = aName;
            Value = "resb " + aLength;
            IsBssData = true;
        }

        public AsmData(string aName, byte[] aValue)
        {
            Name = aName;
            if (aValue.LastOrDefault(a => a != 0) == 0)
            {
                IsBssData = true;
                Value = "resb " + aValue.Length;
            }
            else
            {
                Value = string.Format("db {0}", string.Join(", ", aValue.Select(a => a.ToString())));
            }
        }

        public AsmData(string aName, string[] aValue)
        {
            Name = aName;
            Value = string.Format("dd {0}", string.Join(", ", aValue.Select(a => a.ToString())));
            IsBssData = false;
        }

        public void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(string.Format("{0} {1}", Name, Value));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Assembly Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomix.CompilerExt.Attributes
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    public class AssemblyAttribute : Attribute
    {
        public readonly bool NeedCalliHeader;

        public AssemblyAttribute(bool aNeedCalliHeader = false)
        {
            NeedCalliHeader = aNeedCalliHeader;
        }
    }
}
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ILCompiler.Assembler")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Hewlett-Packard")]
[assembly: AssemblyProduct("ILCompiler.Assembler")]
[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5624d4e9-3e8b-4185-8d7c-f7543d2b5565")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Add Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Add : DestinationSourceSize
    {
        public Add()
            : base("add")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 And Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class And : DestinationSourceSize
    {
        public And()
            : base("and")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Architecture Listenings
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc
{
    public enum Architecture : int
    {
        None = 0,
        x86  = 1,
        x64 = 2,
        ARM = 3
    };
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          System.Array Plugs
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.Lib.Plugs
{
    internal static class ArrayImpl
    {
        [Plug("System_Void_System_Array_Copy_System_Array__System_Array__System_Int32_", Architecture.x86)]
        internal static void CopyHelper(Array aSourceArray, Array aDestinationArray, int aLength)
        {
            Copy(aSourceArray, 0, aDestinationArray, 0, aLength, false);
        }

        [Plug("System_Void_System_Array_Copy_System_Array__System_Int32__System_Array__System_Int32__System_Int32_", Architecture.x86)]
        internal static void CopyHelper(Array aSourceArray, int aSourceIndex, Array aDestinationArray, int aDestinationIndex, int aLength)
        {
            Copy(aSourceArray, aSourceIndex, aDestinationArray, aDestinationIndex, aLength, false);
        }

        [Assembly(true), Plug("System_Void_System_Array_Copy_System_Array__System_Int32__System_Array__System_Int32__System_Int32__System_Boolean_", Architecture.x86)]
        internal static void Copy(Array aSourceArray, int aSourceIndex, Array aDestinationArray, int aDestinationIndex, int aLength, bool aReliable)
        {
            // Destination
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x14, SourceIndirect = true };
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceDisplacement = 0xC, SourceIndirect = true };
            new Mov { DestinationReg = Register.EBX, SourceReg = Register.EBP, SourceDisplacement = 0x10, SourceIndirect = true };
            new Mul { DestinationReg = Register.EBX };
            new Add { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x14, SourceIndirect = true };
            new Add { DestinationReg = Register.EAX, SourceRef = "0x10" };
            new Mov { DestinationReg = Register.EDI, SourceReg = Register.EAX };

            // Source
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x1C, SourceIndirect = true };
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceDisplacement = 0xC, SourceIndirect = true };
            new Mov { DestinationReg = Register.EBX, SourceReg = Register.EBP, SourceDisplacement = 0x18, SourceIndirect = true };
            new Mul { DestinationReg = Register.EBX };
            new Add { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x1C, SourceIndirect = true };
            new Add { DestinationReg = Register.EAX, SourceRef = "0x10" };
            new Mov { DestinationReg = Register.ESI, SourceReg = Register.EAX };

            // copy
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x14, SourceIndirect = true };
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceDisplacement = 0xC, SourceIndirect = true };
            new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0xC, SourceIndirect = true };
            new Mul { DestinationReg = Register.EDX };
            new Mov { DestinationReg = Register.ECX, SourceReg = Register.EAX };
            new Shr { DestinationReg = Register.ECX, SourceRef = "0x2" };
            new And { DestinationReg = Register.EAX, SourceRef = "0x3" };
            new Literal("rep movsd");
            new Mov { DestinationReg = Register.ECX, SourceReg = Register.EAX };
            new Literal("rep movsb");
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Atomixilc
{
    public class AsmData
    {
        string mKey;
        byte[] mRawData;
        string[] mData;

        public string Key
        { get { return mKey; } }

        public AsmData(string aKey)
        {
            mKey = aKey;
        }

        public AsmData(string aKey, uint aData)
        {
            mKey = aKey;
            mData = new string[1];
            mData[0] = aData.ToString();
        }

        public AsmData(string aKey, uint[] aData)
        {
            mKey = aKey;
            mData = aData.Select(a => a.ToString()).ToArray();
        }

        public AsmData(string aKey, byte[] aData)
        {
            mKey = aKey;
            mRawData = aData;
        }

        public AsmData(string aKey, string[] aData)
        {
            mKey = aKey;
            mData = aData;
        }

        public override string ToString()
        {
            if (mRawData != null)
                return string.Format("{0} db {1}", mKey, string.Join(", ", mRawData.Select(a => a.ToString())));
            else if (mData != null)
                return string.Format("{0} dd {1}", mKey, string.Join(", ", mData.Select(a => a.ToString())));
            else
                return mKey;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Method Assembly Stub Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomixilc.Attributes
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    public class AssemblyAttribute : Attribute
    {
        public readonly bool CalliHeader;

        public AssemblyAttribute(bool requiredCallingHeader = false)
        {
            CalliHeader = requiredCallingHeader;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Beq MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Beq)]
    internal class Beq_il : MSIL
    {
        public Beq_il()
            : base(ILCode.Beq)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Beq(v=vs.110).aspx
         * Description : Transfers control to a target instruction if two values are equal.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is equal to value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Xor { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JZ, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bge MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Bge)]
    internal class Bge_il : MSIL
    {
        public Bge_il()
            : base(ILCode.Bge)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Bge(v=vs.110).aspx
         * Description : Transfers control to a target instruction if the first value is greater than or equal to the second value.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is greater than or equal to value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JGE, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bge_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Bge_Un)]
    internal class Bge_Un_il : MSIL
    {
        public Bge_Un_il()
            : base(ILCode.Bge_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Bge_Un(v=vs.110).aspx
         * Description : Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is greater than or equal to value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JAE, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bgt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Bgt)]
    internal class Bgt_il : MSIL
    {
        public Bgt_il()
            : base(ILCode.Bgt)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Bgt(v=vs.110).aspx
         * Description : Transfers control to a target instruction if the first value is greater than the second value.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is greater than value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JG, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bgt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Bgt_Un)]
    internal class Bgt_Un_il : MSIL
    {
        public Bgt_Un_il()
            : base(ILCode.Bgt_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Bgt_Un(v=vs.110).aspx
         * Description : Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is greater than value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JA, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          System.BitConverter Plugs
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Attributes;

namespace Atomixilc.Lib.Plugs
{
    internal unsafe static class BitConverterImpl
    {
        [Plug("System_UInt32_System_BitConverter_ToUInt32_System_Byte____System_Int32_")]
        internal static uint ToUInt32(byte* aData, int aIndex)
        {
            return *(uint*)(aData + 0x10 + aIndex);
        }

        [Plug("System_Int32_System_BitConverter_ToInt32_System_Byte____System_Int32_")]
        internal static int ToInt32(byte* aData, int aIndex)
        {
            return *(int*)(aData + 0x10 + aIndex);
        }

        [Plug("System_UInt16_System_BitConverter_ToUInt16_System_Byte____System_Int32_")]
        internal static ushort ToUInt16(byte* aData, int aIndex)
        {
            return *(ushort*)(aData + 0x10 + aIndex);
        }

        [Plug("System_Int16_System_BitConverter_ToInt16_System_Byte____System_Int32_")]
        internal static short ToInt16(byte* aData, int aIndex)
        {
            return *(short*)(aData + 0x10 + aIndex);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ble MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ble)]
    internal class Ble_il : MSIL
    {
        public Ble_il()
            : base(ILCode.Ble)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ble(v=vs.110).aspx
         * Description : Transfers control to a target instruction if the first value is less than or equal to the second value.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is less than or equal to value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JLE, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ble_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ble_Un)]
    internal class Ble_Un_il : MSIL
    {
        public Ble_Un_il()
            : base(ILCode.Ble_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ble_Un(v=vs.110).aspx
         * Description : Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is less than or equal to value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JBE, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Blt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Blt)]
    internal class Blt_il : MSIL
    {
        public Blt_il()
            : base(ILCode.Blt)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Blt(v=vs.110).aspx
         * Description : Transfers control to a target instruction if the first value is less than the second value.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is less than value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JL, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Blt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Blt_Un)]
    internal class Blt_Un_il : MSIL
    {
        public Blt_Un_il()
            : base(ILCode.Blt_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Blt_Un(v=vs.110).aspx
         * Description : Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is less than value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JB, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bne_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Bne_Un)]
    internal class Bne_Un_il : MSIL
    {
        public Bne_Un_il()
            : base(ILCode.Bne_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Bne_Un(v=vs.110).aspx
         * Description : Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var offset = ((OpBranch)xOp).Value;
            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; if value1 is not equal to value2, the branch operation is performed.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Jmp { Condition = ConditionalJump.JNE, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Br MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Br)]
    internal class Br_il : MSIL
    {
        public Br_il()
            : base(ILCode.Br)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Br(v=vs.110).aspx
         * Description : Unconditionally transfers control to a target instruction.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var offset = ((OpBranch)xOp).Value;
            var xTrueLabel = Helper.GetLabel(offset);

            /* No evaluation stack behaviors are performed by this operation.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Jmp { DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Brfalse MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Brfalse)]
    internal class Brfalse_il : MSIL
    {
        public Brfalse_il()
            : base(ILCode.Brfalse)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Brfalse(v=vs.110).aspx
         * Description : Transfers control to a target instruction if value is false, a null reference (Nothing in Visual Basic), or zero.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var offset = ((OpBranch)xOp).Value;
            var item = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack by a previous operation.
             * value is popped from the stack; if value is false, branch to target.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Cmp { DestinationReg = Register.EAX, SourceRef = "0x0" };
                        new Jmp { Condition = ConditionalJump.JZ, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Brtrue MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Brtrue)]
    internal class Brtrue_il : MSIL
    {
        public Brtrue_il()
            : base(ILCode.Brtrue)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Brtrue(v=vs.110).aspx
         * Description : Transfers control to a target instruction if value is true, not null, or non-zero.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var offset = ((OpBranch)xOp).Value;
            var item = Optimizer.vStack.Pop();

            var xTrueLabel = Helper.GetLabel(offset);

            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack by a previous operation.
             * value is popped from the stack; if value is true, branch to target.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Cmp { DestinationReg = Register.EAX, SourceRef = "0x0" };
                        new Jmp { Condition = ConditionalJump.JNZ, DestinationRef = xTrueLabel };

                        Optimizer.SaveStack(offset);
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Call Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Call : Instruction
    {
        public bool IsLabel;
        public string DestinationRef;

        public Call()
            : base("call")
        {

        }

        public override string ToString()
        {
            if (DestinationRef.StartsWith("."))
                DestinationRef = Label.Primary + DestinationRef;

            return string.Format("call {0}", DestinationRef);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Callvirt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;
using System.Linq;
using System.Runtime.InteropServices;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Callvirt)]
    internal class Callvirt_il : MSIL
    {
        public Callvirt_il()
            : base(ILCode.Callvirt)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Callvirt(v=vs.110).aspx
         * Description : Calls a late-bound method on an object, pushing the return value onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var xOpMethod = (OpMethod)xOp;
            var functionInfo = xOpMethod.Value as MethodInfo;

            var addressRefernce = functionInfo.FullName();
            var parameters = functionInfo.GetParameters();

            var size = parameters.Sum(a => Helper.GetTypeSize(a.ParameterType, Config.TargetPlatform, true));
            int returnSize = 0;
            if (functionInfo != null)
                returnSize = Helper.GetTypeSize(functionInfo.ReturnType, Config.TargetPlatform, true);

            int count = parameters.Length;
            if (!functionInfo.IsStatic)
                count++;

            if (Optimizer.vStack.Count < count)
                throw new Exception("Internal Compiler Error: vStack.Count < expected size");

            if (xOpMethod.CallingConvention != CallingConvention.StdCall)
                throw new Exception(string.Format("CallingConvention '{0}' not supported", xOpMethod.CallingConvention));

            /* The stack transitional behavior, in sequential order, is:
             * An object reference obj is pushed onto the stack.
             * Method arguments arg1 through argN are pushed onto the stack.
             * Method arguments arg1 through argN and the object reference obj are popped from the stack;
             * the method call is performed with these arguments and control is transferred to the method
             * in obj referred to by the method metadata token. When complete, a return value is generated
             * by the callee method and sent to the caller.
             * The return value is pushed onto the stack.
             */

            while (count > 0)
            {
                Optimizer.vStack.Pop();
                count--;
            }

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (returnSize > 8)
                            throw new Exception(string.Format("UnImplemented '{0}' Return-type: '{1}'", msIL, functionInfo.ReturnType));

                        if (functionInfo.IsStatic || functionInfo.IsFinal || !functionInfo.IsVirtual || !functionInfo.IsAbstract)
                        {
                            new Call { DestinationRef = addressRefernce };
                            new Test { DestinationReg = Register.ECX, SourceRef = "0xFFFFFFFF" };
                            new Jmp { Condition = ConditionalJump.JNZ, DestinationRef = xOp.HandlerRef };
                            Optimizer.SaveStack(xOp.HandlerPosition);
                        }
                        else
                        {
                            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = size, SourceIndirect = true };
                            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceIndirect = true };

                            new Push { DestinationRef = Helper.VTable_Flush };
                            new Push { DestinationRef = "0x" + xOpMethod.MethodUID.ToString("X") };
                            new Push { DestinationReg = Register.EAX };
                            new Call { DestinationRef = Helper.VTable_Label, IsLabel = true };
                            new Test { DestinationReg = Register.ECX, SourceRef = "0xFFFFFFFF" };
                            new Jmp { Condition = ConditionalJump.JNZ, DestinationRef = xOp.HandlerRef };
                            Optimizer.SaveStack(xOp.HandlerPosition);

                            if (functionInfo.DeclaringType == typeof(object))
                                throw new Exception("Callvirt Object Declaring type not implemented");

                            new Call { DestinationRef = "EAX" };
                            new Test { DestinationReg = Register.ECX, SourceRef = "0xFFFFFFFF" };
                            new Jmp { Condition = ConditionalJump.JNZ, DestinationRef = xOp.HandlerRef };
                        }

                        if (functionInfo.ReturnType != typeof(void))
                        {
                            if (returnSize == 8)
                                new Push { DestinationReg = Register.EDX };
                            new Push { DestinationReg = Register.EAX };
                            Optimizer.vStack.Push(new StackItem(functionInfo.ReturnType));
                        }

                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Cdq Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Cdq : Instruction
    {
        public Cdq()
            :base("cdq")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ceq MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ceq)]
    internal class Ceq_il : MSIL
    {
        public Ceq_il()
            : base(ILCode.Ceq)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ceq(v=vs.110).aspx
         * Description : Compares two values. If they are equal, the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xCurrentLabel = Helper.GetLabel(xOp.Position);
            var xNextLabel = Helper.GetLabel(xOp.NextPosition);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; value1 is compared to value2.
             * If value1 is equal to value2, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Sete { DestinationReg = Register.AL };
                        new Movzx { DestinationReg = Register.EAX, SourceReg = Register.AL, Size = 8 };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(bool)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Cgt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Cgt)]
    internal class Cgt_il : MSIL
    {
        public Cgt_il()
            : base(ILCode.Cgt)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Cgt(v=vs.110).aspx
         * Description : Compares two values. If the first value is greater than the second, the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xCurrentLabel = Helper.GetLabel(xOp.Position);
            var xNextLabel = Helper.GetLabel(xOp.NextPosition);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; cgt tests if value1 is greater than value2.
             * If value1 is greater than value2, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Setg { DestinationReg = Register.AL };
                        new Movzx { DestinationReg = Register.EAX, SourceReg = Register.AL, Size = 8 };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(bool)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Cgt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Cgt_Un)]
    internal class Cgt_Un_il : MSIL
    {
        public Cgt_Un_il()
            : base(ILCode.Cgt_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Cgt_Un(v=vs.110).aspx
         * Description : Compares two unsigned or unordered values. If the first value is greater than the second, the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xCurrentLabel = Helper.GetLabel(xOp.Position);
            var xNextLabel = Helper.GetLabel(xOp.NextPosition);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; cgt.un tests if value1 is greater than value2.
             * If value1 is greater than value2, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Seta { DestinationReg = Register.AL };
                        new Movzx { DestinationReg = Register.EAX, SourceReg = Register.AL, Size = 8 };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(bool)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Cli Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Cli : Instruction
    {
        public Cli()
            : base("cli")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Clt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Clt_Un)]
    internal class Clt_Un_il : MSIL
    {
        public Clt_Un_il()
            : base(ILCode.Clt_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Clt_Un(v=vs.110).aspx
         * Description : Compares the unsigned or unordered values value1 and value2. If value1 is less than value2, then the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var xCurrentLabel = Helper.GetLabel(xOp.Position);
            var xNextLabel = Helper.GetLabel(xOp.NextPosition);

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; clt.un tests if value1 is less than value2.
             * If value1 is less than value2, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };
                        new Cmp { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Setb { DestinationReg = Register.AL };
                        new Movzx { DestinationReg = Register.EAX, SourceReg = Register.AL, Size = 8 };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(bool)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Cmp Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Cmp : DestinationSourceSize
    {
        public Cmp()
            : base("cmp")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Assembly Comment
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine
{
    public class Comment : Instruction
    {
        string mMessage;

        public Comment(string aMessage)
            : base(string.Empty)
        {
            mMessage = aMessage;
        }

        public override string ToString()
        {
            return string.Format("; {0}", mMessage);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler entrypoint
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Reflection;
using Emit = System.Reflection.Emit;
using System.Collections.Generic;
using System.Runtime.InteropServices;

using Atomixilc.IL;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc
{
    internal class Compiler
    {
        /// <summary>
        /// Compiler Configurations
        /// </summary>
        Options Config;

        /// <summary>
        /// Input Assembly Entrypoint from which Kernel should be loaded
        /// </summary>
        Type Entrypoint;

        /// <summary>
        /// ILCode to Compiler's MSIL Implementation mapping
        /// </summary>
        Dictionary<ILCode, MSIL> ILCodes;

        /// <summary>
        /// IL byte code to OpCode Type mapping
        /// </summary>
        Dictionary<short, Emit.OpCode> OpCode;

        /// <summary>
        /// MethodBase (override Implementation) to target method's label mapping
        /// </summary>
        Dictionary<MethodBase, string> Plugs;

        /// <summary>
        /// Unique ID to Methodbase (Implementaion) mapping
        /// </summary>
        Dictionary<string, MethodBase> Labels;

        /// <summary>
        /// Compiler Scanner Queue
        /// </summary>
        Queue<object> ScanQ;

        /// <summary>
        /// Compiler Processed Item set
        /// </summary>
        HashSet<object> FinishedQ;

        /// <summary>
        /// Processed String Entries set
        /// </summary>
        HashSet<string> StringTable;

        /// <summary>
        /// Exportable MethodInfo from ELF Image
        /// </summary>
        HashSet<MethodInfo> Globals;

        /// <summary>
        /// External Symbols
        /// </summary>
        HashSet<MethodBase> Externals;

        /// <summary>
        /// Inherit methods
        /// </summary>
        HashSet<MethodInfo> Virtuals;

        /// <summary>
        /// Processed Code blocks
        /// </summary>
        List<FunctionalBlock> CodeSegment;

        /// <summary>
        /// Processed Bss Entries
        /// </summary>
        Dictionary<string, Type> ZeroSegment;

        /// <summary>
        /// Processed Data Entries
        /// </summary>
        Dictionary<string, AsmData> DataSegment;

        /// <summary>
        /// Compiler Constructor
        /// </summary>
        /// <param name="aCompilerOptions">Configurations</param>
        internal Compiler(Options aCompilerOptions)
        {
            Config = aCompilerOptions;

            PrepareEnvironment();
        }

        /// <summary>
        /// Initialise variables and load MSIL, OpCode, ByteCode mappings
        /// </summary>
        internal void PrepareEnvironment()
        {
            var ExecutingAssembly = Assembly.GetExecutingAssembly();

            ILCodes = new Dictionary<ILCode, MSIL>();
            Plugs = new Dictionary<MethodBase, string>();
            Labels = new Dictionary<string, MethodBase>();
            ScanQ = new Queue<object>();
            FinishedQ = new HashSet<object>();
            Virtuals = new HashSet<MethodInfo>();
            Globals = new HashSet<MethodInfo>();
            Externals = new HashSet<MethodBase>();
            OpCode = new Dictionary<short, Emit.OpCode>();

            ZeroSegment = new Dictionary<string, Type>();
            DataSegment = new Dictionary<string, AsmData>();
            CodeSegment = new List<FunctionalBlock>();
            StringTable = new HashSet<string>();

            /* load OpCode <-> MSIL Implementation mapping */
            var types = ExecutingAssembly.GetTypes();
            foreach (var type in types)
            {
                var ILattributes = type.GetCustomAttributes<ILImplAttribute>();
                foreach (var attrib in ILattributes)
                {
                    Verbose.Message("[MSIL] {0}", type.ToString());
                    ILCodes.Add(attrib.OpCode, (MSIL)Activator.CreateInstance(type));
                }
            }

            /* load byte code to OpCode type mapping */
            var ilOpcodes = typeof(Emit.OpCodes).GetFields(BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public);
            foreach (var xField in ilOpcodes)
            {
                var xOpCode = (Emit.OpCode)xField.GetValue(null);
                Verbose.Message("[OpCode] {0} [0x{1}]", xOpCode, xOpCode.Value.ToString("X4"));
                OpCode.Add(xOpCode.Value, xOpCode);
            }
        }

        /// <summary>
        /// Clean previous session of compiler and execute new compilation stage
        /// </summary>
        internal void Execute()
        {
            /* clean up mess we've created in last session :P */
            ScanQ.Clear();
            Globals.Clear();
            Virtuals.Clear();
            Externals.Clear();
            FinishedQ.Clear();
            ZeroSegment.Clear();
            DataSegment.Clear();
            CodeSegment.Clear();
            StringTable.Clear();

            /* so much mess around :P */
            Helper.DataSegment.Clear();
            Helper.ZeroSegment.Clear();
            Helper.cachedFieldLabel.Clear();
            Helper.cachedMethodLabel.Clear();
            Helper.cachedResolvedStringLabel.Clear();

            Entrypoint = null;

            /* Anyways, time to scan our new Assembly */
            ScanInputAssembly(out Entrypoint);

            /* why on earth somebody would do this mistake
             * but you never know, what is going in a programmer's brain :P
             * they sometime really don't know what they are doing :P
             */
            if (Entrypoint == null)
                throw new Exception("No input entrypoint found");

            /* Anyways, I am adding all these kind of exceptions throughout the compiler
             * because I know, sometime I act very stupid
             */
            var main = Entrypoint.GetMethod("main");
            if (main == null)
                throw new Exception("No main function found");

            /* I will be speechless if somebody asked me why to Enqueue main function :P */
            ScanQ.Enqueue(main);
            IncludePlugAndLibrary();

            /* The real work :D kidding :P */
            while (ScanQ.Count != 0)
            {
                var ScanObject = ScanQ.Dequeue();

                if (FinishedQ.Contains(ScanObject))
                    continue;

                /* while writing this code, I though there could be a lot of ways
                 * to write this branch, but hey what is the most beautiful way?
                 * now look below, Isn't it look beautiful? full of symmetry
                 * Thanks me later :P
                 */

                /* Some serious stuff :p
                 * Though ScanQ Enqueue Objects but compiler assume it only of these three types
                 */

                var method = ScanObject as MethodBase;
                if (method != null)
                {
                    Verbose.Message("Scanning Method : {0}", method.FullName());
                    ScanMethod(method);
                    continue;
                }

                var type = ScanObject as Type;
                if (type != null)
                {
                    Verbose.Message("Scanning Type : {0}", type.FullName);
                    ScanType(type);
                    continue;
                }

                var field = ScanObject as FieldInfo;
                if (field != null)
                {
                    Verbose.Message("Scanning Field : {0}", field.FullName());
                    ProcessFieldInfo(field);
                    continue;
                }

                throw new Exception(string.Format("Invalid Object in Queue of type '{0}'", ScanObject.GetType()));
            }
        }

        /// <summary>
        /// Flush Compiler output
        /// </summary>
        internal void Flush()
        {
            FlushVTables();
            FlushStringTable();

            /* Hack? Issue: #55 */
            if (Verbose.ErrorCounter > 0)
                Verbose.Error("Errors: {0}", Verbose.ErrorCounter);

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    Flushx86();
                    break;
                default:
                    throw new Exception("Unsupported Flush Platform");
            }
        }

        /// <summary>
        /// Flush method targeting x86 arch only
        /// </summary>
        private void Flushx86()
        {
            using (var SW = new StreamWriter(Config.OutputFile))
            {
                var attrib = Entrypoint.GetCustomAttribute<EntrypointAttribute>();
                if (attrib == null)
                    throw new Exception("Internal compiler error");

                /* Assembly header */
                SW.WriteLine("global entrypoint");
                SW.WriteLine(string.Format("entrypoint equ {0}", attrib.Entrypoint));

                /* Global Symbols */
                foreach (var global in Globals)
                    SW.WriteLine(string.Format("global {0}", global.FullName()));
                SW.WriteLine();

                /* External Symbols */
                foreach (var method in Externals)
                    SW.WriteLine(string.Format("extern {0}", method.FullName()));
                SW.WriteLine();

                /* BSS Section */
                SW.WriteLine("section .bss");
                foreach (var bssEntry in Helper.ZeroSegment)
                    SW.WriteLine(string.Format("{0} resb {1}", bssEntry.Key, bssEntry.Value));

                /* BSS - Global Variable Section */
                var bssEntries = ZeroSegment.ToList();
                bssEntries.Sort((x, y) => y.Value.IsClass.CompareTo(x.Value.IsClass));

                int index = 0, count = bssEntries.Count;

                /* GC Root Start */
                SW.WriteLine(Helper.GC_Root_Start + ":");
                for (; index < count; index++)
                {
                    var entry = bssEntries[index];
                    int size = Helper.GetTypeSize(entry.Value, Config.TargetPlatform);
                    if (!entry.Value.IsClass)
                        break;
                    SW.WriteLine(string.Format("{0} resb {1}", entry.Key, size));
                }
                SW.WriteLine(Helper.GC_Root_End + ":");
                /* GC Root End */

                for (; index < count; index++)
                {
                    var entry = bssEntries[index];
                    int size = Helper.GetTypeSize(entry.Value, Config.TargetPlatform, true);// align it
                    SW.WriteLine(string.Format("{0} resb {1}", entry.Key, size));
                }

                /* End of Global Variables Section */

                SW.WriteLine();

                /* Data Section */
                SW.WriteLine("section .data");
                foreach (var dataEntry in Helper.DataSegment)
                    SW.WriteLine(dataEntry);
                foreach (var dataEntry in DataSegment)
                    SW.WriteLine(dataEntry.Value);
                SW.WriteLine();

                /* Code Section */
                SW.WriteLine("section .text");
                foreach (var block in CodeSegment)
                {
                    var xbody = block.Body;
                    foreach (var code in xbody)
                    {
                        /* Some styping and indentation thing, because I love beautiful code :P */
                        if (!(code is Label))
                            SW.Write("    ");
                        else
                            SW.WriteLine();

                        /* Is this a call by label name?
                         * yes, replace label with original label name
                         */
                        if (code is Call)
                        {
                            var xCall = (Call)code;
                            if (xCall.IsLabel)
                            {
                                xCall.IsLabel = false;
                                xCall.DestinationRef = Labels[xCall.DestinationRef].FullName();
                            }
                        }

                        SW.WriteLine(code);
                    }
                    /* some more styling */
                    SW.WriteLine();
                }

                SW.WriteLine(Helper.Compiler_End + ":");

                SW.Flush();
                SW.Close();
            }
        }

        /// <summary>
        /// Flush string table, create data entries for all discovered strings
        /// </summary>
        private void FlushStringTable()
        {
            var encoding = Encoding.Unicode;
            foreach(var str in StringTable)
            {
                int count = encoding.GetByteCount(str);
                var data = new byte[count + 0x10];

                /* String Entry
                 *      |string_type_id|        : typeof(string).GetHashCode()
                 *      |"0x1"|                 : object identifier ID "0x1" : object, "0x2" : array
                 *      |entry_size|            : total memory length in bytes
                 *      |string_length|         : string length in characters
                 *      |char_0|                : data entry
                 *      |char_1|
                 *        ...
                 */

                Array.Copy(BitConverter.GetBytes(typeof(string).GetHashCode()), 0, data, 0, 4);
                Array.Copy(BitConverter.GetBytes(0x1), 0, data, 4, 4);
                Array.Copy(BitConverter.GetBytes(data.Length), 0, data, 8, 4);
                Array.Copy(BitConverter.GetBytes(str.Length), 0, data, 12, 4);
                Array.Copy(encoding.GetBytes(str), 0, data, 16, count);

                var label = Helper.GetResolvedStringLabel(str);
                DataSegment.Add(label, new AsmData(label, data));
            }
        }

        /// <summary>
        /// FlushVTable to create a lookup table in datasegment
        /// </summary>
        private void FlushVTables()
        {
            /* VTables are implemented based on the idea of lookup tables
             * Structure:
             *      |next_block_offset|             : points to next block offset
             *      |method_uid|                    : MethodBase UID
             *          |method_address||type_id|   : MethodInfo Address and DeclaringType ID
             *          |method_address||type_id|
             *          |method_address||type_id|
             *          |"0"|                       : End of this block
             *      |next_block_offset|
             *      |method_uid|
             *          |method_address||type_id|
             *          |method_address||type_id|
             *          |method_address||type_id|
             *          |"0"|
             *      |"0"|                           : End of VTable
             */

            var count = new Dictionary<int, int>();
            var tables = new List<KeyValuePair<int, MethodInfo> >();
            foreach(var method in Virtuals)
            {
                var baseDef = method.GetBaseDefinition();
                if (!baseDef.IsAbstract)
                    continue;

                int UID = baseDef.GetHashCode();

                if (count.ContainsKey(UID))
                    count[UID]++;
                else
                    count.Add(UID, 1);

                tables.Add(new KeyValuePair<int, MethodInfo>(UID, method));
            }

            tables.Sort((x, y) => x.Key.CompareTo(y.Key));

            var methodgroup = count.ToList();
            methodgroup.Sort((x, y) => x.Key.CompareTo(y.Key));

            int index = 0;
            List<string> data = new List<string>();
            foreach(var methodgroupitem in methodgroup)
            {
                var offset = (methodgroupitem.Value * 2) + 3;
                data.Add(offset.ToString()); // methods count
                data.Add(methodgroupitem.Key.ToString()); // method UID
                for (;  index < tables.Count; index++)
                {
                    var item = tables[index];
                    if (item.Key != methodgroupitem.Key)
                        break;
                    data.Add(item.Value.FullName()); // method address
                    data.Add(item.Value.DeclaringType.GetHashCode().ToString()); // type ID
                }

                data.Add("0");
            }

            data.Add("0");

            DataSegment.Add(Helper.VTable_Flush, new AsmData(Helper.VTable_Flush, data.ToArray()));
        }

        /// <summary>
        /// Include Compiler Provided Libraries
        /// </summary>
        internal void IncludePlugAndLibrary()
        {
            /* Hey, I know what you are thinking
             * this code doesn't look good, right?
             * But you don't know how it feels to debug the whole compiler continously for 3 days
             * that much of debugging completely drain your skills :P
             * don't mess up this code, and move forward
             */
            ScanQ.Enqueue(typeof(Lib.Libc));
            ScanQ.Enqueue(typeof(Lib.VTable));
            ScanQ.Enqueue(typeof(Lib.Memory));
            ScanQ.Enqueue(typeof(Lib.Native));
            ScanQ.Enqueue(typeof(Lib.Plugs.ArrayImpl));
            ScanQ.Enqueue(typeof(Lib.Plugs.StringImpl));
            ScanQ.Enqueue(typeof(Lib.Plugs.ExceptionImpl));
            ScanQ.Enqueue(typeof(Lib.Plugs.BitConverterImpl));

            foreach (var plug in Plugs)
                ScanQ.Enqueue(plug.Key);

            foreach (var label in Labels)
                ScanQ.Enqueue(label.Value);
        }

        /// <summary>
        /// Scan Input assembly for entrypoint, plugs/labels
        /// </summary>
        /// <param name="Entrypoint"></param>
        internal void ScanInputAssembly(out Type Entrypoint)
        {
            var InputAssembly = Assembly.LoadFile(Config.InputFiles[0]);

            var types = InputAssembly.GetTypes();

            Entrypoint = null;
            Plugs.Clear();
            Labels.Clear();
            foreach (var type in types)
            {
                var entrypointattrib = type.GetCustomAttribute<EntrypointAttribute>();
                if (entrypointattrib != null && entrypointattrib.Platform == Config.TargetPlatform)
                {
                    if (Entrypoint != null)
                        throw new Exception("Multiple Entrypoint with same target platform");
                    Entrypoint = type;
                }

                var methods = type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
                foreach (var method in methods)
                {
                    /* look for plugs */
                    var plugattrib = method.GetCustomAttribute<PlugAttribute>();
                    if (plugattrib != null && plugattrib.Platform == Config.TargetPlatform)
                    {
                        if (Plugs.ContainsValue(plugattrib.TargetLabel))
                            throw new Exception(string.Format("Multiple plugs with same target label '{0}'", plugattrib.TargetLabel));
                        Verbose.Message("[Plug] {0} : {1}", plugattrib.TargetLabel, method.FullName());
                        method.AddPlug(plugattrib.TargetLabel);
                        Plugs.Add(method, plugattrib.TargetLabel);
                    }

                    /* look for labels */
                    var labelattrib = method.GetCustomAttribute<LabelAttribute>();
                    if (labelattrib != null)
                    {
                        if (Labels.ContainsKey(labelattrib.RefLabel))
                            throw new Exception(string.Format("Multiple labels with same Ref label '{0}'", labelattrib.RefLabel));
                        Verbose.Message("[Label] {0} : {1}", labelattrib.RefLabel, method.FullName());
                        Labels.Add(labelattrib.RefLabel, method);
                    }
                }
            }
        }

        /// <summary>
        /// Scan type for constructors, plugs, labels and virtuals
        /// </summary>
        /// <param name="type"></param>
        internal void ScanType(Type type)
        {
            if (type.BaseType != null)
                ScanQ.Enqueue(type.BaseType);

            /* Scan for constructors */
            var constructors = type.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public);
            foreach (var ctor in constructors)
            {
                if (ctor.DeclaringType != type)
                    continue;
                ScanQ.Enqueue(ctor);
            }

            /* Scan for plugs/labels */
            var methods = type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
            foreach (var method in methods)
            {
                /* You might ask, why I am scanning plugs/labels again (ScanInputAssembly already doing this)
                 * well the reason is, ScanInputAssembly is called for scanning input assembly only
                 * but we are inserting compiler implementations too in build process
                 * they might also have plugs/labels
                 */

                /* scan plugs */
                var plugattrib = method.GetCustomAttribute<PlugAttribute>();
                if (plugattrib != null && !Plugs.ContainsKey(method))
                {
                    ScanQ.Enqueue(method);
                    method.AddPlug(plugattrib.TargetLabel);
                    Plugs.Add(method, plugattrib.TargetLabel);
                    Verbose.Message("[Plug] {0} : {1}", plugattrib.TargetLabel, method.FullName());
                }

                /* scan labels */
                var labelattrib = method.GetCustomAttribute<LabelAttribute>();
                if (labelattrib != null && !Labels.ContainsKey(labelattrib.RefLabel))
                {
                    ScanQ.Enqueue(method);
                    Labels.Add(labelattrib.RefLabel, method);
                    Verbose.Message("[Label] {0} : {1}", labelattrib.RefLabel, method.FullName());
                }
            }

            /* Scan for virtual methods */
            methods = type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);
            foreach (var method in methods)
            {
                var basedefination = method.GetBaseDefinition();

                if (Virtuals.Contains(method) ||
                    !basedefination.IsAbstract ||
                    method.DeclaringType.IsAbstract ||
                    basedefination.DeclaringType == method.DeclaringType)
                    continue;

                Virtuals.Add(method);
                ScanQ.Enqueue(method);
            }

            FinishedQ.Add(type);
        }

        /// <summary>
        /// Scan Method and process if recognized format
        /// </summary>
        /// <param name="method">Method function</param>
        internal void ScanMethod(MethodBase method)
        {
            FunctionalBlock block = null;

            /* Hey? Is this label exportable? */
            if (!Helper.RestrictedAssembly.Contains(method.DeclaringType.Assembly.GetName().Name)
                && method.IsPublic
                && method.DeclaringType.IsVisible
                && (method as MethodInfo) != null)
                Globals.Add((MethodInfo)method);

            /* Wow! Is it somekind of special method? :P */

            /* Assembly method */
            if (method.GetCustomAttribute<AssemblyAttribute>() != null)
                ProcessAssemblyMethod(method, ref block);

            /* Dll Import? Dynamic external function */
            else if (method.GetCustomAttribute<DllImportAttribute>() != null)
                ProcessExternMethod(method, ref block);

            /* Is this a delegate? wow! */
            else if (typeof(Delegate).IsAssignableFrom(method.DeclaringType))
                ProcessDelegate(method, ref block);

            /* lol, sorry It was just a normal method :P */
            else
                ProcessMethod(method, ref block);

            /* no function body? great! You're dead for me now */
            if (block != null)
                CodeSegment.Add(block);

            /* I am not going to treat you again :P */
            FinishedQ.Add(method);
        }

        /// <summary>
        /// Process Assembly attributed function
        /// </summary>
        /// <param name="method">method function</param>
        /// <param name="block">code block</param>
        internal void ProcessAssemblyMethod(MethodBase method, ref FunctionalBlock block)
        {
            var attrib = method.GetCustomAttribute<AssemblyAttribute>();
            /* bwahahha, though this method is being called by ScanMethod only so, this attrib should not be null!
             * but I really don't myself when I am coding sleepless
             */
            if (attrib == null)
                throw new Exception("Invalid call to ProcessAssemblyMethod");

            if (attrib.CalliHeader == false && method.GetCustomAttribute<NoExceptionAttribute>() == null)
                Verbose.Error("NoException Attribute not present '{0}' CalliHeader == false", method.FullName());

            /* I am sure captain that we have discovered something, can we have our new functional block? */
            block = new FunctionalBlock(method.FullName(), Config.TargetPlatform, CallingConvention.StdCall);

            /* Instructions capturing ON! */
            Instruction.Block = block;

            /* Function entry label */
            new Label(method.FullName());

            /* Some assembly method don't really need a calliHeader -- Optimization thing */
            if (attrib.CalliHeader)
                EmitHeader(block, method, 0);

            /* This is the simplest method processing, all you have to do is, execute that function
             * Instruction will be created and captured by Instruction.Block hence our fucntions block
             */
            try
            {
                method.Invoke(null, new object[method.GetParameters().Length]);
            }
            catch (Exception e)
            {
                throw new Exception(string.Format("Exception occured while invoking assembly function '{0}' => {1}", method.FullName(), e.ToString()));
            }

            /* No header so no footer :P */
            if (attrib.CalliHeader)
                EmitFooter(block, method);

            /* this isn't necessary, but again I can't take bet on my sleepless coding :P */
            Instruction.Block = null;
        }

        /// <summary>
        /// Process dynamic loadable methods
        /// </summary>
        /// <param name="method"></param>
        /// <param name="block"></param>
        internal void ProcessExternMethod(MethodBase method, ref FunctionalBlock block)
        {
            var attrib = method.GetCustomAttribute<DllImportAttribute>();
            if (attrib == null)
                throw new Exception("Invalid call to ProcessExternMethod");

            Externals.Add(method);
            Verbose.Message("Extern Method Found '{0}'", method.FullName());
        }

        /// <summary>
        /// Process and Add fieldInfo data/entry
        /// </summary>
        /// <param name="fieldInfo"></param>
        internal void ProcessFieldInfo(FieldInfo fieldInfo)
        {
            var name = fieldInfo.FullName();

            /* simply add this to BSS segment with given size */
            InsertData(name, fieldInfo.FieldType);
            FinishedQ.Add(fieldInfo);
        }

        /// <summary>
        /// Helper function to add data to BSS segment
        /// </summary>
        /// <param name="name"></param>
        /// <param name="size"></param>
        internal void InsertData(string name, Type fieldtype)
        {
            /* Again I can't take bet on my stupidity */
            if (ZeroSegment.ContainsKey(name))
            {
                if (ZeroSegment[name] != fieldtype)
                    /* please log, if I did some stupidity */
                    Verbose.Error("Two different type for same field label '{0}' : '{1}' '{2}'", name, ZeroSegment[name], fieldtype.Name);
                return;
            }

            ZeroSegment.Add(name, fieldtype);
        }

        /// <summary>
        /// Process Delegates
        /// </summary>
        /// <param name="method"></param>
        /// <param name="block"></param>
        internal void ProcessDelegate(MethodBase method, ref FunctionalBlock block)
        {
            /* This is difficult to explain :p believe me, I wasted a lot of time in designing and optimizing this stuff :P
             * But I am going to explain it :P hahaha ready? scroll down!
             */

            /* two important methods are implemented, "constructor" and "invoke" */
            if (method.Name == ".ctor")
            {
                /* constructor */
                block = new FunctionalBlock(method.FullName(), Config.TargetPlatform, CallingConvention.StdCall);
                Instruction.Block = block;

                /* method signature: void.ctor(System.Object, IntPtr)
                 * because this is non-static method, original signature would be : void.ctor(memory, System.Object, IntPtr)
                 * memory points to just allocated memory for this delegate, so we can use it to store info
                 * 0xC byte size metadata -- added by compiler
                 * [memory + 0xC] := IntPtr
                 * [memory + 0x10] := System.Object
                 */

                new Label(method.FullName());

                EmitHeader(block, method, 0);
                new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x10, SourceIndirect = true };
                new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
                // [Memory + 0xC] := Intptr
                new Mov { DestinationReg = Register.EAX, DestinationDisplacement = 0xC, DestinationIndirect = true, SourceReg = Register.EDX };
                new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0xC, SourceIndirect = true };
                // [Memory + 0x10] := Object
                new Mov { DestinationReg = Register.EAX, DestinationDisplacement = 0x10, DestinationIndirect = true, SourceReg = Register.EDX };
                EmitFooter(block, method);

                Instruction.Block = null;
            }
            else if (method.Name == "Invoke")
            {
                block = new FunctionalBlock(method.FullName(), Config.TargetPlatform, CallingConvention.StdCall);
                Instruction.Block = block;

                /* Ah! I really can't explain this :P It was so difficult to write
                 * method signature : void Invoke(memory, params ...)
                 * check if System.Object [memory + 0x10] is null or not
                 * if null, simply call Intptr [memory + 0xC] after pushing params on to the stack
                 * if not null, first push System.Object [memory + 0x10] then push push params and then call Intptr [memory + 0xC]
                 */

                // Return-Type Invoke(params)
                new Label(method.FullName());

                int ESPOffset = 4;
                var xparams = method.GetParameters();

                foreach (var par in xparams)
                    ESPOffset += Helper.GetTypeSize(par.ParameterType, Config.TargetPlatform, true);

                new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = ESPOffset, SourceIndirect = true };
                new Add { DestinationReg = Register.EAX, SourceRef = "0xC" };
                new Cmp { DestinationReg = Register.EAX, DestinationDisplacement = 0x4, DestinationIndirect = true, SourceRef = "0x0" };
                new Jmp { Condition = ConditionalJump.JNE, DestinationRef = ".push_object_ref" };

                new Pop { DestinationReg = Register.EDX };
                new Mov { DestinationReg = Register.ESP, DestinationDisplacement = ESPOffset - 4, DestinationIndirect = true, SourceReg = Register.EDX };
                new Call { DestinationRef = "[EAX]" };
                new Ret { Offset = 0 };

                new Label(".push_object_ref");
                new Push { DestinationReg = Register.EAX, DestinationDisplacement = 0x4, DestinationIndirect = true };
                for (int i = ESPOffset; i > 4; i -= 4)
                    new Push { DestinationReg = Register.ESP, DestinationDisplacement = ESPOffset, DestinationIndirect = true };

                new Call { DestinationRef = "[EAX]" };

                new Ret { Offset = (byte)ESPOffset };

                Instruction.Block = null;
            }
            else
            {
                /* wohooo! Aman didn't implement you. just go to hell! :P */
                Verbose.Error("Unimplemented delegate function '{0}'", method.Name);
            }
        }

        /// <summary>
        /// Process normal method body
        /// </summary>
        /// <param name="method"></param>
        /// <param name="block"></param>
        internal void ProcessMethod(MethodBase method, ref FunctionalBlock block)
        {
            var Body = method.GetMethodBody();
            if (Body == null)
            {
                /* wow! you don't have a body? Great! */
                Verbose.Warning("Body == null");
                return;
            }

            var MethodName = method.FullName();

            /* You are not allowed sir! if you have been implemented by a plug */
            if (Plugs.ContainsValue(MethodName) && !Plugs.ContainsKey(method))
                return;

            /* Some dark magic is happening below; I a not going to explain everything :p */
            var parameters = method.GetParameters();
            foreach(var param in parameters)
            {
                ScanQ.Enqueue(param.ParameterType);
            }

            var localvars = Body.LocalVariables;

            int bodySize = 0;
            foreach(var localvar in localvars)
            {
                bodySize += Helper.GetTypeSize(localvar.LocalType, Config.TargetPlatform, true);
                ScanQ.Enqueue(localvar.LocalType);
            }

            block = new FunctionalBlock(MethodName, Config.TargetPlatform, CallingConvention.StdCall);
            Instruction.Block = block;

            new Label(method.FullName());

            if (method.IsStatic && method is ConstructorInfo)
            {
                /* Is static? Is constructor? hey you can't be called more than once */
                EmitConstructor(block, method);
            }

            EmitHeader(block, method, bodySize);

            var ReferencedPositions = new HashSet<int>();
            var xOpCodes = EmitOpCodes(method, ReferencedPositions).ToDictionary(IL => IL.Position);

            var ILQueue = new Queue<int>();
            ILQueue.Enqueue(0);

            var ILBlocks = new Dictionary<int, FunctionalBlock>();
            var Optimizer = new Optimizer(Config, ILQueue);
            while(ILQueue.Count != 0)
            {
                int index = ILQueue.Dequeue();

                /* Create room for new IL and add it to Blocks List */
                var xOp = xOpCodes[index];
                if (xOp == null) continue;

                xOpCodes[index] = null;

                var tempBlock = new FunctionalBlock(null, Config.TargetPlatform, CallingConvention.StdCall);
                Instruction.Block = tempBlock;
                ILBlocks.Add(xOp.Position, tempBlock);

                /* scan inline OpCodes, maybe we get some treasure */
                if (xOp is OpMethod)
                    /* Wow! I found a method, Lucky me :P */
                    ScanQ.Enqueue(((OpMethod)xOp).Value);
                else if (xOp is OpType)
                    /* Wow! I found a Type, Great! xD */
                    ScanQ.Enqueue(((OpType)xOp).Value);
                else if (xOp is OpField)
                {
                    /* Wow! I found a field, Cool */
                    var xOpField = ((OpField)xOp).Value;
                    ScanQ.Enqueue(xOpField.DeclaringType);
                    if (xOpField.IsStatic)
                        ScanQ.Enqueue(xOpField);
                }
                else if (xOp is OpToken)
                {
                    /* Ah! I found a toek, Thanks :) */
                    var xOpToken = (OpToken)xOp;
                    if (xOpToken.IsType)
                        ScanQ.Enqueue(xOpToken.ValueType);
                    else if (xOpToken.IsField)
                    {
                        ScanQ.Enqueue(xOpToken.ValueField.DeclaringType);
                        if (xOpToken.ValueField.IsStatic)
                            ScanQ.Enqueue(xOpToken.ValueField);
                    }
                }
                else if (xOp is OpString)
                {
                    /* Please! no more treasure :P */
                    var xOpStr = (OpString)xOp;
                    StringTable.Add(xOpStr.Value);
                }

                /* Thank god, It's over xD */

                /* Add label to branch/refernced locations */
                if (ReferencedPositions.Contains(xOp.Position))
                    new Label(Helper.GetLabel(xOp.Position));

                /* Load state of dynamic state */
                Optimizer.LoadStack(xOp.Position);

                if (xOp.NeedHandler)
                {
                    /* sir You asked me load execption object onto the stack? sure sir! */
                    EmitExceptionHandler(block, method);
                    Optimizer.vStack.Push(new StackItem(typeof(Exception)));
                }

                /* darkest magic of all time */
                MSIL ILHandler = null;
                ILCodes.TryGetValue(xOp.ILCode, out ILHandler);
                if (ILHandler == null)
                {
                    /* please I can't implement more IL code */
                    new Comment(string.Format("Unimplemented ILCode '{0}'", xOp.ILCode));
                    Verbose.Error("Unimplemented ILCode '{0}'", xOp.ILCode);
                }
                else
                {
                    new Comment(string.Format("[{0}] : {1} => {2}", xOp.ILCode.ToString(), xOp.ToString(), Optimizer.vStack.Count));
                    /* yayaya! I found one that is already implement. I am lucky, right? I should buy a lottery ticket :P */
                    ILHandler.Execute(Config, xOp, method, Optimizer);
                }
            }

            /* Add minor blocks to main block  */
            var ILKeys = ILBlocks.Keys.ToList();
            ILKeys.Sort();

            foreach (var pos in ILKeys)
                block.Body.AddRange(ILBlocks[pos].Body);

            /* revert to original main block */
            Instruction.Block = block;
            EmitFooter(block, method);

            Instruction.Block = null;
        }

        /// <summary>
        /// Emit calli header
        /// </summary>
        /// <param name="block"></param>
        /// <param name="method"></param>
        /// <param name="stackspace"></param>
        internal void EmitHeader(FunctionalBlock block, MethodBase method, int stackspace)
        {
            switch(block.CallingConvention)
            {
                case CallingConvention.StdCall:
                    {
                        switch(block.Platform)
                        {
                            case Architecture.x86:
                                {
                                    /* this is pretty much standard thing :P */

                                    new Push { DestinationReg = Register.EBP };
                                    new Mov { DestinationReg = Register.EBP, SourceReg = Register.ESP };
                                    if (stackspace > 0)
                                        new Sub { DestinationReg = Register.ESP, SourceRef = "0x" + stackspace.ToString("X") };
                                }
                                break;
                            default:
                                throw new Exception(string.Format("Unsupported Platform method '{0}'", method.FullName()));
                        }
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported CallingConvention used in method '{0}'", method.FullName()));
            }
        }

        /// <summary>
        /// Load up execption pointer onto the stack
        /// </summary>
        /// <param name="block"></param>
        /// <param name="method"></param>
        internal void EmitExceptionHandler(FunctionalBlock block, MethodBase method)
        {
            switch (block.CallingConvention)
            {
                case CallingConvention.StdCall:
                    {
                        switch (block.Platform)
                        {
                            case Architecture.x86:
                                {
                                    /* ECX contains pointer to the exception object */
                                    new Push { DestinationReg = Register.ECX };
                                }
                                break;
                            default:
                                throw new Exception(string.Format("Unsupported Platform method '{0}'", method.FullName()));
                        }
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported CallingConvention used in method '{0}'", method.FullName()));
            }
        }

        /// <summary>
        /// Emit static method constructor's header
        /// </summary>
        /// <param name="block"></param>
        /// <param name="method"></param>
        internal void EmitConstructor(FunctionalBlock block, MethodBase method)
        {
            if ((method is ConstructorInfo) == false)
                throw new Exception(string.Format("Illegal call to EmitConstructor by '{0}'", method.FullName()));

            /* Constructors should be called once in a life time, so make sure they are not getting called again */
            switch (block.Platform)
            {
                case Architecture.x86:
                    {
                        var key = method.ConstructorKey();
                        InsertData(key, typeof(bool));

                        /* Return if it was called before */

                        new Test { DestinationRef = key, DestinationIndirect = true, SourceRef = "0x1" };
                        new Jmp { Condition = ConditionalJump.JZ, DestinationRef = ".Load" };
                        new Ret { Offset = 0x0 };
                        new Label(".Load");
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported Platform method '{0}'", method.FullName()));
            }
        }

        /// <summary>
        /// Emit Calli footer
        /// </summary>
        /// <param name="block"></param>
        /// <param name="method"></param>
        internal void EmitFooter(FunctionalBlock block, MethodBase method)
        {
            /* warning: dark magic below */
            var paramsSize = method.GetParameters().Sum(arg => Helper.GetTypeSize(arg.ParameterType, Config.TargetPlatform, true));

            if (!method.IsStatic)
                paramsSize += Helper.GetTypeSize(method.DeclaringType, Config.TargetPlatform, true);

            if (paramsSize > 255) throw new Exception(string.Format("Too large stack frame for parameters '{0}'", method.FullName()));

            var functionInfo = method as MethodInfo;

            int returncount = 0;
            if (functionInfo != null && functionInfo.ReturnType != typeof(void))
                returncount = Helper.GetTypeSize(functionInfo.ReturnType, Config.TargetPlatform, true);

            switch (block.CallingConvention)
            {
                case CallingConvention.StdCall:
                    {
                        switch (block.Platform)
                        {
                            case Architecture.x86:
                                {
                                    new Label(".End");
                                    /* if process didn't throw any error, then clear ECX register */
                                    new Xor { DestinationReg = Register.ECX, SourceReg = Register.ECX };

                                    new Label(".Error");

                                    /* pop return value and put it in EAX register */
                                    if (returncount != 0)
                                    {
                                        if (returncount > 8)
                                            throw new Exception("Return type > 8 not supported");

                                        new Pop { DestinationReg = Register.EAX };
                                        if (returncount == 8)
                                            new Pop { DestinationReg = Register.EDX };
                                    }

                                    new Leave { };
                                    new Ret { Offset = (byte)paramsSize };
                                }
                                break;
                            default:
                                throw new Exception(string.Format("Unsupported Platform method '{0}'", method.FullName()));
                        }
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported CallingConvention used in method '{0}'", method.FullName()));
            }
        }

        /// <summary>
        /// try to emit OpCodeType from method IL byte body
        /// </summary>
        /// <param name="method">method function</param>
        /// <param name="ReferencedPositions">branch positions</param>
        /// <returns></returns>
        internal List<OpCodeType> EmitOpCodes(MethodBase method, HashSet<int> ReferencedPositions)
        {
            /* probably this is the darkest magic of all this, and not that MSIL stuff */

            var body = method.GetMethodBody();
            if (body == null)
                throw new Exception(string.Format("illegal call to EmitOpCodes '{0}'", method.FullName()));

            var byteCode = body.GetILAsByteArray();

            Type[] genericTypeArgs = null;
            Type[] genericMethodArgs = null;
            var EmittedOpCodes = new List<OpCodeType>();

            if (method.DeclaringType.IsGenericType)
                genericTypeArgs = method.DeclaringType.GetGenericArguments();

            if (method.IsGenericMethod)
                genericMethodArgs = method.GetGenericArguments();

            ILCode xOpCodeVal;
            Emit.OpCode xOpCode;
            OpCodeType xOpCodeType;
            ExceptionHandlingClause xCurrentHandler;

            int index = 0;
            while (index < byteCode.Length)
            {
                xCurrentHandler = null;
                foreach (ExceptionHandlingClause xHandler in body.ExceptionHandlingClauses)
                {
                    if (xHandler.TryOffset >= 0)
                    {
                        if (xHandler.TryOffset <= index && (xHandler.TryLength + xHandler.TryOffset + 1) > index)
                        {
                            if (xCurrentHandler == null)
                            {
                                xCurrentHandler = xHandler;
                                continue;
                            }
                            else if (xHandler.TryOffset > xCurrentHandler.TryOffset && (xHandler.TryLength + xHandler.TryOffset) < (xCurrentHandler.TryLength + xCurrentHandler.TryOffset))
                            {
                                xCurrentHandler = xHandler;
                                continue;
                            }
                        }
                    }
                    if (xHandler.HandlerOffset > 0)
                    {
                        if (xHandler.HandlerOffset <= index && (xHandler.HandlerOffset + xHandler.HandlerLength + 1) > index)
                        {
                            if (xCurrentHandler == null)
                            {
                                xCurrentHandler = xHandler;
                                continue;
                            }
                            else if (xHandler.HandlerOffset > xCurrentHandler.HandlerOffset && (xHandler.HandlerOffset + xHandler.HandlerLength) < (xCurrentHandler.HandlerOffset + xCurrentHandler.HandlerLength))
                            {
                                xCurrentHandler = xHandler;
                                continue;
                            }
                        }
                    }
                    if ((xHandler.Flags & ExceptionHandlingClauseOptions.Filter) > 0)
                    {
                        if (xHandler.FilterOffset > 0)
                        {
                            if (xHandler.FilterOffset <= index)
                            {
                                if (xCurrentHandler == null)
                                {
                                    xCurrentHandler = xHandler;
                                    continue;
                                }
                                else if (xHandler.FilterOffset > xCurrentHandler.FilterOffset)
                                {
                                    xCurrentHandler = xHandler;
                                    continue;
                                }
                            }
                        }
                    }
                }

                if (xCurrentHandler != null)
                    ReferencedPositions.Add(xCurrentHandler.HandlerOffset);

                int position = index;

                if (byteCode[index] == 0xFE)
                {
                    xOpCode = OpCode[(short)(0xFE00 | byteCode[index + 1])];
                    index += 2;
                }
                else
                {
                    xOpCode = OpCode[byteCode[index]];
                    index++;
                }

                xOpCodeVal = (ILCode)xOpCode.Value;

                switch (xOpCode.OperandType)
                {
                    case Emit.OperandType.InlineNone:
                        {
                            switch (xOpCodeVal)
                            {
                                case ILCode.Ldarg_0:
                                    xOpCodeType = new OpVar(ILCode.Ldarg, position, index, 0, xCurrentHandler);
                                    break;
                                case ILCode.Ldarg_1:
                                    xOpCodeType = new OpVar(ILCode.Ldarg, position, index, 1, xCurrentHandler);
                                    break;
                                case ILCode.Ldarg_2:
                                    xOpCodeType = new OpVar(ILCode.Ldarg, position, index, 2, xCurrentHandler);
                                    break;
                                case ILCode.Ldarg_3:
                                    xOpCodeType = new OpVar(ILCode.Ldarg, position, index, 3, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_0:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 0, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_1:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 1, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_2:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 2, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_3:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 3, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_4:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 4, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_5:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 5, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_6:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 6, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_7:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 7, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_8:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, 8, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_M1:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index, -1, xCurrentHandler);
                                    break;
                                case ILCode.Ldloc_0:
                                    xOpCodeType = new OpVar(ILCode.Ldloc, position, index, 0, xCurrentHandler);
                                    break;
                                case ILCode.Ldloc_1:
                                    xOpCodeType = new OpVar(ILCode.Ldloc, position, index, 1, xCurrentHandler);
                                    break;
                                case ILCode.Ldloc_2:
                                    xOpCodeType = new OpVar(ILCode.Ldloc, position, index, 2, xCurrentHandler);
                                    break;
                                case ILCode.Ldloc_3:
                                    xOpCodeType = new OpVar(ILCode.Ldloc, position, index, 3, xCurrentHandler);
                                    break;
                                case ILCode.Stloc_0:
                                    xOpCodeType = new OpVar(ILCode.Stloc, position, index, 0, xCurrentHandler);
                                    break;
                                case ILCode.Stloc_1:
                                    xOpCodeType = new OpVar(ILCode.Stloc, position, index, 1, xCurrentHandler);
                                    break;
                                case ILCode.Stloc_2:
                                    xOpCodeType = new OpVar(ILCode.Stloc, position, index, 2, xCurrentHandler);
                                    break;
                                case ILCode.Stloc_3:
                                    xOpCodeType = new OpVar(ILCode.Stloc, position, index, 3, xCurrentHandler);
                                    break;
                                default:
                                    xOpCodeType = new OpNone(xOpCodeVal, position, index, xCurrentHandler);
                                    break;
                            }
                        }
                        break;
                    case Emit.OperandType.ShortInlineBrTarget:
                        {
                            int xTarget = index + 1 + (sbyte)byteCode[index];

                            index++;
                            ReferencedPositions.Add(xTarget);
                            switch (xOpCodeVal)
                            {
                                case ILCode.Beq_S:
                                    xOpCodeType = new OpBranch(ILCode.Beq, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bge_S:
                                    xOpCodeType = new OpBranch(ILCode.Bge, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bge_Un_S:
                                    xOpCodeType = new OpBranch(ILCode.Bge_Un, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bgt_S:
                                    xOpCodeType = new OpBranch(ILCode.Bgt, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bgt_Un_S:
                                    xOpCodeType = new OpBranch(ILCode.Bgt_Un, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Ble_S:
                                    xOpCodeType = new OpBranch(ILCode.Ble, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Ble_Un_S:
                                    xOpCodeType = new OpBranch(ILCode.Ble_Un, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Blt_S:
                                    xOpCodeType = new OpBranch(ILCode.Blt, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Blt_Un_S:
                                    xOpCodeType = new OpBranch(ILCode.Blt_Un, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bne_Un_S:
                                    xOpCodeType = new OpBranch(ILCode.Bne_Un, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Br_S:
                                    xOpCodeType = new OpBranch(ILCode.Br, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Brfalse_S:
                                    xOpCodeType = new OpBranch(ILCode.Brfalse, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Brtrue_S:
                                    xOpCodeType = new OpBranch(ILCode.Brtrue, position, index, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Leave_S:
                                    xOpCodeType = new OpBranch(ILCode.Leave, position, index, xTarget, xCurrentHandler);
                                    break;
                                default:
                                    xOpCodeType = new OpBranch(xOpCodeVal, position, index, xTarget, xCurrentHandler);
                                    break;
                            }
                        }
                        break;
                    case Emit.OperandType.InlineBrTarget:
                        {
                            int xTarget = index + 4 + BitConverter.ToInt32(byteCode, index);
                            index += 4;
                            ReferencedPositions.Add(xTarget);
                            xOpCodeType = new OpBranch(xOpCodeVal, position, index, xTarget, xCurrentHandler);
                        }
                        break;
                    case Emit.OperandType.ShortInlineI:
                        {
                            switch (xOpCodeVal)
                            {
                                case ILCode.Ldc_I4_S:
                                    xOpCodeType = new OpInt(ILCode.Ldc_I4, position, index + 1, ((sbyte)byteCode[index]), xCurrentHandler);
                                    break;
                                default:
                                    xOpCodeType = new OpInt(xOpCodeVal, position, index + 1, ((sbyte)byteCode[index]), xCurrentHandler);
                                    break;
                            }
                            index++;
                        }
                        break;
                    case Emit.OperandType.InlineI:
                        xOpCodeType = new OpInt(xOpCodeVal, position, index + 4, BitConverter.ToInt32(byteCode, index), xCurrentHandler);
                        index += 4;
                        break;
                    case Emit.OperandType.InlineI8:
                        xOpCodeType = new OpInt64(xOpCodeVal, position, index + 8, BitConverter.ToInt64(byteCode, index), xCurrentHandler);
                        index += 8;
                        break;
                    case Emit.OperandType.ShortInlineR:
                        xOpCodeType = new OpSingle(xOpCodeVal, position, index + 4, BitConverter.ToSingle(byteCode, index), xCurrentHandler);
                        index += 4;
                        break;
                    case Emit.OperandType.InlineR:
                        xOpCodeType = new OpDouble(xOpCodeVal, position, index + 8, BitConverter.ToDouble(byteCode, index), xCurrentHandler);
                        index += 8;
                        break;
                    case Emit.OperandType.InlineField:
                        {
                            var xValue = method.Module.ResolveField(BitConverter.ToInt32(byteCode, index), genericTypeArgs, genericMethodArgs);
                            xOpCodeType = new OpField(xOpCodeVal, position, index + 4, xValue, xCurrentHandler);
                            index += 4;
                        }
                        break;
                    case Emit.OperandType.InlineMethod:
                        {
                            var xValue = method.Module.ResolveMethod(BitConverter.ToInt32(byteCode, index), genericTypeArgs, genericMethodArgs);
                            xOpCodeType = new OpMethod(xOpCodeVal, position, index + 4, xValue, xCurrentHandler);
                            index += 4;
                        }
                        break;
                    case Emit.OperandType.InlineSig:
                        xOpCodeType = new OpSig(xOpCodeVal, position, index + 4, BitConverter.ToInt32(byteCode, index), xCurrentHandler);
                        index += 4;
                        break;
                    case Emit.OperandType.InlineString:
                        xOpCodeType = new OpString(xOpCodeVal, position, index + 4, method.Module.ResolveString((int)BitConverter.ToInt32(byteCode, index)), xCurrentHandler);
                        index += 4;
                        break;
                    case Emit.OperandType.InlineSwitch:
                        {
                            int xCount = BitConverter.ToInt32(byteCode, index);
                            index += 4;
                            int xNextOpPos = index + xCount * 4;
                            int[] xBranchLocations = new int[xCount];
                            for (int i = 0; i < xCount; i++)
                            {
                                xBranchLocations[i] = xNextOpPos + BitConverter.ToInt32(byteCode, index + i * 4);
                                ReferencedPositions.Add(xBranchLocations[i]);
                            }
                            xOpCodeType = new OpSwitch(xOpCodeVal, position, xNextOpPos, xBranchLocations, xCurrentHandler);
                            index = xNextOpPos;
                        }
                        break;
                    case Emit.OperandType.InlineTok:
                        xOpCodeType = new OpToken(xOpCodeVal, position, index + 4, BitConverter.ToInt32(byteCode, index), method.Module, genericTypeArgs, genericMethodArgs, xCurrentHandler);
                        index += 4;
                        break;
                    case Emit.OperandType.InlineType:
                        {
                            var xValue = method.Module.ResolveType(BitConverter.ToInt32(byteCode, index), genericTypeArgs, genericMethodArgs);
                            xOpCodeType = new OpType(xOpCodeVal, position, index + 4, xValue, xCurrentHandler);
                            index += 4;
                        }
                        break;
                    case Emit.OperandType.ShortInlineVar:
                        switch (xOpCodeVal)
                        {
                            case ILCode.Ldloc_S:
                                xOpCodeType = new OpVar(ILCode.Ldloc, position, index + 1, byteCode[index], xCurrentHandler);
                                break;
                            case ILCode.Ldloca_S:
                                xOpCodeType = new OpVar(ILCode.Ldloca, position, index + 1, byteCode[index], xCurrentHandler);
                                break;
                            case ILCode.Ldarg_S:
                                xOpCodeType = new OpVar(ILCode.Ldarg, position, index + 1, byteCode[index], xCurrentHandler);
                                break;
                            case ILCode.Ldarga_S:
                                xOpCodeType = new OpVar(ILCode.Ldarga, position, index + 1, byteCode[index], xCurrentHandler);
                                break;
                            case ILCode.Starg_S:
                                xOpCodeType = new OpVar(ILCode.Starg, position, index + 1, byteCode[index], xCurrentHandler);
                                break;
                            case ILCode.Stloc_S:
                                xOpCodeType = new OpVar(ILCode.Stloc, position, index + 1, byteCode[index], xCurrentHandler);
                                break;
                            default:
                                xOpCodeType = new OpVar(xOpCodeVal, position, index + 1, byteCode[index], xCurrentHandler);
                                break;
                        }
                        index++;
                        break;
                    case Emit.OperandType.InlineVar:
                        xOpCodeType = new OpVar(xOpCodeVal, position, index + 2, BitConverter.ToUInt16(byteCode, index), xCurrentHandler);
                        index += 2;
                        break;
                    default:
                        throw new Exception("Internal Compiler error" + xOpCode.OperandType);
                }

                xOpCodeType.IsLastIL = xOpCodeType.NextPosition == byteCode.Length;
                EmittedOpCodes.Add(xOpCodeType);
            }

            return EmittedOpCodes;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Conditional Jumps Listenings
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public enum ConditionalJump
    {
        JMP, JO, JNO, JS, JNS, JE, JZ, JNE, JNZ, JB, JNAE, JC,
        JNB, JAE, JNC, JBE, JNA, JA, JNBE, JL, JNGE, JGE, JNL,
        JLE, JNG, JG, JNLE, JP, JPE, JNP, JPO, JCXZ, JECXZ,
    };
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_I1)]
    internal class Conv_I1_il : MSIL
    {
        public Conv_I1_il()
            : base(ILCode.Conv_I1)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_I1(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to native int
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Movsx { DestinationReg = Register.EAX, SourceReg = Register.AL, Size = 8 };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(int)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_I2)]
    internal class Conv_I2_il : MSIL
    {
        public Conv_I2_il()
            : base(ILCode.Conv_I2)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_I2(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to native int
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Movsx { DestinationReg = Register.EAX, SourceReg = Register.AX, Size = 16 };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(int)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_I4)]
    internal class Conv_I4_il : MSIL
    {
        public Conv_I4_il()
            : base(ILCode.Conv_I4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_I4(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to native int
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Optimizer.vStack.Push(new StackItem(typeof(int)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_I)]
    internal class Conv_I_il : MSIL
    {
        public Conv_I_il()
            : base(ILCode.Conv_I)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_I(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to native int
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Optimizer.vStack.Push(new StackItem(typeof(int)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_R8 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_R8)]
    internal class Conv_R8_il : MSIL
    {
        public Conv_R8_il()
            : base(ILCode.Conv_R8)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_R8(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to float64.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Fild { DestinationReg = Register.ESP, DestinationIndirect = true };
                        new Sub { DestinationReg = Register.ESP, SourceRef = "0x4" };
                        new Fstp { DestinationReg = Register.ESP, DestinationIndirect = true, Size = 64 };

                        Optimizer.vStack.Push(new StackItem(typeof(double)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_U1)]
    internal class Conv_U1_il : MSIL
    {
        public Conv_U1_il()
            : base(ILCode.Conv_U1)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_U1(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to native uint
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Movzx { DestinationReg = Register.EAX, SourceReg = Register.AL, Size = 8 };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_U2)]
    internal class Conv_U2_il : MSIL
    {
        public Conv_U2_il()
            : base(ILCode.Conv_U2)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_U2(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to native uint
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Movzx { DestinationReg = Register.EAX, SourceReg = Register.AX, Size = 16 };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_U4)]
    internal class Conv_U4_il : MSIL
    {
        public Conv_U4_il()
            : base(ILCode.Conv_U4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_U4(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to native uint
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Conv_U)]
    internal class Conv_U_il : MSIL
    {
        public Conv_U_il()
            : base(ILCode.Conv_U)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Conv_U(v=vs.110).aspx
         * Description : Converts the value on top of the evaluation stack to native uint
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped from the stack and the conversion operation is attempted.
             * If the conversion is successful, the resulting value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Destination-Source type set Instructions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Text;

namespace Atomixilc.Machine.x86
{
    public class DestinationSource : Instruction
    {
        public string DestinationRef;
        public Register? DestinationReg;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;

        public string SourceRef;
        public Register? SourceReg;
        public bool SourceIndirect;
        public int? SourceDisplacement;

        public DestinationSource(string aMnemonic)
            :base(aMnemonic)
        {

        }

        public override string ToString()
        {
            if ((!string.IsNullOrEmpty(DestinationRef) && DestinationReg.HasValue) ||
                (string.IsNullOrEmpty(DestinationRef) && !DestinationReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Destination Parameters", Mnemonic));

            if ((!string.IsNullOrEmpty(SourceRef) && SourceReg.HasValue) ||
                (string.IsNullOrEmpty(SourceRef) && !SourceReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Source Parameters", Mnemonic));

            var SB = new StringBuilder();
            SB.Append(Mnemonic);
            SB.Append(' ');

            if (DestinationIndirect)
                SB.Append('[');

            if (DestinationReg.HasValue)
                SB.Append(DestinationReg.Value);
            else
                SB.Append(DestinationRef);

            if (DestinationDisplacement.HasValue && DestinationDisplacement != 0)
            {
                int offset = DestinationDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (DestinationIndirect)
                SB.Append(']');

            SB.Append(", ");

            if (SourceIndirect)
                SB.Append('[');

            if (SourceReg.HasValue)
                SB.Append(SourceReg.Value);
            else
                SB.Append(SourceRef);

            if (SourceDisplacement.HasValue && SourceDisplacement != 0)
            {
                int offset = SourceDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (SourceIndirect)
                SB.Append(']');

            return SB.ToString();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Destination-Source-Size type set Instructions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Text;

namespace Atomixilc.Machine.x86
{
    public class DestinationSourceSize : Instruction
    {
        public string DestinationRef;
        public Register? DestinationReg;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;

        public string SourceRef;
        public Register? SourceReg;
        public bool SourceIndirect;
        public int? SourceDisplacement;

        public byte Size;

        public DestinationSourceSize(string aMnemonic)
            :base(aMnemonic)
        {
            Size = 32;
        }

        public override string ToString()
        {
            if ((!string.IsNullOrEmpty(DestinationRef) && DestinationReg.HasValue) ||
                (string.IsNullOrEmpty(DestinationRef) && !DestinationReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Destination Parameters", Mnemonic));

            if ((!string.IsNullOrEmpty(SourceRef) && SourceReg.HasValue) ||
                (string.IsNullOrEmpty(SourceRef) && !SourceReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Source Parameters", Mnemonic));

            var SB = new StringBuilder();
            SB.Append(Mnemonic);
            SB.Append(' ');
            SB.Append(Helper.SizeToString(Size));
            SB.Append(' ');

            if (DestinationIndirect)
                SB.Append('[');

            if (DestinationReg.HasValue)
                SB.Append(DestinationReg.Value);
            else
                SB.Append(DestinationRef);

            if (DestinationDisplacement.HasValue && DestinationDisplacement != 0)
            {
                int offset = DestinationDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (DestinationIndirect)
                SB.Append(']');

            SB.Append(", ");

            if (SourceIndirect)
                SB.Append('[');

            if (SourceReg.HasValue)
                SB.Append(SourceReg.Value);
            else
                SB.Append(SourceRef);

            if (SourceDisplacement.HasValue && SourceDisplacement != 0)
            {
                int offset = SourceDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (SourceIndirect)
                SB.Append(']');

            return SB.ToString();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Div Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Div : OnlyDestination
    {
        public Div()
            :base("div")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Div_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Div_Un)]
    internal class Div_Un_il : MSIL
    {
        public Div_Un_il()
            : base(ILCode.Div_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Div_Un(v=vs.110).aspx
         * Description : Divides two unsigned integer values and pushes the result (int32) onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var divisor = Optimizer.vStack.Pop();
            var dividend = Optimizer.vStack.Pop();

            var size = Math.Max(Helper.GetTypeSize(divisor.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(dividend.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack; value1 is divided by value2.
             * The result is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (divisor.IsFloat || dividend.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!dividend.SystemStack || !divisor.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EBX };
                        new Pop { DestinationReg = Register.EAX };
                        new Xor { DestinationReg = Register.EDX, SourceReg = Register.EDX };
                        new Div { DestinationReg = Register.EBX };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(divisor.OperandType));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Dup MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Dup)]
    internal class Dup_il : MSIL
    {
        public Dup_il()
            : base(ILCode.Dup)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Dup(v=vs.110).aspx
         * Description : Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Peek();
            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * value is pushed onto the stack.
             * value is popped off of the stack for duplication.
             * value is pushed back onto the stack.
             * A duplicate value is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Push { DestinationReg = Register.ESP, DestinationIndirect = true };

                        Optimizer.vStack.Push(new StackItem(item.OperandType));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Application Entrypoint Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomixilc.Attributes
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class EntrypointAttribute : Attribute
    {
        public readonly string Entrypoint;
        public readonly Architecture Platform;

        public EntrypointAttribute(Architecture arch, string entrypoint)
        {
            Entrypoint = entrypoint;
            Platform = arch;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          System.Exception Plugs
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Attributes;

namespace Atomixilc.Lib.Plugs
{
    internal unsafe static class ExceptionImpl
    {
        [Plug("System_Void_System_Exception__cctor__")]
        internal static void ctor(uint* aException)
        {

        }

        [Plug("System_Void_System_Exception__ctor_System_String_")]
        internal static void ctor(uint* aException, uint aMessage)
        {
            *(aException + 0x3) = aMessage;
        }

        [Plug("System_String_System_Exception_get_Message__")]
        internal static uint GetMessage(uint* aAddress)
        {
            return *(aAddress + 0x3);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Fild Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Fild : OnlyDestination
    {
        public Fild()
            : base("fild")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Fstp Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Fstp : OnlyDestination
    {
        public Fstp()
            : base("fstp")
        {

        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

using Atomixilc.Machine;

namespace Atomixilc
{
    internal class FunctionalBlock
    {
        string mName;
        Architecture mPlatform;
        List<Instruction> mBody;
        CallingConvention mCallingConvention;

        internal string Name
        {
            get { return mName; }
            set { mName = value; }
        }

        internal Architecture Platform
        {
            get { return mPlatform; }
        }

        internal List<Instruction> Body
        {
            get
            {
                if (mBody == null)
                    mBody = new List<Instruction>();
                return mBody;
            }
        }

        internal CallingConvention CallingConvention
        {
            get { return mCallingConvention; }
        }

        internal FunctionalBlock(string name, Architecture arch, CallingConvention callc)
        {
            mName = name;
            mPlatform = arch;
            mCallingConvention = callc;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Helper functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomixilc.Machine.x86
{
    internal static class Helper
    {
        internal static string SizeToString(byte Size)
        {
            switch(Size)
            {
                case 8: return ("byte");
                case 16: return ("word");
                case 32: return ("dword");
                case 64: return ("qword");
                default: throw new Exception(string.Format("Invalid Size '{0}'", Size));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 IDiv Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class IDiv : OnlyDestination
    {
        public IDiv()
            :base("idiv")
        {

        }
    }
}
﻿using System;

namespace Atomixilc
{
    internal enum ILCode : ushort
    {
        //
        // Summary:
        //     Adds two values and pushes the result onto the evaluation stack.
        Add = 0x0058,
        Add_Ovf = 0x00D6,
        //
        // Summary:
        //     Adds two unsigned integer values, performs an overflow check, and pushes the
        //     result onto the evaluation stack.
        Add_Ovf_Un = 0x00D7,
        //
        // Summary:
        //     Computes the bitwise AND of two values and pushes the result onto the evaluation
        //     stack.
        And = 0x005F,
        //
        // Summary:
        //     Returns an unmanaged pointer to the argument list of the current method.
        Arglist = 0xFE00,
        //
        // Summary:
        //     Transfers control to a target instruction if two values are equal.
        Beq = 0x003B,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if two values are equal.
        Beq_S = 0x002E,
        //
        // Summary:
        //     Transfers control to a target instruction if the first value is greater than
        //     or equal to the second value.
        Bge = 0x003C,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if the first value is
        //     greater than or equal to the second value.
        Bge_S = 0x002F,
        //
        // Summary:
        //     Transfers control to a target instruction if the first value is greater than
        //     the second value, when comparing unsigned integer values or unordered float values.
        Bge_Un = 0x0041,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if the first value is
        //     greater than the second value, when comparing unsigned integer values or unordered
        //     float values.
        Bge_Un_S = 0x0034,
        //
        // Summary:
        //     Transfers control to a target instruction if the first value is greater than
        //     the second value.
        Bgt = 0x003D,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if the first value is
        //     greater than the second value.
        Bgt_S = 0x0030,
        //
        // Summary:
        //     Transfers control to a target instruction if the first value is greater than
        //     the second value, when comparing unsigned integer values or unordered float values.
        Bgt_Un = 0x0042,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if the first value is
        //     greater than the second value, when comparing unsigned integer values or unordered
        //     float values.
        Bgt_Un_S = 0x0035,
        //
        // Summary:
        //     Transfers control to a target instruction if the first value is less than or
        //     equal to the second value.
        Ble = 0x003E,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if the first value is
        //     less than or equal to the second value.
        Ble_S = 0x0031,
        //
        // Summary:
        //     Transfers control to a target instruction if the first value is less than or
        //     equal to the second value, when comparing unsigned integer values or unordered
        //     float values.
        Ble_Un = 0x0043,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if the first value is
        //     less than or equal to the second value, when comparing unsigned integer values
        //     or unordered float values.
        Ble_Un_S = 0x0036,
        //
        // Summary:
        //     Transfers control to a target instruction if the first value is less than the
        //     second value.
        Blt = 0x003F,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if the first value is
        //     less than the second value.
        Blt_S = 0x0032,
        //
        // Summary:
        //     Transfers control to a target instruction if the first value is less than the
        //     second value, when comparing unsigned integer values or unordered float values.
        Blt_Un = 0x0044,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if the first value is
        //     less than the second value, when comparing unsigned integer values or unordered
        //     float values.
        Blt_Un_S = 0x0037,
        //
        // Summary:
        //     Transfers control to a target instruction when two unsigned integer values or
        //     unordered float values are not equal.
        Bne_Un = 0x0040,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) when two unsigned integer
        //     values or unordered float values are not equal.
        Bne_Un_S = 0x0033,
        //
        // Summary:
        //     Converts a value type to an object reference (type O).
        Box = 0x008C,
        //
        // Summary:
        //     Unconditionally transfers control to a target instruction.
        Br = 0x0038,
        //
        // Summary:
        //     Signals the Common Language Infrastructure (CLI) to inform the debugger that
        //     a break point has been tripped.
        Break = 0x0001,
        //
        // Summary:
        //     Transfers control to a target instruction if value is false, a null reference
        //     (Nothing in Visual Basic), or zero.
        Brfalse = 0x0039,
        //
        // Summary:
        //     Transfers control to a target instruction if value is false, a null reference,
        //     or zero.
        Brfalse_S = 0x002C,
        //
        // Summary:
        //     Transfers control to a target instruction if value is true, not null, or non-zero.
        Brtrue = 0x003A,
        //
        // Summary:
        //     Transfers control to a target instruction (short form) if value is true, not
        //     null, or non-zero.
        Brtrue_S = 0x002D,
        //
        // Summary:
        //     Unconditionally transfers control to a target instruction (short form).
        Br_S = 0x002B,
        //
        // Summary:
        //     Calls the method indicated by the passed method descriptor.
        Call = 0x0028,
        //
        // Summary:
        //     Calls the method indicated on the evaluation stack (as a pointer to an entry
        //     point) with arguments described by a calling convention.
        Calli = 0x0029,
        //
        // Summary:
        //     Calls a late-bound method on an object, pushing the return value onto the evaluation
        //     stack.
        Callvirt = 0x006F,
        //
        // Summary:
        //     Attempts to cast an object passed by reference to the specified class.
        Castclass = 0x0074,
        //
        // Summary:
        //     Compares two values. If they are equal, the integer value 1 (int32) is pushed
        //     onto the evaluation stack, otherwise 0 (int32) is pushed onto the evaluation
        //     stack.
        Ceq = 0xFE01,
        //
        // Summary:
        //     Compares two values. If the first value is greater than the second, the integer
        //     value 1 (int32) is pushed onto the evaluation stack, otherwise 0 (int32) is pushed
        //     onto the evaluation stack.
        Cgt = 0xFE02,
        //
        // Summary:
        //     Compares two unsigned or unordered values. If the first value is greater than
        //     the second, the integer value 1 (int32) is pushed onto the evaluation stack,
        //     otherwise 0 (int32) is pushed onto the evaluation stack.
        Cgt_Un = 0xFE03,
        //
        // Summary:
        //     Throws System.ArithmeticException if value is not a finite number.
        Ckfinite = 0x00C3,
        //
        // Summary:
        //     Compares two values. If the first value is less than the second, the integer
        //     value 1 (int32) is pushed onto the evaluation stack, otherwise 0 (int32) is pushed
        //     onto the evaluation stack.
        Clt = 0xFE04,
        //
        // Summary:
        //     Compares the unsigned or unordered values value1 and value2. If value1 is less
        //     than value2, then the integer value 1 (int32) is pushed onto the evaluation stack,
        //     otherwise 0 (int32) is pushed onto the evaluation stack.
        Clt_Un = 0xFE05,
        //
        // Summary:
        //     Constrains the type on which a virtual method call is made.
        Constrained = 0xFE16,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to native int.
        Conv_I = 0x00D3,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to int8, then extends (pads)
        //     it to int32.
        Conv_I1 = 0x0067,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to int16, then extends (pads)
        //     it to int32.
        Conv_I2 = 0x0068,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to int32.
        Conv_I4 = 0x0069,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to int64.
        Conv_I8 = 0x006A,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to signed native int,
        //     throwing System.OverflowException on overflow.
        Conv_Ovf_I = 0x00D4,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to signed int8 and extends
        //     it to int32, throwing System.OverflowException on overflow.
        Conv_Ovf_I1 = 0x00B3,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to signed int8 and
        //     extends it to int32, throwing System.OverflowException on overflow.
        Conv_Ovf_I1_Un = 0x0082,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to signed int16 and
        //     extending it to int32, throwing System.OverflowException on overflow.
        Conv_Ovf_I2 = 0x00B5,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to signed int16 and
        //     extends it to int32, throwing System.OverflowException on overflow.
        Conv_Ovf_I2_Un = 0x0083,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to signed int32, throwing
        //     System.OverflowException on overflow.
        Conv_Ovf_I4 = 0x00B7,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to signed int32, throwing
        //     System.OverflowException on overflow.
        Conv_Ovf_I4_Un = 0x0084,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to signed int64, throwing
        //     System.OverflowException on overflow.
        Conv_Ovf_I8 = 0x00B9,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to signed int64, throwing
        //     System.OverflowException on overflow.
        Conv_Ovf_I8_Un = 0x0085,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to signed native int,
        //     throwing System.OverflowException on overflow.
        Conv_Ovf_I_Un = 0x008A,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to unsigned native int,
        //     throwing System.OverflowException on overflow.
        Conv_Ovf_U = 0x00D5,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to unsigned int8 and
        //     extends it to int32, throwing System.OverflowException on overflow.
        Conv_Ovf_U1 = 0x00B4,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to unsigned int8 and
        //     extends it to int32, throwing System.OverflowException on overflow.
        Conv_Ovf_U1_Un = 0x0086,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to unsigned int16 and
        //     extends it to int32, throwing System.OverflowException on overflow.
        Conv_Ovf_U2 = 0x00B6,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to unsigned int16
        //     and extends it to int32, throwing System.OverflowException on overflow.
        Conv_Ovf_U2_Un = 0x0087,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to unsigned int32, throwing
        //     System.OverflowException on overflow.
        Conv_Ovf_U4 = 0x00B8,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to unsigned int32,
        //     throwing System.OverflowException on overflow.
        Conv_Ovf_U4_Un = 0x0088,
        //
        // Summary:
        //     Converts the signed value on top of the evaluation stack to unsigned int64, throwing
        //     System.OverflowException on overflow.
        Conv_Ovf_U8 = 0x00BA,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to unsigned int64,
        //     throwing System.OverflowException on overflow.
        Conv_Ovf_U8_Un = 0x0089,
        //
        // Summary:
        //     Converts the unsigned value on top of the evaluation stack to unsigned native
        //     int, throwing System.OverflowException on overflow.
        Conv_Ovf_U_Un = 0x008B,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to float32.
        Conv_R4 = 0x006B,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to float64.
        Conv_R8 = 0x006C,
        //
        // Summary:
        //     Converts the unsigned integer value on top of the evaluation stack to float32.
        Conv_R_Un = 0x0076,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to unsigned native int, and
        //     extends it to native int.
        Conv_U = 0x00E0,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to unsigned int8, and extends
        //     it to int32.
        Conv_U1 = 0x00D2,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to unsigned int16, and extends
        //     it to int32.
        Conv_U2 = 0x00D1,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to unsigned int32, and extends
        //     it to int32.
        Conv_U4 = 0x006D,
        //
        // Summary:
        //     Converts the value on top of the evaluation stack to unsigned int64, and extends
        //     it to int64.
        Conv_U8 = 0x006E,
        //
        // Summary:
        //     Copies a specified number bytes from a source address to a destination address.
        Cpblk = 0xFE17,
        //
        // Summary:
        //     Copies the value type located at the address of an object (type &, * or native
        //     int) to the address of the destination object (type &, * or native int).
        Cpobj = 0x0070,
        //
        // Summary:
        //     Divides two values and pushes the result as a floating-point (type F) or quotient
        //     (type int32) onto the evaluation stack.
        Div = 0x005B,
        //
        // Summary:
        //     Divides two unsigned integer values and pushes the result (int32) onto the evaluation
        //     stack.
        Div_Un = 0x005C,
        //
        // Summary:
        //     Copies the current topmost value on the evaluation stack, and then pushes the
        //     copy onto the evaluation stack.
        Dup = 0x0025,
        //
        // Summary:
        //     Transfers control from the filter clause of an exception back to the Common Language
        //     Infrastructure (CLI) exception handler.
        Endfilter = 0xFE11,
        //
        // Summary:
        //     Transfers control from the fault or finally clause of an exception block back
        //     to the Common Language Infrastructure (CLI) exception handler.
        Endfinally = 0x00DC,
        //
        // Summary:
        //     Initializes a specified block of memory at a specific address to a given size
        //     and initial value.
        Initblk = 0xFE18,
        //
        // Summary:
        //     Initializes each field of the value type at a specified address to a null reference
        //     or a 0 of the appropriate primitive type.
        Initobj = 0xFE15,
        //
        // Summary:
        //     Tests whether an object reference (type O) is an instance of a particular class.
        Isinst = 0x0075,
        //
        // Summary:
        //     Exits current method and jumps to specified method.
        Jmp = 0x0027,
        //
        // Summary:
        //     Loads an argument (referenced by a specified index value) onto the stack.
        Ldarg = 0xFE09,
        //
        // Summary:
        //     Load an argument address onto the evaluation stack.
        Ldarga = 0xFE0A,
        //
        // Summary:
        //     Load an argument address, in short form, onto the evaluation stack.
        Ldarga_S = 0x000F,
        //
        // Summary:
        //     Loads the argument at index 0 onto the evaluation stack.
        Ldarg_0 = 0x0002,
        //
        // Summary:
        //     Loads the argument at index 1 onto the evaluation stack.
        Ldarg_1 = 0x0003,
        //
        // Summary:
        //     Loads the argument at index 2 onto the evaluation stack.
        Ldarg_2 = 0x0004,
        //
        // Summary:
        //     Loads the argument at index 3 onto the evaluation stack.
        Ldarg_3 = 0x0005,
        //
        // Summary:
        //     Loads the argument (referenced by a specified short form index) onto the evaluation
        //     stack.
        Ldarg_S = 0x000E,
        //
        // Summary:
        //     Pushes a supplied value of type int32 onto the evaluation stack as an int32.
        Ldc_I4 = 0x0020,
        //
        // Summary:
        //     Pushes the integer value of 0 onto the evaluation stack as an int32.
        Ldc_I4_0 = 0x0016,
        //
        // Summary:
        //     Pushes the integer value of 1 onto the evaluation stack as an int32.
        Ldc_I4_1 = 0x0017,
        //
        // Summary:
        //     Pushes the integer value of 2 onto the evaluation stack as an int32.
        Ldc_I4_2 = 0x0018,
        //
        // Summary:
        //     Pushes the integer value of 3 onto the evaluation stack as an int32.
        Ldc_I4_3 = 0x0019,
        //
        // Summary:
        //     Pushes the integer value of 4 onto the evaluation stack as an int32.
        Ldc_I4_4 = 0x001A,
        //
        // Summary:
        //     Pushes the integer value of 5 onto the evaluation stack as an int32.
        Ldc_I4_5 = 0x001B,
        //
        // Summary:
        //     Pushes the integer value of 6 onto the evaluation stack as an int32.
        Ldc_I4_6 = 0x001C,
        //
        // Summary:
        //     Pushes the integer value of 7 onto the evaluation stack as an int32.
        Ldc_I4_7 = 0x001D,
        //
        // Summary:
        //     Pushes the integer value of 8 onto the evaluation stack as an int32.
        Ldc_I4_8 = 0x001E,
        //
        // Summary:
        //     Pushes the integer value of -1 onto the evaluation stack as an int32.
        Ldc_I4_M1 = 0x0015,
        //
        // Summary:
        //     Pushes the supplied int8 value onto the evaluation stack as an int32, short form.
        Ldc_I4_S = 0x001F,
        //
        // Summary:
        //     Pushes a supplied value of type int64 onto the evaluation stack as an int64.
        Ldc_I8 = 0x0021,
        //
        // Summary:
        //     Pushes a supplied value of type float32 onto the evaluation stack as type F (float).
        Ldc_R4 = 0x0022,
        //
        // Summary:
        //     Pushes a supplied value of type float64 onto the evaluation stack as type F (float).
        Ldc_R8 = 0x0023,
        //
        // Summary:
        //     Loads the element at a specified array index onto the top of the evaluation stack
        //     as the type specified in the instruction.
        Ldelem = 0x00A3,
        //
        // Summary:
        //     Loads the address of the array element at a specified array index onto the top
        //     of the evaluation stack as type & (managed pointer).
        Ldelema = 0x008F,
        //
        // Summary:
        //     Loads the element with type native int at a specified array index onto the top
        //     of the evaluation stack as a native int.
        Ldelem_I = 0x0097,
        //
        // Summary:
        //     Loads the element with type int8 at a specified array index onto the top of the
        //     evaluation stack as an int32.
        Ldelem_I1 = 0x0090,
        //
        // Summary:
        //     Loads the element with type int16 at a specified array index onto the top of
        //     the evaluation stack as an int32.
        Ldelem_I2 = 0x0092,
        //
        // Summary:
        //     Loads the element with type int32 at a specified array index onto the top of
        //     the evaluation stack as an int32.
        Ldelem_I4 = 0x0094,
        //
        // Summary:
        //     Loads the element with type int64 at a specified array index onto the top of
        //     the evaluation stack as an int64.
        Ldelem_I8 = 0x0096,
        //
        // Summary:
        //     Loads the element with type float32 at a specified array index onto the top of
        //     the evaluation stack as type F (float).
        Ldelem_R4 = 0x0098,
        //
        // Summary:
        //     Loads the element with type float64 at a specified array index onto the top of
        //     the evaluation stack as type F (float).
        Ldelem_R8 = 0x0099,
        //
        // Summary:
        //     Loads the element containing an object reference at a specified array index onto
        //     the top of the evaluation stack as type O (object reference).
        Ldelem_Ref = 0x009A,
        //
        // Summary:
        //     Loads the element with type unsigned int8 at a specified array index onto the
        //     top of the evaluation stack as an int32.
        Ldelem_U1 = 0x0091,
        //
        // Summary:
        //     Loads the element with type unsigned int16 at a specified array index onto the
        //     top of the evaluation stack as an int32.
        Ldelem_U2 = 0x0093,
        //
        // Summary:
        //     Loads the element with type unsigned int32 at a specified array index onto the
        //     top of the evaluation stack as an int32.
        Ldelem_U4 = 0x0095,
        //
        // Summary:
        //     Finds the value of a field in the object whose reference is currently on the
        //     evaluation stack.
        Ldfld = 0x007B,
        //
        // Summary:
        //     Finds the address of a field in the object whose reference is currently on the
        //     evaluation stack.
        Ldflda = 0x007C,
        //
        // Summary:
        //     Pushes an unmanaged pointer (type native int) to the native code implementing
        //     a specific method onto the evaluation stack.
        Ldftn = 0xFE06,
        //
        // Summary:
        //     Loads a value of type native int as a native int onto the evaluation stack indirectly.
        Ldind_I = 0x004D,
        //
        // Summary:
        //     Loads a value of type int8 as an int32 onto the evaluation stack indirectly.
        Ldind_I1 = 0x0046,
        //
        // Summary:
        //     Loads a value of type int16 as an int32 onto the evaluation stack indirectly.
        Ldind_I2 = 0x0048,
        //
        // Summary:
        //     Loads a value of type int32 as an int32 onto the evaluation stack indirectly.
        Ldind_I4 = 0x004A,
        //
        // Summary:
        //     Loads a value of type int64 as an int64 onto the evaluation stack indirectly.
        Ldind_I8 = 0x004C,
        //
        // Summary:
        //     Loads a value of type float32 as a type F (float) onto the evaluation stack indirectly.
        Ldind_R4 = 0x004E,
        //
        // Summary:
        //     Loads a value of type float64 as a type F (float) onto the evaluation stack indirectly.
        Ldind_R8 = 0x004F,
        //
        // Summary:
        //     Loads an object reference as a type O (object reference) onto the evaluation
        //     stack indirectly.
        Ldind_Ref = 0x0050,
        //
        // Summary:
        //     Loads a value of type unsigned int8 as an int32 onto the evaluation stack indirectly.
        Ldind_U1 = 0x0047,
        //
        // Summary:
        //     Loads a value of type unsigned int16 as an int32 onto the evaluation stack indirectly.
        Ldind_U2 = 0x0049,
        //
        // Summary:
        //     Loads a value of type unsigned int32 as an int32 onto the evaluation stack indirectly.
        Ldind_U4 = 0x004B,
        //
        // Summary:
        //     Pushes the number of elements of a zero-based, one-dimensional array onto the
        //     evaluation stack.
        Ldlen = 0x008E,
        //
        // Summary:
        //     Loads the local variable at a specific index onto the evaluation stack.
        Ldloc = 0xFE0C,
        //
        // Summary:
        //     Loads the address of the local variable at a specific index onto the evaluation
        //     stack.
        Ldloca = 0xFE0D,
        //
        // Summary:
        //     Loads the address of the local variable at a specific index onto the evaluation
        //     stack, short form.
        Ldloca_S = 0x0012,
        //
        // Summary:
        //     Loads the local variable at index 0 onto the evaluation stack.
        Ldloc_0 = 0x0006,
        //
        // Summary:
        //     Loads the local variable at index 1 onto the evaluation stack.
        Ldloc_1 = 0x0007,
        //
        // Summary:
        //     Loads the local variable at index 2 onto the evaluation stack.
        Ldloc_2 = 0x0008,
        //
        // Summary:
        //     Loads the local variable at index 3 onto the evaluation stack.
        Ldloc_3 = 0x0009,
        //
        // Summary:
        //     Loads the local variable at a specific index onto the evaluation stack, short
        //     form.
        Ldloc_S = 0x0011,
        //
        // Summary:
        //     Pushes a null reference (type O) onto the evaluation stack.
        Ldnull = 0x0014,
        //
        // Summary:
        //     Copies the value type object pointed to by an address to the top of the evaluation
        //     stack.
        Ldobj = 0x0071,
        //
        // Summary:
        //     Pushes the value of a static field onto the evaluation stack.
        Ldsfld = 0x007E,
        //
        // Summary:
        //     Pushes the address of a static field onto the evaluation stack.
        Ldsflda = 0x007F,
        //
        // Summary:
        //     Pushes a new object reference to a string literal stored in the metadata.
        Ldstr = 0x0072,
        //
        // Summary:
        //     Converts a metadata token to its runtime representation, pushing it onto the
        //     evaluation stack.
        Ldtoken = 0x00D0,
        //
        // Summary:
        //     Pushes an unmanaged pointer (type native int) to the native code implementing
        //     a particular virtual method associated with a specified object onto the evaluation
        //     stack.
        Ldvirtftn = 0xFE07,
        //
        // Summary:
        //     Exits a protected region of code, unconditionally transferring control to a specific
        //     target instruction.
        Leave = 0x00DD,
        //
        // Summary:
        //     Exits a protected region of code, unconditionally transferring control to a target
        //     instruction (short form).
        Leave_S = 0x00DE,
        //
        // Summary:
        //     Allocates a certain number of bytes from the local dynamic memory pool and pushes
        //     the address (a transient pointer, type *) of the first allocated byte onto the
        //     evaluation stack.
        Localloc = 0xFE0F,
        //
        // Summary:
        //     Pushes a typed reference to an instance of a specific type onto the evaluation
        //     stack.
        Mkrefany = 0x00C6,
        //
        // Summary:
        //     Multiplies two values and pushes the result on the evaluation stack.
        Mul = 0x005A,
        //
        // Summary:
        //     Multiplies two integer values, performs an overflow check, and pushes the result
        //     onto the evaluation stack.
        Mul_Ovf = 0x00D8,
        //
        // Summary:
        //     Multiplies two unsigned integer values, performs an overflow check, and pushes
        //     the result onto the evaluation stack.
        Mul_Ovf_Un = 0x00D9,
        //
        // Summary:
        //     Negates a value and pushes the result onto the evaluation stack.
        Neg = 0x0065,
        //
        // Summary:
        //     Pushes an object reference to a new zero-based, one-dimensional array whose elements
        //     are of a specific type onto the evaluation stack.
        Newarr = 0x008D,
        //
        // Summary:
        //     Creates a new object or a new instance of a value type, pushing an object reference
        //     (type O) onto the evaluation stack.
        Newobj = 0x0073,
        //
        // Summary:
        //     Fills space if opcodes are patched. No meaningful operation is performed although
        //     a processing cycle can be consumed.
        Nop = 0x0000,
        //
        // Summary:
        //     Computes the bitwise complement of the integer value on top of the stack and
        //     pushes the result onto the evaluation stack as the same type.
        Not = 0x0066,
        //
        // Summary:
        //     Compute the bitwise complement of the two integer values on top of the stack
        //     and pushes the result onto the evaluation stack.
        Or = 0x0060,
        //
        // Summary:
        //     Removes the value currently on top of the evaluation stack.
        Pop = 0x0026,
        //
        // Summary:
        //     This is a reserved instruction.
        Prefix1 = 0x00FE,
        //
        // Summary:
        //     This is a reserved instruction.
        Prefix2 = 0x00FD,
        //
        // Summary:
        //     This is a reserved instruction.
        Prefix3 = 0x00FC,
        //
        // Summary:
        //     This is a reserved instruction.
        Prefix4 = 0x00FB,
        //
        // Summary:
        //     This is a reserved instruction.
        Prefix5 = 0x00FA,
        //
        // Summary:
        //     This is a reserved instruction.
        Prefix6 = 0x00F9,
        //
        // Summary:
        //     This is a reserved instruction.
        Prefix7 = 0x00F8,
        //
        // Summary:
        //     This is a reserved instruction.
        Prefixref = 0x00FF,
        //
        // Summary:
        //     Specifies that the subsequent array address operation performs no type check
        //     at run time, and that it returns a managed pointer whose mutability is restricted.
        Readonly = 0xFE1E,
        //
        // Summary:
        //     Retrieves the type token embedded in a typed reference.
        Refanytype = 0xFE1D,
        //
        // Summary:
        //     Retrieves the address (type &) embedded in a typed reference.
        Refanyval = 0x00C2,
        //
        // Summary:
        //     Divides two values and pushes the remainder onto the evaluation stack.
        Rem = 0x005D,
        //
        // Summary:
        //     Divides two unsigned values and pushes the remainder onto the evaluation stack.
        Rem_Un = 0x005E,
        //
        // Summary:
        //     Returns from the current method, pushing a return value (if present) from the
        //     callee's evaluation stack onto the caller's evaluation stack.
        Ret = 0x002A,
        //
        // Summary:
        //     Rethrows the current exception.
        Rethrow = 0xFE1A,
        //
        // Summary:
        //     Shifts an integer value to the left (in zeroes) by a specified number of bits,
        //     pushing the result onto the evaluation stack.
        Shl = 0x0062,
        //
        // Summary:
        //     Shifts an integer value (in sign) to the right by a specified number of bits,
        //     pushing the result onto the evaluation stack.
        Shr = 0x0063,
        //
        // Summary:
        //     Shifts an unsigned integer value (in zeroes) to the right by a specified number
        //     of bits, pushing the result onto the evaluation stack.
        Shr_Un = 0x0064,
        //
        // Summary:
        //     Pushes the size, in bytes, of a supplied value type onto the evaluation stack.
        Sizeof = 0xFE1C,
        //
        // Summary:
        //     Stores the value on top of the evaluation stack in the argument slot at a specified
        //     index.
        Starg = 0xFE0B,
        //
        // Summary:
        //     Stores the value on top of the evaluation stack in the argument slot at a specified
        //     index, short form.
        Starg_S = 0x0010,
        //
        // Summary:
        //     Replaces the array element at a given index with the value on the evaluation
        //     stack, whose type is specified in the instruction.
        Stelem = 0x00A4,
        //
        // Summary:
        //     Replaces the array element at a given index with the native int value on the
        //     evaluation stack.
        Stelem_I = 0x009B,
        //
        // Summary:
        //     Replaces the array element at a given index with the int8 value on the evaluation
        //     stack.
        Stelem_I1 = 0x009C,
        //
        // Summary:
        //     Replaces the array element at a given index with the int16 value on the evaluation
        //     stack.
        Stelem_I2 = 0x009D,
        //
        // Summary:
        //     Replaces the array element at a given index with the int32 value on the evaluation
        //     stack.
        Stelem_I4 = 0x009E,
        //
        // Summary:
        //     Replaces the array element at a given index with the int64 value on the evaluation
        //     stack.
        Stelem_I8 = 0x009F,
        //
        // Summary:
        //     Replaces the array element at a given index with the float32 value on the evaluation
        //     stack.
        Stelem_R4 = 0x00A0,
        //
        // Summary:
        //     Replaces the array element at a given index with the float64 value on the evaluation
        //     stack.
        Stelem_R8 = 0x00A1,
        //
        // Summary:
        //     Replaces the array element at a given index with the object ref value (type O)
        //     on the evaluation stack.
        Stelem_Ref = 0x00A2,
        //
        // Summary:
        //     Replaces the value stored in the field of an object reference or pointer with
        //     a new value.
        Stfld = 0x007D,
        //
        // Summary:
        //     Stores a value of type native int at a supplied address.
        Stind_I = 0x00DF,
        //
        // Summary:
        //     Stores a value of type int8 at a supplied address.
        Stind_I1 = 0x0052,
        //
        // Summary:
        //     Stores a value of type int16 at a supplied address.
        Stind_I2 = 0x0053,
        //
        // Summary:
        //     Stores a value of type int32 at a supplied address.
        Stind_I4 = 0x0054,
        //
        // Summary:
        //     Stores a value of type int64 at a supplied address.
        Stind_I8 = 0x0055,
        //
        // Summary:
        //     Stores a value of type float32 at a supplied address.
        Stind_R4 = 0x0056,
        //
        // Summary:
        //     Stores a value of type float64 at a supplied address.
        Stind_R8 = 0x0057,
        //
        // Summary:
        //     Stores a object reference value at a supplied address.
        Stind_Ref = 0x0051,
        //
        // Summary:
        //     Pops the current value from the top of the evaluation stack and stores it in
        //     a the local variable list at a specified index.
        Stloc = 0xFE0E,
        //
        // Summary:
        //     Pops the current value from the top of the evaluation stack and stores it in
        //     a the local variable list at index 0.
        Stloc_0 = 0x000A,
        //
        // Summary:
        //     Pops the current value from the top of the evaluation stack and stores it in
        //     a the local variable list at index 1.
        Stloc_1 = 0x000B,
        //
        // Summary:
        //     Pops the current value from the top of the evaluation stack and stores it in
        //     a the local variable list at index 2.
        Stloc_2 = 0x000C,
        //
        // Summary:
        //     Pops the current value from the top of the evaluation stack and stores it in
        //     a the local variable list at index 3.
        Stloc_3 = 0x000D,
        //
        // Summary:
        //     Pops the current value from the top of the evaluation stack and stores it in
        //     a the local variable list at index (short form).
        Stloc_S = 0x0013,
        //
        // Summary:
        //     Copies a value of a specified type from the evaluation stack into a supplied
        //     memory address.
        Stobj = 0x0081,
        //
        // Summary:
        //     Replaces the value of a static field with a value from the evaluation stack.
        Stsfld = 0x0080,
        //
        // Summary:
        //     Subtracts one value from another and pushes the result onto the evaluation stack.
        Sub = 0x0059,
        //
        // Summary:
        //     Subtracts one integer value from another, performs an overflow check, and pushes
        //     the result onto the evaluation stack.
        Sub_Ovf = 0x00DA,
        //
        // Summary:
        //     Subtracts one unsigned integer value from another, performs an overflow check,
        //     and pushes the result onto the evaluation stack.
        Sub_Ovf_Un = 0x00DB,
        //
        // Summary:
        //     Implements a jump table.
        Switch = 0x0045,
        //
        // Summary:
        //     Performs a postfixed method call instruction such that the current method's stack
        //     frame is removed before the actual call instruction is executed.
        Tailcall = 0xFE14,
        //
        // Summary:
        //     Throws the exception object currently on the evaluation stack.
        Throw = 0x007A,
        //
        // Summary:
        //     Indicates that an address currently atop the evaluation stack might not be aligned
        //     to the natural size of the immediately following ldind, stind, ldfld, stfld,
        //     ldobj, stobj, initblk, or cpblk instruction.
        Unaligned = 0xFE12,
        //
        // Summary:
        //     Converts the boxed representation of a value type to its unboxed form.
        Unbox = 0x0079,
        //
        // Summary:
        //     Converts the boxed representation of a type specified in the instruction to its
        //     unboxed form.
        Unbox_Any = 0x00A5,
        //
        // Summary:
        //     Specifies that an address currently atop the evaluation stack might be volatile,
        //     and the results of reading that location cannot be cached or that multiple stores
        //     to that location cannot be suppressed.
        Volatile = 0xFE13,
        //
        // Summary:
        //     Computes the bitwise XOR of the top two values on the evaluation stack, pushing
        //     the result onto the evaluation stack.
        Xor = 0x0061,
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler MSIL Implementation Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomixilc.Attributes
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
    internal class ILImplAttribute : Attribute
    {
        internal readonly ILCode OpCode;

        internal ILImplAttribute(ILCode aOpCode)
        {
            OpCode = aOpCode;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 IMul Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class IMul : OnlyDestination
    {
        public IMul()
            : base("imul")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 In Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class In : DestinationSource
    {
        public In()
            : base("in")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Architecture Instructions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine
{
    public abstract class Instruction
    {
        internal static FunctionalBlock Block;

        public readonly string Mnemonic;

        public Instruction(string aMnemonic)
        {
            Mnemonic = aMnemonic;
            if (Block == null)
            {
                Verbose.Warning("Floating Instructions");
                return;
            }
            Block.Body.Add(this);
        }

        public override string ToString()
        {
            return Mnemonic.ToString();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Application Internals support functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Lib
{
    public static class Internals
    {
        #region GetHashCode
        //http://www.cse.yorku.ca/~oz/hash.html
        public static uint GetHashCode(string aData)
        {
            uint Hash = 0;

            int index = 0, length = aData.Length;
            while (index < length)
                Hash = aData[index++] + (Hash << 16) + (Hash << 6) - Hash;
            return Hash;
        }

        public static uint GetHashCode(uint aData)
        {
            return aData;
        }

        public static uint GetHashCode(char[] aData)
        {
            uint Hash = 0;

            int index = 0, length = aData.Length;
            while (index < length)
                Hash = aData[index++] + (Hash << 16) + (Hash << 6) - Hash;
            return Hash;
        }

        public static uint GetHashCode(byte[] aData)
        {
            uint Hash = 0;
            
            int index = 0, length = aData.Length;
            while (index < length)
                Hash = aData[index++] + (Hash << 16) + (Hash << 6) - Hash;
            return Hash;
        }

        #endregion

        #region Equals
        public static bool Equals(uint a, uint b)
        {
            return (a == b);
        }
        #endregion
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Iret Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Iret : Instruction
    {
        public Iret()
            : base("iret")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Jmp Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Jmp : Instruction
    {
        public ConditionalJump? Condition;
        public string DestinationRef;
        public ushort? Selector;

        string ParentLabel;

        public Jmp()
            :base("jmp")
        {
            ParentLabel = Label.Primary;
        }

        public override string ToString()
        {
            if (!Condition.HasValue)
                Condition = ConditionalJump.JMP;

            if (DestinationRef.StartsWith("."))
                DestinationRef = ParentLabel + DestinationRef;

            if (Selector.HasValue)
                DestinationRef = string.Format("{0}:{1}", Selector, DestinationRef);

            if (Condition == ConditionalJump.JMP)
                return string.Format("jmp {0}", DestinationRef);

            return string.Format("{0} near {1}", Condition.ToString().ToLower(), DestinationRef);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Assembly Labels
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine
{
    public class Label : Instruction
    {
        string mlabel;

        public static string Primary;

        public Label(string aLabel)
            :base(string.Empty)
        {
            if (aLabel.StartsWith("."))
                mlabel = Primary + aLabel;
            else
            {
                Primary = aLabel;
                mlabel = aLabel;
            }
        }

        public override string ToString()
        {
            return string.Format("{0}:", mlabel);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldarga MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldarga)]
    internal class Ldarga_il : MSIL
    {
        public Ldarga_il()
            : base(ILCode.Ldarga)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldarga(v=vs.110).aspx
         * Description : Load an argument address onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var index = ((OpVar)xOp).Value;

            int EBPoffset = Ldarg_il.GetArgumentOffset(Config, method, index);

            /* The stack transitional behavior, in sequential order, is:
             * The address addr of the argument indexed by index is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Lea { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = EBPoffset, SourceIndirect = true };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldarg MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldarg)]
    internal class Ldarg_il : MSIL
    {
        public Ldarg_il()
            : base(ILCode.Ldarg)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldarg(v=vs.110).aspx
         * Description : Loads an argument (referenced by a specified index value) onto the stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var index = ((OpVar)xOp).Value;

            int EBPoffset = GetArgumentOffset(Config, method, index);

            Type ArgType = null;
            if (!method.IsStatic)
            {
                if (index == 0)
                {
                    ArgType = method.DeclaringType;
                    if (method.DeclaringType.IsValueType)
                        ArgType = ArgType.MakeByRefType();
                }
                else
                    ArgType = method.GetParameters()[index - 1].ParameterType;
            }
            else
                ArgType = method.GetParameters()[index].ParameterType;

            int ArgSize = Helper.GetTypeSize(ArgType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * The argument value at index is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (ArgSize > 4)
                            throw new Exception("Unsupported ArgSize");

                        new Push
                        {
                            DestinationReg = Register.EBP,
                            DestinationDisplacement = EBPoffset,
                            DestinationIndirect = true
                        };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(ArgType));
            Optimizer.SaveStack(xOp.NextPosition);
        }

        internal static int GetArgumentOffset(Options Config, MethodBase method, int paramIndex)
        {
            if (Config.TargetPlatform != Architecture.x86)
                throw new Exception("Unsupported Platform");

            var xparams = method.GetParameters();

            if (!method.IsStatic) paramIndex--;

            int offset = 8, index = xparams.Length - 1;
            while(index > paramIndex)
            {
                offset += Helper.GetTypeSize(xparams[index].ParameterType, Config.TargetPlatform, true);
                index--;
            }

            return offset;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldc_I4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldc_I4)]
    internal class Ldc_I4_il : MSIL
    {
        public Ldc_I4_il()
            : base(ILCode.Ldc_I4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldc_I4(v=vs.110).aspx
         * Description : Pushes a supplied value of type int32 onto the evaluation stack as an int32.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var num = ((OpInt)xOp).Value;

            /* The stack transitional behavior, in sequential order, is:
             * The value num is pushed onto the stack
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Push { DestinationRef = "0x" + num.ToString("X") };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(int)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldc_I8 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldc_I8)]
    internal class Ldc_I8_il : MSIL
    {
        public Ldc_I8_il()
            : base(ILCode.Ldc_I8)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldc_I8(v=vs.110).aspx
         * Description : Pushes a supplied value of type int64 onto the evaluation stack as an int64.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var num = ((OpInt64)xOp).Value;

            /* The stack transitional behavior, in sequential order, is:
             * The value num is pushed onto the stack
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Push { DestinationRef = "0x" + ((uint)(num >> 32)).ToString("X") };
                        new Push { DestinationRef = "0x" + ((uint)num).ToString("X") };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(long)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldc_R4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldc_R4)]
    internal class Ldc_R4_il : MSIL
    {
        public Ldc_R4_il()
            : base(ILCode.Ldc_R4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldc_R4(v=vs.110).aspx
         * Description : Pushes a supplied value of type float32 onto the evaluation stack as type F (float).
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var num = ((OpSingle)xOp).Value;
            var xData = BitConverter.GetBytes(num);

            /* The stack transitional behavior, in sequential order, is:
             * The value num is pushed onto the stack
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {

                        new Push { DestinationRef = "0x" + BitConverter.ToUInt32(xData, 0).ToString("X") };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(float)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldc_R8 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldc_R8)]
    internal class Ldc_R8_il : MSIL
    {
        public Ldc_R8_il()
            : base(ILCode.Ldc_R8)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldc_R8(v=vs.110).aspx
         * Description : Pushes a supplied value of type float64 onto the evaluation stack as type F (float).
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var num = ((OpDouble)xOp).Value;
            var xData = BitConverter.GetBytes(num);

            /* The stack transitional behavior, in sequential order, is:
             * The value num is pushed onto the stack
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {

                        new Push { DestinationRef = "0x" + BitConverter.ToUInt32(xData, 4).ToString("X") };
                        new Push { DestinationRef = "0x" + BitConverter.ToUInt32(xData, 0).ToString("X") };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(double)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelema MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelema)]
    internal class Ldelema_il : MSIL
    {
        public Ldelema_il()
            : base(ILCode.Ldelema)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelema(v=vs.110).aspx
         * Description : Loads the address of the array element at a specified array index onto the top of the evaluation stack as type & (managed pointer).
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var operand = ((OpType)xOp).Value;
            var size = Helper.GetTypeSize(operand, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The address is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Mov { DestinationReg = Register.EDX, SourceRef = "0x" + size.ToString("X") };
                        new Mul { DestinationReg = Register.EDX };

                        new Pop { DestinationReg = Register.EDX };
                        new Add { DestinationReg = Register.EDX, SourceReg = Register.EAX };
                        new Add { DestinationReg = Register.EDX, SourceRef = "0x10" };

                        new Push { DestinationReg = Register.EDX };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(uint)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem)]
    internal class Ldelem_il : MSIL
    {
        public Ldelem_il()
            : base(ILCode.Ldelem)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem(v=vs.110).aspx
         * Description : Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var operand = ((OpType)xOp).Value;
            var size = Helper.GetTypeSize(operand, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Executex86(size, true);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(operand));
            Optimizer.SaveStack(xOp.NextPosition);
        }

        internal static void Executex86(int size, bool IsSigned)
        {
            new Pop { DestinationReg = Register.EAX };
            new Pop { DestinationReg = Register.EDX };

            switch (size)
            {
                case 1: break;
                case 2:
                    new Add { DestinationReg = Register.EAX, SourceReg = Register.EAX };
                    break;
                case 4:
                    new Shl { DestinationReg = Register.EAX, SourceRef = "0x2" };
                    break;
                default:
                    throw new Exception("size not supported");
            }

            new Add { DestinationReg = Register.EAX, SourceReg = Register.EDX };

            if (size < 4)
            {
                if (IsSigned)
                    new Movsx { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceDisplacement = 0x10, SourceIndirect = true, Size = (byte)(size * 8) };
                else
                    new Movzx { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceDisplacement = 0x10, SourceIndirect = true, Size = (byte)(size * 8) };
                new Push { DestinationReg = Register.EAX };
            }
            else
            {
                new Push { DestinationReg = Register.EAX, DestinationDisplacement = 0x10, DestinationIndirect = true };
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem_I1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem_I1)]
    internal class Ldelem_I1_il : MSIL
    {
        public Ldelem_I1_il()
            : base(ILCode.Ldelem_I1)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem_I1(v=vs.110).aspx
         * Description : Loads the element with type int8 at a specified array index onto the top of the evaluation stack as an int32.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldelem_il.Executex86(1, true);
                        Optimizer.vStack.Push(new StackItem(typeof(int)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem_I2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem_I2)]
    internal class Ldelem_I2_il : MSIL
    {
        public Ldelem_I2_il()
            : base(ILCode.Ldelem_I2)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem_I2(v=vs.110).aspx
         * Description : Loads the element with type int16 at a specified array index onto the top of the evaluation stack as an int32.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldelem_il.Executex86(2, true);
                        Optimizer.vStack.Push(new StackItem(typeof(int)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem_I4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem_I4)]
    internal class Ldelem_I4_il : MSIL
    {
        public Ldelem_I4_il()
            : base(ILCode.Ldelem_I4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem_I4(v=vs.110).aspx
         * Description : Loads the element with type int32 at a specified array index onto the top of the evaluation stack as an int32.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldelem_il.Executex86(4, true);
                        Optimizer.vStack.Push(new StackItem(typeof(int)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem_I MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem_I)]
    internal class Ldelem_I_il : MSIL
    {
        public Ldelem_I_il()
            : base(ILCode.Ldelem_I)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem_I(v=vs.110).aspx
         * Description : Loads the element with type native int at a specified array index onto the top of the evaluation stack as a native int.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldelem_il.Executex86(4, true);
                        Optimizer.vStack.Push(new StackItem(typeof(int)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem_Ref MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem_Ref)]
    internal class Ldelem_Ref_il : MSIL
    {
        public Ldelem_Ref_il()
            : base(ILCode.Ldelem_Ref)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem_Ref(v=vs.110).aspx
         * Description : Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type O (object reference).
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldelem_il.Executex86(4, false);
                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem_U1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem_U1)]
    internal class Ldelem_U1_il : MSIL
    {
        public Ldelem_U1_il()
            : base(ILCode.Ldelem_U1)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem_U1(v=vs.110).aspx
         * Description : Loads the element with type unsigned int8 at a specified array index onto the top of the evaluation stack as an int32.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldelem_il.Executex86(1, false);
                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem_U2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem_U2)]
    internal class Ldelem_U2_il : MSIL
    {
        public Ldelem_U2_il()
            : base(ILCode.Ldelem_U2)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem_U2(v=vs.110).aspx
         * Description : Loads the element with type unsigned int16 at a specified array index onto the top of the evaluation stack as an int32.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldelem_il.Executex86(2, false);
                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldelem_U4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldelem_U4)]
    internal class Ldelem_U4_il : MSIL
    {
        public Ldelem_U4_il()
            : base(ILCode.Ldelem_U4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldelem_U4(v=vs.110).aspx
         * Description : Loads the element with type unsigned int32 at a specified array index onto the top of the evaluation stack as an int32.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference array is pushed onto the stack.
             * An index value index is pushed onto the stack.
             * index and array are popped from the stack; the value stored at position index in array is looked up.
             * The value is pushed onto the stack.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldelem_il.Executex86(4, false);
                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldflda MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldflda)]
    internal class Ldflda_il : MSIL
    {
        public Ldflda_il()
            : base(ILCode.Ldflda)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldflda(v=vs.110).aspx
         * Description : Finds the address of a field in the object whose reference is currently on the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var field = ((OpField)xOp).Value;
            var offset = Helper.GetFieldOffset(field.DeclaringType, field, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * An object reference (or pointer) is pushed onto the stack.
             * The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.
             * The address of the specified field is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Add { DestinationReg = Register.ESP, DestinationIndirect = true, SourceRef = "0x" + offset.ToString("X") };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(uint)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldfld MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldfld)]
    internal class Ldfld_il : MSIL
    {
        public Ldfld_il()
            : base(ILCode.Ldfld)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldfld(v=vs.110).aspx
         * Description : Finds the value of a field in the object whose reference is currently on the evaluation stack
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var field = ((OpField)xOp).Value;
            var offset = Helper.GetFieldOffset(field.DeclaringType, field, Config.TargetPlatform);
            var size = Helper.GetTypeSize(field.FieldType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * An object reference (or pointer) is pushed onto the stack.
             * The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.
             * The value stored in the field is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };

                        for (int i = 1; i <= (size / 4); i++)
                        {
                            new Push
                            {
                                DestinationReg = Register.EAX,
                                DestinationIndirect = true,
                                DestinationDisplacement = (size - (i * 4) + offset)
                            };
                        }

                        switch(size % 4)
                        {
                            case 0: break;
                            case 1:
                                {
                                    new Movzx { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceIndirect = true, SourceDisplacement = offset, Size = 8 };
                                    new Push { DestinationReg = Register.EAX };
                                }
                                break;
                            case 2:
                                {
                                    new Movzx { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceIndirect = true, SourceDisplacement = offset, Size = 16 };
                                    new Push { DestinationReg = Register.EAX };
                                }
                                break;
                            default:
                                throw new Exception("Unsupported Size");
                        }
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(field.FieldType));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldftn MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldftn)]
    internal class Ldftn_il : MSIL
    {
        public Ldftn_il()
            : base(ILCode.Ldftn)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldftn(v=vs.110).aspx
         * Description : Pushes an unmanaged pointer (type native int) to the native code implementing a specific method onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var function = ((OpMethod)xOp).Value;

            /* The stack transitional behavior, in sequential order, is:
             * The unmanaged pointer to a specific method is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Push { DestinationRef = function.FullName() };

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldind_I1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldind_I1)]
    internal class Ldind_I1_il : MSIL
    {
        public Ldind_I1_il()
            : base(ILCode.Ldind_I1)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldind_I1(v=vs.110).aspx
         * Description : Loads a value of type int8 as an int32 onto the evaluation stack indirectly.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * The address is popped from the stack; the value located at the address is fetched.
             * The fetched value is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldind_I_il.Executex86(1, true);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(int)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldind_I2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldind_I2)]
    internal class Ldind_I2_il : MSIL
    {
        public Ldind_I2_il()
            : base(ILCode.Ldind_I2)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldind_I2(v=vs.110).aspx
         * Description : Loads a value of type int16 as an int32 onto the evaluation stack indirectly.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * The address is popped from the stack; the value located at the address is fetched.
             * The fetched value is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldind_I_il.Executex86(2, true);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(int)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldind_I4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldind_I4)]
    internal class Ldind_I4_il : MSIL
    {
        public Ldind_I4_il()
            : base(ILCode.Ldind_I4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldind_I4(v=vs.110).aspx
         * Description : Loads a value of type int32 as an int32 onto the evaluation stack indirectly.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * The address is popped from the stack; the value located at the address is fetched.
             * The fetched value is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldind_I_il.Executex86(4, true);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(int)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldind_I MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldind_I)]
    internal class Ldind_I_il : MSIL
    {
        public Ldind_I_il()
            : base(ILCode.Ldind_I)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldind_I(v=vs.110).aspx
         * Description : Loads a value of type native int as a native int onto the evaluation stack indirectly.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * The address is popped from the stack; the value located at the address is fetched.
             * The fetched value is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Executex86(4, true);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(int)));
            Optimizer.SaveStack(xOp.NextPosition);
        }

        internal static void Executex86(int size, bool IsSigned)
        {
            new Pop { DestinationReg = Register.EDX };

            if (size < 4)
            {
                if (IsSigned)
                    new Movsx { DestinationReg = Register.EAX, SourceReg = Register.EDX, SourceIndirect = true, Size = (byte)(size * 8) };
                else
                    new Movzx { DestinationReg = Register.EAX, SourceReg = Register.EDX, SourceIndirect = true, Size = (byte)(size * 8) };
                new Push { DestinationReg = Register.EAX };
            }
            else
                new Push { DestinationReg = Register.EDX, DestinationIndirect = true };
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldind_Ref MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldind_Ref)]
    internal class Ldind_Ref_il : MSIL
    {
        public Ldind_Ref_il()
            : base(ILCode.Ldind_Ref)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldind_Ref(v=vs.110).aspx
         * Description : Loads a value of type int32 as an int32 onto the evaluation stack indirectly.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * The address is popped from the stack; the value located at the address is fetched.
             * The fetched value is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldind_I_il.Executex86(4, true);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(int)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldind_U1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldind_U1)]
    internal class Ldind_U1_il : MSIL
    {
        public Ldind_U1_il()
            : base(ILCode.Ldind_U1)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldind_U1(v=vs.110).aspx
         * Description : Loads a value of type unsigned int8 as an int32 onto the evaluation stack indirectly.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * The address is popped from the stack; the value located at the address is fetched.
             * The fetched value is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldind_I_il.Executex86(1, false);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(uint)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldind_U2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldind_U2)]
    internal class Ldind_U2_il : MSIL
    {
        public Ldind_U2_il()
            : base(ILCode.Ldind_U2)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldind_U2(v=vs.110).aspx
         * Description : Loads a value of type unsigned int16 as an int32 onto the evaluation stack indirectly.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * The address is popped from the stack; the value located at the address is fetched.
             * The fetched value is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldind_I_il.Executex86(2, false);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(uint)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldind_U4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldind_U4)]
    internal class Ldind_U4_il : MSIL
    {
        public Ldind_U4_il()
            : base(ILCode.Ldind_U4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldind_U4(v=vs.110).aspx
         * Description : Loads a value of type unsigned int32 as an int32 onto the evaluation stack indirectly.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * The address is popped from the stack; the value located at the address is fetched.
             * The fetched value is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Ldind_I_il.Executex86(4, false);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.vStack.Push(new StackItem(typeof(uint)));
            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldlen MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldlen)]
    internal class Ldlen_il : MSIL
    {
        public Ldlen_il()
            : base(ILCode.Ldlen)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldlen(v=vs.110).aspx
         * Description : Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference to an array is pushed onto the stack.
             * The array reference is popped from the stack and the length is computed.
             * The length is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Push { DestinationReg = Register.EAX, DestinationDisplacement = 8, DestinationIndirect = true };

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldnull MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldnull)]
    internal class Ldnull_il : MSIL
    {
        public Ldnull_il()
            : base(ILCode.Ldnull)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldnull(v=vs.110).aspx
         * Description : Pushes a null reference (type O) onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            /* The stack transitional behavior, in sequential order, is:
             * A null object reference is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Push { DestinationRef = "0x0" };

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldobj MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldobj)]
    internal class Ldobj_il : MSIL
    {
        public Ldobj_il()
            : base(ILCode.Ldobj)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldobj(v=vs.110).aspx
         * Description : Copies the value type object pointed to by an address to the top of the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var xOpType = ((OpType)xOp).Value;
            var size = Helper.GetTypeSize(xOpType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * The address of a value type object is pushed onto the stack.
             * The address is popped from the stack and the instance at that particular address is looked up.
             * The value of the object stored at that address is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        for (int i = 1; i <= (size / 4); i++)
                        {
                            new Push
                            {
                                DestinationReg = Register.EAX,
                                DestinationIndirect = true,
                                DestinationDisplacement = (size - (i * 4))
                            };
                        }

                        switch (size % 4)
                        {
                            case 0: break;
                            case 1:
                                {
                                    new Movzx { DestinationReg = Register.EAX, SourceReg = Register.ESI, SourceIndirect = true, Size = 8 };
                                    new Push { DestinationReg = Register.EAX };
                                }
                                break;
                            case 2:
                                {
                                    new Movzx { DestinationReg = Register.EAX, SourceReg = Register.ESI, SourceIndirect = true, Size = 16 };
                                    new Push { DestinationReg = Register.EAX };
                                }
                                break;
                            default:
                                throw new Exception("Unsupported Size");
                        }

                        Optimizer.vStack.Push(new StackItem(xOpType));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldsflda MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;
using System.Linq;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldsflda)]
    internal class Ldsflda_il : MSIL
    {
        public Ldsflda_il()
            : base(ILCode.Ldsflda)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldsflda(v=vs.110).aspx
         * Description : Pushes the address of a static field onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var field = ((OpField)xOp).Value;
            var fieldName = field.FullName();
            var size = Helper.GetTypeSize(field.FieldType, Config.TargetPlatform);

            string cctor_addref = null;

            var cctor = (field.DeclaringType.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public) ?? new ConstructorInfo[0]).SingleOrDefault();
            if (cctor != null)
                cctor_addref = cctor.FullName();

            /* The stack transitional behavior, in sequential order, is:
             * The value of the specific field is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Push { DestinationRef = fieldName };

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldsfld MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;
using System.Linq;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldsfld)]
    internal class Ldsfld_il : MSIL
    {
        public Ldsfld_il()
            : base(ILCode.Ldsfld)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldsfld(v=vs.110).aspx
         * Description : Pushes the value of a static field onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var field = ((OpField)xOp).Value;
            var fieldName = field.FullName();
            var size = Helper.GetTypeSize(field.FieldType, Config.TargetPlatform);

            string cctor_addref = null;

            var cctor = (field.DeclaringType.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public) ?? new ConstructorInfo[0]).SingleOrDefault();
            if (cctor != null)
                cctor_addref = cctor.FullName();

            /* The stack transitional behavior, in sequential order, is:
             * The value of the specific field is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!string.IsNullOrEmpty(cctor_addref) && cctor != method)
                            new Call { DestinationRef = cctor_addref };

                        for (int i = 1; i <= (size / 4); i++)
                        {
                            new Push
                            {
                                DestinationRef = fieldName,
                                DestinationIndirect = true,
                                DestinationDisplacement = (size - (i * 4))
                            };
                        }

                        switch (size % 4)
                        {
                            case 0: break;
                            case 1:
                                {
                                    new Movzx { DestinationReg = Register.EAX, SourceRef = fieldName, SourceIndirect = true, Size = 8 };
                                    new Push { DestinationReg = Register.EAX };
                                }
                                break;
                            case 2:
                                {
                                    new Movzx { DestinationReg = Register.EAX, SourceRef = fieldName, SourceIndirect = true, Size = 16 };
                                    new Push { DestinationReg = Register.EAX };
                                }
                                break;
                            default:
                                throw new Exception("Unsupported Size");
                        }

                        Optimizer.vStack.Push(new StackItem(field.FieldType));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldstr MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldstr)]
    internal class Ldstr_il : MSIL
    {
        public Ldstr_il()
            : base(ILCode.Ldstr)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldstr(v=vs.110).aspx
         * Description : Pushes a new object reference to a string literal stored in the metadata.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var str = ((OpString)xOp).Value;

            /* The stack transitional behavior, in sequential order, is:
             * An object reference to a string is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Push { DestinationRef = Helper.GetResolvedStringLabel(str) };

                        Optimizer.vStack.Push(new StackItem(typeof(string)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ldtoken MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Ldtoken)]
    internal class Ldtoken_il : MSIL
    {
        public Ldtoken_il()
            : base(ILCode.Ldtoken)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Ldtoken(v=vs.110).aspx
         * Description : Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var token = (OpToken)xOp;
            string tokenAddress = null;

            if (token.IsField)
                tokenAddress = token.ValueField.FullName();
            else
                throw new Exception("token.IsType not implemented");

            /* The stack transitional behavior, in sequential order, is:
             * The passed token is converted to a RuntimeHandle and pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Push { DestinationRef = tokenAddress };

                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Lea Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Lea : DestinationSource
    {
        public Lea()
            : base("lea")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Leave Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Leave : Instruction
    {
        public Leave()
            :base("leave")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Libc native functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Runtime.InteropServices;

using Atomixilc.Attributes;

namespace Atomixilc.Lib
{
    public static class Libc
    {
        const string LIBRARY = "libc.a";

        [NoException]
        [Plug("_init")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        public static extern void Init();

        [NoException]
        [Plug("_fini")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        public static extern void Finish();

        [NoException]
        [Plug("malloc")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint malloc(int len);

        [NoException]
        [Plug("free")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        public static extern void free(uint addr);
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Literal Assembly Codes
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine
{
    public class Literal : Instruction
    {
        string mCode;

        public Literal(string aCode)
            : base(string.Empty)
        {
            mCode = aCode;
        }

        public Literal(string aCode, params object[] aParams)
            : base(string.Empty)
        {
            mCode = string.Format(aCode, aParams);
        }

        public override string ToString()
        {
            return mCode;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Application Memory Access support functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.Lib
{
    public static class Memory
    {
        /// <summary>
        /// Read 32 bit Memory at given address :)
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [NoException]
        [Assembly(false)]
        public static uint Read32(uint aAddress)
        {
            // Load address into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            // Read memory into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceIndirect = true };
            // Return
            new Ret { Offset = 0x4 };

            return 0; // For c# error --> Don't make any sense for compiler
        }

        /// <summary>
        /// Read 16 bit Memory at given address :)
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [NoException]
        [Assembly(false)]
        public static ushort Read16(uint aAddress)
        {
            // Load address into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            // Read memory into EAX
            new Movzx { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceIndirect = true, Size = 16 };
            // Return
            new Ret { Offset = 0x4 };

            return 0; // For c# error --> Don't make any sense for compiler
        }

        /// <summary>
        /// Read 8 bit Memory at given address :)
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [NoException]
        [Assembly(false)]
        public static byte Read8(uint aAddress)
        {
            // Load address into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            // Read memory into EAX
            new Movzx { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceIndirect = true, Size = 8 };
            // Return
            new Ret { Offset = 0x4 };

            return 0; // For c# error --> Don't make any sense for compiler
        }

        /// <summary>
        /// Write 32 bit Memory at given address :)
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [NoException]
        [Assembly(false)]
        public static void Write32(uint aAddress, uint Value)
        {
            // Load address into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Load Value into EDX
            new Mov { DestinationReg = Register.EBX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            // Save value at mem Location
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBX, DestinationIndirect = true };
            // Return
            new Ret { Offset = 0x8 };
        }

        /// <summary>
        /// Write 16 bit Memory at given address :)
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [NoException]
        [Assembly(false)]
        public static void Write16(uint aAddress, ushort Value)
        {
            // Load address into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Load Value into EDX
            new Mov { DestinationReg = Register.EBX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            // Save value at mem Location
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.BX, DestinationIndirect = true, Size = 16 };
            // Return
            new Ret { Offset = 0x8 };
        }

        /// <summary>
        /// Write 8 bit Memory at given address :)
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [NoException]
        [Assembly(false)]
        public static void Write8(uint aAddress, byte Value)
        {
            // Load address into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Load Value into EDX
            new Mov { DestinationReg = Register.EBX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            // Save value at mem Location
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.BL, DestinationIndirect = true, Size = 8 };
            // Return
            new Ret { Offset = 0x8 };
        }

        [NoException]
        [Assembly(false)]
        public static void FastCopy(uint aDest, uint aSrc, uint aLen)
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            new Mov { DestinationReg = Register.ESI, SourceReg = Register.ESP, SourceDisplacement = 0x8, SourceIndirect = true };
            new Mov { DestinationReg = Register.EDI, SourceReg = Register.ESP, SourceDisplacement = 0xC, SourceIndirect = true };

            new Mov { DestinationReg = Register.ECX, SourceReg = Register.EAX };
            new Shr { DestinationReg = Register.ECX, SourceRef = "0x2" };
            new Literal("rep movsd");
            new Mov { DestinationReg = Register.ECX, SourceReg = Register.EAX };
            new And { DestinationReg = Register.ECX, SourceRef = "0x3" };
            new Literal("rep movsb");

            // Return
            new Ret { Offset = 0xC };
        }

        [NoException]
        [Assembly(false)]
        public static unsafe void FastClear(uint Address, uint Length)
        {
            new Mov { DestinationReg = Register.EBX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            new Mov { DestinationReg = Register.EDI, SourceReg = Register.ESP, SourceDisplacement = 0x8, SourceIndirect = true };

            new Xor { DestinationReg = Register.EAX, SourceReg = Register.EAX };
            new Mov { DestinationReg = Register.ECX, SourceReg = Register.EBX };
            new Shr { DestinationReg = Register.ECX, SourceRef = "0x2" };
            new Literal("rep stosd");// Copy EAX to EDI
            new Mov { DestinationReg = Register.ECX, SourceReg = Register.EBX };
            new And { DestinationReg = Register.ECX, SourceRef = "0x3" };// Modulo by 4
            new Literal("rep stosb");

            // Return
            new Ret { Offset = 0x8 };
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Mov Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Mov : DestinationSourceSize
    {
        public Mov()
            :base("mov")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Movsx Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Text;

namespace Atomixilc.Machine.x86
{
    public class Movsx : DestinationSourceSize
    {
        public Movsx()
            : base("movsx")
        {

        }

        public override string ToString()
        {
            if ((!string.IsNullOrEmpty(DestinationRef) && DestinationReg.HasValue) ||
                (string.IsNullOrEmpty(DestinationRef) && !DestinationReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Destination Parameters", Mnemonic));

            if ((!string.IsNullOrEmpty(SourceRef) && SourceReg.HasValue) ||
                (string.IsNullOrEmpty(SourceRef) && !SourceReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Source Parameters", Mnemonic));

            var SB = new StringBuilder();
            SB.Append(Mnemonic);
            SB.Append(' ');

            if (DestinationIndirect)
                SB.Append('[');

            if (DestinationReg.HasValue)
                SB.Append(DestinationReg.Value);
            else
                SB.Append(DestinationRef);

            if (DestinationDisplacement.HasValue && DestinationDisplacement != 0)
            {
                int offset = DestinationDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (DestinationIndirect)
                SB.Append(']');

            SB.Append(", ");

            SB.Append(Helper.SizeToString(Size));
            SB.Append(' ');

            if (SourceIndirect)
                SB.Append('[');

            if (SourceReg.HasValue)
                SB.Append(SourceReg.Value);
            else
                SB.Append(SourceRef);

            if (SourceDisplacement.HasValue && SourceDisplacement != 0)
            {
                int offset = SourceDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (SourceIndirect)
                SB.Append(']');

            return SB.ToString();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Movzx Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Text;

namespace Atomixilc.Machine.x86
{
    public class Movzx : DestinationSourceSize
    {
        public Movzx()
            : base("movzx")
        {

        }

        public override string ToString()
        {
            if ((!string.IsNullOrEmpty(DestinationRef) && DestinationReg.HasValue) ||
                (string.IsNullOrEmpty(DestinationRef) && !DestinationReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Destination Parameters", Mnemonic));

            if ((!string.IsNullOrEmpty(SourceRef) && SourceReg.HasValue) ||
                (string.IsNullOrEmpty(SourceRef) && !SourceReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Source Parameters", Mnemonic));

            var SB = new StringBuilder();
            SB.Append(Mnemonic);
            SB.Append(' ');

            if (DestinationIndirect)
                SB.Append('[');

            if (DestinationReg.HasValue)
                SB.Append(DestinationReg.Value);
            else
                SB.Append(DestinationRef);

            if (DestinationDisplacement.HasValue && DestinationDisplacement != 0)
            {
                int offset = DestinationDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (DestinationIndirect)
                SB.Append(']');

            SB.Append(", ");

            SB.Append(Helper.SizeToString(Size));
            SB.Append(' ');

            if (SourceIndirect)
                SB.Append('[');

            if (SourceReg.HasValue)
                SB.Append(SourceReg.Value);
            else
                SB.Append(SourceRef);

            if (SourceDisplacement.HasValue && SourceDisplacement != 0)
            {
                int offset = SourceDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (SourceIndirect)
                SB.Append(']');

            return SB.ToString();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL Abstract Type
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL
{
    internal abstract class MSIL
    {
        internal ILCode msIL;

        internal MSIL(ILCode aILCode)
        {
            msIL = aILCode;
        }

        internal abstract void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer);
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Mul Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Mul : OnlyDestination
    {
        public Mul()
            : base("mul")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Application architecture native support functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.Lib
{
    public static class Native
    {
        /// <summary>
        /// Clear Interrupts
        /// </summary>
        [NoException]
        [Assembly(false)]
        public static void Cli()
        {
            new Cli();
            new Ret { Offset = 0x0 };
        }

        /// <summary>
        /// Enable Interrupts
        /// </summary>
        [NoException]
        [Assembly(false)]
        public static void Sti()
        {
            new Sti();
            new Ret { Offset = 0x0 };
        }

        /// <summary>
        /// Halt The Processor
        /// </summary>
        [NoException]
        [Assembly(false)]
        public static void Hlt()
        {
            new Literal("hlt");
            new Ret { Offset = 0x0 };
        }
        
        [NoException]
        [Assembly(false)]
        public static uint GetDataOffset(this string aStr)
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            new Add { DestinationReg = Register.EAX, SourceRef = "0x10" };
            new Ret { Offset = 0x4 };

            return 0;
        }

        [NoException]
        [Assembly(false)]
        public static uint GetDataOffset(this Array aArray)
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            new Add { DestinationReg = Register.EAX, SourceRef = "0x10" };
            new Ret { Offset = 0x4 };

            return 0;
        }

        /// <summary>
        /// Get Invokable method address from Action Delegate
        /// </summary>
        /// <param name="aDelegate"></param>
        /// <returns></returns>
        [NoException]
        [Assembly(false)]
        public static uint InvokableAddress(this Delegate aDelegate)
        {
            // Compiler.cs : ProcessDelegate(MethodBase xMethod);
            // [aDelegate + 0xC] := Address Field
            new Mov
            {
                DestinationReg = Register.EAX,
                SourceReg = Register.ESP,
                SourceDisplacement = 0x4,
                SourceIndirect = true
            };

            new Mov { DestinationReg = Register.EAX,  SourceReg = Register.EAX, SourceDisplacement = 0xC, SourceIndirect = true };
            new Ret { Offset = 0x4 };

            return 0;
        }

        [NoException]
        [Assembly(false)]
        public static uint GetStackPointer()
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP };
            new Add { DestinationReg = Register.EAX, SourceRef = "0x4" };
            new Ret { Offset = 0x0 };

            return 0;
        }

        /// <summary>
        /// End of kernel offset
        /// </summary>
        /// <returns></returns>
        [NoException]
        [Assembly(false)]
        public static uint EndOfKernel()
        {
            // Just put Compiler_End location into return value
            new Mov { DestinationReg = Register.EAX, SourceRef = Helper.Compiler_End };
            new Ret { Offset = 0x0 };

            return 0; // just for c# error
        }

        [NoException]
        [Assembly(false)]
        public static uint GlobalVarStart()
        {
            new Mov { DestinationReg = Register.EAX, SourceRef = Helper.GC_Root_Start };
            new Ret { Offset = 0x0 };

            return 0;
        }

        [NoException]
        [Assembly(false)]
        public static uint GlobalVarEnd()
        {
            new Mov { DestinationReg = Register.EAX, SourceRef = Helper.GC_Root_End };
            new Ret { Offset = 0x0 };

            return 0;
        }

        [NoException]
        [Assembly(false)]
        public static uint CR2Register()
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.CR2 };
            new Ret { Offset = 0x0 };

            return 0;
        }

        [NoException]
        [Assembly(false)]
        public static uint AtomicExchange(ref uint aLock, uint val)
        {
            new Mov { DestinationReg = Register.EBX, SourceReg = Register.ESP, SourceDisplacement = 0x8, SourceIndirect = true };
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceDisplacement = 0x4, SourceIndirect = true };
            new Literal("xchg dword [EBX], EAX");
            new Ret { Offset = 0x8 };

            return 0;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Neg MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Neg)]
    internal class Neg_il : MSIL
    {
        public Neg_il()
            : base(ILCode.Neg)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Neg(v=vs.110).aspx
         * Description : Negates a value and pushes the result onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();

            var size = Helper.GetTypeSize(item.OperandType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * A value is pushed onto the stack.
             * A value is popped from the stack and negated.
             * The result is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (item.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Xor { DestinationReg = Register.EAX, SourceRef = "0xFFFFFFFF" };
                        new Add { DestinationReg = Register.EAX, SourceRef = "0x1" };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(item.OperandType));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Newarr MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Newarr)]
    internal class Newarr_il : MSIL
    {
        public Newarr_il()
            : base(ILCode.Newarr)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Newarr(v=vs.110).aspx
         * Description : Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var type = ((OpType)xOp).Value;
            var size = Helper.GetTypeSize(type, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * The number of elements in the array is pushed onto the stack.
             * The number of elements is popped from the stack and the array is created.
             * An object reference to the new array is pushed onto the stack.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Mov { DestinationReg = Register.ESI, SourceReg = Register.ESP, SourceIndirect = true };
                        new Mov { DestinationReg = Register.EAX, SourceRef = "0x" + size.ToString() };
                        new Mul { DestinationReg = Register.ESI };
                        new Add { DestinationReg = Register.EAX, SourceRef = "0x10" };

                        new Push { DestinationReg = Register.EAX };
                        new Call { DestinationRef = Helper.Heap_Label, IsLabel = true };
                        new Test { DestinationReg = Register.ECX, SourceRef = "0xFFFFFFFF" };
                        new Jmp { Condition = ConditionalJump.JNZ, DestinationRef = xOp.HandlerRef };

                        new Pop { DestinationReg = Register.ESI };
                        new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, SourceRef = "0x" + type.GetHashCode().ToString("X") };
                        new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = 4, SourceRef = "0x" + (0x2 | (type.IsClass ? 0x1 : 0x0)).ToString("X") };
                        new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = 8, SourceReg = Register.ESI };
                        new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = 12, SourceRef = "0x" + size.ToString("X") };

                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(typeof(Array)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Newobj MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;
using System.Linq;
using System.Runtime.InteropServices;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Newobj)]
    internal class Newobj_il : MSIL
    {
        public Newobj_il()
            : base(ILCode.Newobj)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Newobj(v=vs.110).aspx
         * Description : Creates a new object or a new instance of a value type, pushing an object reference (type O) onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var xOpMethod = (OpMethod)xOp;
            var functionInfo = xOpMethod.Value;

            var addressRefernce = functionInfo.FullName();
            var parameters = functionInfo.GetParameters();
            var type = functionInfo.DeclaringType;

            int FieldIsClassType = 0;
            var memsize = Helper.GetStorageSize(type, Config.TargetPlatform, ref FieldIsClassType);
            var paramsize = parameters.Sum(para => Helper.GetTypeSize(para.ParameterType, Config.TargetPlatform, true));
            Verbose.Warning("{0} : ByRefCount '{1}'", type.FullName, FieldIsClassType);
            int count = parameters.Length;
            if (Optimizer.vStack.Count < count)
                throw new Exception("Internal Compiler Error: vStack.Count < expected size");

            if (xOpMethod.CallingConvention != CallingConvention.StdCall)
                throw new Exception(string.Format("CallingConvention '{0}' not supported", xOpMethod.CallingConvention));

            /* The stack transitional behavior, in sequential order, is:
             * Arguments arg1 through argn are pushed on the stack in sequence.
             * Arguments argn through arg1 are popped from the stack and passed to ctor for object creation.
             * A reference to the new object is pushed onto the stack.
             */

            int index = count;
            while (index > 0)
            {
                Optimizer.vStack.Pop();
                index--;
            }

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (type.IsValueType)
                            throw new Exception("Newobj ValueType not implemented");

                        if (type == typeof(string))
                        {
                            if (parameters.Length == 1)
                            {
                                var param = parameters[0].ParameterType.ToString();
                                if (param == "System.Char[]")
                                {
                                    new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceIndirect = true };
                                    new Mov { DestinationReg = Register.EAX, SourceReg = Register.EAX, SourceIndirect = true, SourceDisplacement = 8 };
                                    new Shl { DestinationReg = Register.EAX, SourceRef = "0x1" };
                                }
                                else if (param == "System.Char*")
                                {
                                    new Push { DestinationReg = Register.ESP, DestinationIndirect = true };
                                    new Call { DestinationRef = "GetLength.System.Char*", IsLabel = true };
                                    new Shl { DestinationReg = Register.EAX, SourceRef = "0x1" };
                                }
                                else if (param == "System.SByte*")
                                {
                                    new Push { DestinationReg = Register.ESP, DestinationIndirect = true };
                                    new Call { DestinationRef = "GetLength.System.SByte*", IsLabel = true };
                                    new Shl { DestinationReg = Register.EAX, SourceRef = "0x1" };
                                }
                                else
                                    throw new Exception("String constructor not implemented");
                            }
                            else if (parameters.Length == 3)
                            {
                                new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceIndirect = true };
                                new Shl { DestinationReg = Register.EAX, SourceRef = "0x1" };
                            }
                            else if (parameters.Length == 2)
                            {
                                new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP, SourceIndirect = true };
                                new Shl { DestinationReg = Register.EAX, SourceRef = "0x1" };
                            }
                            else
                                throw new Exception("String constructor not supported");

                            new Add { DestinationReg = Register.EAX, SourceRef = "0x" + memsize.ToString("X") };
                            new Push { DestinationReg = Register.EAX };
                        }
                        else
                            new Push { DestinationRef = "0x" + memsize.ToString("X") };

                        new Call { DestinationRef = Helper.Heap_Label, IsLabel = true };
                        new Test { DestinationReg = Register.ECX, SourceRef = "0xFFFFFFFF" };
                        new Jmp { Condition = ConditionalJump.JNZ, DestinationRef = xOp.HandlerRef };

                        new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, SourceRef = "0x" + type.GetHashCode().ToString("X") };
                        new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = 4, SourceRef = "0x" + (0x1 | FieldIsClassType << 2).ToString("X") };
                        new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = 8, SourceRef = "0x" + memsize.ToString("X") };

                        new Push { DestinationReg = Register.EAX };
                        new Push { DestinationReg = Register.EAX };

                        for (int i = 0; i < count; i++)
                        {
                            if (Helper.GetTypeSize(parameters[i].ParameterType, Config.TargetPlatform) > 4)
                                throw new Exception("unsupported size");
                            new Push { DestinationReg = Register.ESP, DestinationDisplacement = (paramsize + 4), DestinationIndirect = true };
                        }

                        new Call { DestinationRef = functionInfo.FullName() };
                        new Test { DestinationReg = Register.ECX, SourceRef = "0xFFFFFFFF" };
                        new Jmp { Condition = ConditionalJump.JNZ, DestinationRef = xOp.HandlerRef };

                        new Pop { DestinationReg = Register.EAX };
                        new Add { DestinationReg = Register.ESP, SourceRef = "0x" + paramsize.ToString("X") };
                        new Push { DestinationReg = Register.EAX };

                        Optimizer.vStack.Push(new StackItem(type));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Method NoException Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomixilc.Attributes
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public class NoExceptionAttribute : Attribute
    {
        public NoExceptionAttribute()
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Destination-Size type set Instructions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Text;

namespace Atomixilc.Machine.x86
{
    public class OnlyDestination : Instruction
    {
        public string DestinationRef;
        public Register? DestinationReg;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;

        public byte Size;

        public OnlyDestination(string aMnemonic)
            :base(aMnemonic)
        {
            Size = 32;
        }

        public override string ToString()
        {
            if ((!string.IsNullOrEmpty(DestinationRef) && DestinationReg.HasValue) ||
                (string.IsNullOrEmpty(DestinationRef) && !DestinationReg.HasValue))
                throw new Exception(string.Format("{0} : Invalid Destination Parameters", Mnemonic));

            var SB = new StringBuilder();
            SB.Append(Mnemonic);
            SB.Append(' ');
            SB.Append(Helper.SizeToString(Size));
            SB.Append(' ');

            if (DestinationIndirect)
                SB.Append('[');

            if (DestinationReg.HasValue)
                SB.Append(DestinationReg.Value);
            else
                SB.Append(DestinationRef);

            if (DestinationDisplacement.HasValue && DestinationDisplacement != 0)
            {
                int offset = DestinationDisplacement.Value;
                if (offset < 0)
                    SB.Append(" - ");
                else
                    SB.Append(" + ");
                SB.Append(Math.Abs(offset));
            }

            if (DestinationIndirect)
                SB.Append(']');

            return SB.ToString();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Size type set Instructions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class OnlySize : Instruction
    {
        public byte? Offset;

        public OnlySize(string aMnemonic)
            :base(aMnemonic)
        {

        }

        public override string ToString()
        {
            if (!Offset.HasValue)
            {
                Offset = 0;
                Verbose.Warning("{0} : Offset not set", Mnemonic);
            }
            return string.Format("{0} 0x{1}", Mnemonic, Offset.Value.ToString("X"));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Branch Type MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpBranch : OpCodeType
    {
        internal readonly int Value;

        internal OpBranch(ILCode aCode, int aPosition, int aNextPosition, int aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          OpCodeType Abstract Type
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

namespace Atomixilc.IL
{
    internal abstract class OpCodeType : IComparable<OpCodeType>
    {
        internal readonly ILCode ILCode;
        internal readonly int Position;
        internal readonly int NextPosition;
        internal readonly ExceptionHandlingClause Handler;
        internal readonly bool NeedHandler;
        internal readonly int HandlerPosition;
        internal readonly string HandlerRef;

        internal bool IsLastIL;

        internal OpCodeType(ILCode aCode, int aPosition, int aNextPosition, ExceptionHandlingClause aEhc)
        {
            ILCode = aCode;
            Position = aPosition;
            NextPosition = aNextPosition;
            Handler = aEhc;

            NeedHandler = (aEhc != null)
                && ((aEhc.HandlerOffset == Position) || (((aEhc.Flags & ExceptionHandlingClauseOptions.Filter) != 0) && aEhc.FilterOffset == Position))
                && (aEhc.Flags == ExceptionHandlingClauseOptions.Clause);

            HandlerRef = ".Error";
            HandlerPosition = -1;
            if (aEhc != null && aEhc.HandlerOffset > Position)
            {
                HandlerPosition = aEhc.HandlerOffset;
                HandlerRef = Helper.GetLabel(aEhc.HandlerOffset);
            }
        }

        public int CompareTo(OpCodeType aOther)
        {
            return Position.CompareTo(aOther.Position);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Double Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpDouble : OpCodeType
    {
        internal readonly double Value;

        internal OpDouble(ILCode aCode, int aPosition, int aNextPosition, double aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Field Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpField : OpCodeType
    {
        internal readonly FieldInfo Value;

        internal OpField(ILCode aCode, int aPosition, int aNextPosition, FieldInfo aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Long Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpInt64 : OpCodeType
    {
        internal readonly long Value;

        internal OpInt64(ILCode aCode, int aPosition, int aNextPosition, long aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Int Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpInt : OpCodeType
    {
        internal readonly int Value;

        internal OpInt(ILCode aCode, int aPosition, int aNextPosition, int aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Method Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;
using System.Runtime.InteropServices;

namespace Atomixilc.IL.CodeType
{
    internal class OpMethod : OpCodeType
    {
        internal readonly MethodBase Value;
        internal readonly int MethodUID;
        internal readonly CallingConvention CallingConvention;

        internal OpMethod(ILCode aCode, int aPosition, int aNextPosition, MethodBase aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
            MethodUID = aValue.GetHashCode();
            CallingConvention = CallingConvention.StdCall;

            var attrib = Value.GetCustomAttribute<DllImportAttribute>();
            if (attrib != null)
                CallingConvention = attrib.CallingConvention;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          General type MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpNone : OpCodeType
    {
        internal OpNone(ILCode aCode, int aPosition, int aNextPosition, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {

        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}]", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sig Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpSig : OpCodeType
    {
        internal readonly int Value;

        internal OpSig(ILCode aCode, int aPosition, int aNextPosition, int aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Float Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpSingle : OpCodeType
    {
        internal readonly float Value;

        internal OpSingle(ILCode aCode, int aPosition, int aNextPosition, float aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          String Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpString : OpCodeType
    {
        internal readonly string Value;

        internal OpString(ILCode aCode, int aPosition, int aNextPosition, string aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value.Replace('\n', ' '));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Switch Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpSwitch : OpCodeType
    {
        internal readonly int[] Value;

        internal OpSwitch(ILCode aCode, int aPosition, int aNextPosition, int[] aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;

using Atomixilc.Machine;

namespace Atomixilc
{
    internal class Optimizer
    {
        internal Stack<StackItem> vStack;
        internal readonly Options Config;
        internal readonly Queue<int> ILQueue;
        internal readonly Dictionary<int, Stack<StackItem>> StackState;

        internal Optimizer(Options aConfig, Queue<int> aILQueue)
        {
            Config = aConfig;
            ILQueue = aILQueue;
            StackState = new Dictionary<int, Stack<StackItem>>();

            StackState.Add(0, new Stack<StackItem>());
        }

        internal void SaveStack(int aNextPosition)
        {
            if (aNextPosition < 0) return;

            if (vStack == null)
                throw new Exception("Invalid SaveStack call!");

            if (!StackState.ContainsKey(aNextPosition))
                StackState.Add(aNextPosition, vStack);
            else
            {
                var oldStack = StackState[aNextPosition];
                StackState[aNextPosition] = Merge(oldStack, vStack, aNextPosition);
            }
            ILQueue.Enqueue(aNextPosition);
        }

        internal void LoadStack(int aPosition)
        {
            vStack = null;
            StackState.TryGetValue(aPosition, out vStack);
            if (vStack == null)
                throw new Exception(string.Format("StackState not found! '{0}'", aPosition));
            vStack = new Stack<StackItem>(vStack.Reverse());
        }

        private Stack<StackItem> Merge(Stack<StackItem> itemA, Stack<StackItem> itemB, int aNextPosition)
        {
            var listA = itemA.ToList();
            var listB = itemB.ToList();

            if (listA.Count != listB.Count)
                throw new Exception(string.Format("Can't merge two different size stacks '{0}' => {1} {2}", aNextPosition, listA.Count, listB.Count));

            var aStack = new Stack<StackItem>();

            int n = listA.Count;
            for (int i = 0; i < n; i++)
            {
                if (listA[i].Equals(listB[i]))
                {
                    aStack.Push(listA[i]);
                    continue;
                }
                aStack.Push(new StackItem(listA[i].OperandType));
            }

            return aStack;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler Build Options
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.IO;
using System.Collections.Generic;

namespace Atomixilc
{
    internal class Options
    {
        bool mVerbose = false;
        bool mOptimize = false;
        string mOutputFile = string.Empty;
        List<string> mInputsDlls = null;
        Architecture mTargetPlatform = Architecture.None;

        public List<string> InputFiles
        {
            get
            {
                if (mInputsDlls == null)
                    mInputsDlls = new List<string>();

                return mInputsDlls;
            }
        }

        public string OutputFile
        {
            get { return mOutputFile; }
            set { mOutputFile = value; }
        }

        public Architecture TargetPlatform
        {
            get { return mTargetPlatform; }
            set { mTargetPlatform = value; }
        }

        public bool Verbose
        {
            get { return mVerbose; }
            set { mVerbose = value; }
        }

        public bool Optimize
        {
            get { return mOptimize; }
            set { mOptimize = value; }
        }

        public void Normalize()
        {
            if (InputFiles.Count == 0)
                throw new Exception("No Input File");

            if (string.IsNullOrEmpty(mOutputFile))
                mOutputFile = "App.asm";

            if (TargetPlatform == Architecture.None)
                throw new Exception("No target platform selected");

            if (!Path.IsPathRooted(mOutputFile))
                mOutputFile = Path.Combine(Environment.CurrentDirectory, mOutputFile);

            Directory.CreateDirectory(Path.GetDirectoryName(mOutputFile));
            for (int i = 0; i < InputFiles.Count; i++)
            {
                string InputFile = InputFiles[i];
                if (!Path.IsPathRooted(InputFile))
                    InputFile = Path.Combine(Environment.CurrentDirectory, InputFile);
                if (!File.Exists(InputFile))
                    throw new Exception(string.Format("Input file: '{0}' Does not exist", InputFile));
                InputFiles[i] = InputFile;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Token Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpToken : OpCodeType
    {
        internal readonly int Value;
        internal readonly Type ValueType;
        internal readonly FieldInfo ValueField;

        internal bool IsType
        {
            get
            {
                if (((Value & 0x02000000) != 0)
                    || ((Value & 0x01000000) != 0)
                    || ((Value & 0x1B000000) != 0))
                    return true;
                return false;
            }
        }

        internal bool IsField
        {
            get
            {
                return ((Value & 0x04000000) != 0);
            }
        }

        internal OpToken(ILCode aCode, int aPosition, int aNextPosition, int aValue, Module aModule, Type[] aTypeGenericArgs, Type[] aMethodGenericArgs, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
            if (IsField)
                ValueField = aModule.ResolveField(Value, aTypeGenericArgs, aMethodGenericArgs);
            if (IsType)
                ValueType = aModule.ResolveType(Value, aTypeGenericArgs, aMethodGenericArgs);
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), IsField ? ValueField.ToString() : ValueType.ToString());
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Type Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpType : OpCodeType
    {
        internal readonly Type Value;

        internal OpType(ILCode aCode, int aPosition, int aNextPosition, Type aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          ushort Value MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomixilc.IL.CodeType
{
    internal class OpVar : OpCodeType
    {
        internal readonly ushort Value;

        internal OpVar(ILCode aCode, int aPosition, int aNextPosition, ushort aValue, ExceptionHandlingClause aEhc)
            :base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("{0} [0x{1}-0x{2}] {3}", GetType().Name, Position.ToString("X4"), NextPosition.ToString("X4"), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Or Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Or : DestinationSourceSize
    {
        public Or()
            : base("or")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Out Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Out : DestinationSource
    {
        public Out()
            : base("out")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Method Plug Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomixilc.Attributes
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    public class PlugAttribute : Attribute
    {
        public readonly string TargetLabel;
        public readonly Architecture Platform;

        public PlugAttribute(string label, Architecture arch = Architecture.x86)
        {
            TargetLabel = label;
            Platform = arch;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Popad Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Popad : Instruction
    {
        public Popad()
            : base("popad")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Pop Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Pop : OnlyDestination
    {
        public Pop()
            :base("pop")
        {

        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace Atomixilc
{
    public class Program
    {
        public static void Main(string[] args)
        {
            try
            {
                Options CompilerOptions = null;

                ParseArguments(args, out CompilerOptions);
                CompilerOptions.Normalize();

                var xCompiler = new Compiler(CompilerOptions);
                try
                {
                    xCompiler.Execute();
                }
                catch (Exception e)
                {
                    Verbose.Error(e.ToString());
                }

                xCompiler.Flush();
            }
            catch (Exception e)
            {
                Verbose.Error(e.ToString());
            }
        }

        private static void ParseArguments(string[] args, out Options CompilerOptions)
        {
            Options Options = new Options();

            int index = 0;
            while(index < args.Length)
            {
                string flag = args[index];

                if (flag == "-v") Options.Verbose = true;
                else if (flag == "-optimize") Options.Optimize = true;
                else if (flag == "-cpu")
                {
                    index++;
                    if (index >= args.Length)
                        throw new Exception("Invalid platform parameter");

                    flag = args[index];
                    switch(flag)
                    {
                        case "x86": Options.TargetPlatform = Architecture.x86; break;
                        case "x64": Options.TargetPlatform = Architecture.x64; break;
                        case "ARM": Options.TargetPlatform = Architecture.ARM; break;
                        default: throw new Exception("Invalid target platform");
                    }
                }
                else if (flag == "-i")
                {
                    index++;
                    if (index >= args.Length)
                        throw new Exception("Invalid input files parameter");
                    Options.InputFiles.AddRange(args[index].Split(';'));
                }
                else if (flag == "-o")
                {
                    index++;
                    if (index >= args.Length)
                        throw new Exception("Invalid output files parameter");
                    Options.OutputFile = args[index];
                }

                index++;
            }

            CompilerOptions = Options;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Pushad Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Pushad : Instruction
    {
        public Pushad()
            : base("pushad")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Push Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Push : OnlyDestination
    {
        public Push()
            :base("push")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Architecture Registers
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine
{
    public enum Register
    {
        EAX, AX, AH, AL,
        EBX, BX, BH, BL,
        ECX, CX, CH, CL,
        EDX, DX, DH, DL,
        CS, DS, ES, FS,
        GS, SS, ESP, SP,
        EBP, BP, ESI, SI,
        EDI, DI, CR0, CR1,
        CR2, CR3, CR4, XMM0,
        XMM1, XMM2, XMM3, XMM4,
        XMM5, XMM6, XMM7, ST0,
        ST1, ST2, ST3, ST4,
        ST5, ST6, ST7, R0,
        R1, R2, R3, R4,
        R5, R6, R7, R8,
        R9, R10, R11, R12,
        R13, R14, R15
    };
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Rem MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Rem)]
    internal class Rem_il : MSIL
    {
        public Rem_il()
            : base(ILCode.Rem)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Rem(v=vs.110).aspx
         * Description : Divides two values and pushes the remainder onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var divisor = Optimizer.vStack.Pop();
            var dividend = Optimizer.vStack.Pop();

            var size = Math.Max(Helper.GetTypeSize(divisor.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(dividend.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack and the remainder of value1 div value2 computed.
             * The result is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (divisor.IsFloat || dividend.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!divisor.SystemStack || !dividend.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EBX };
                        new Pop { DestinationReg = Register.EAX };
                        new Cdq { };
                        new IDiv { DestinationReg = Register.EBX };
                        new Push { DestinationReg = Register.EDX };

                        Optimizer.vStack.Push(new StackItem(divisor.OperandType));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Rem_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Rem_Un)]
    internal class Rem_Un_il : MSIL
    {
        public Rem_Un_il()
            : base(ILCode.Rem_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Rem(v=vs.110).aspx
         * Description : Divides two unsigned values and pushes the remainder onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var divisor = Optimizer.vStack.Pop();
            var dividend = Optimizer.vStack.Pop();

            var size = Math.Max(Helper.GetTypeSize(divisor.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(dividend.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * value1 is pushed onto the stack.
             * value2 is pushed onto the stack.
             * value2 and value1 are popped from the stack and the remainder of value1 div value2 computed.
             * The result is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (divisor.IsFloat || dividend.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!divisor.SystemStack || !dividend.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EBX };
                        new Pop { DestinationReg = Register.EAX };
                        new Xor { DestinationReg = Register.EDX, SourceReg = Register.EDX };
                        new Div { DestinationReg = Register.EBX };
                        new Push { DestinationReg = Register.EDX };

                        Optimizer.vStack.Push(new StackItem(divisor.OperandType));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Ret Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Ret : OnlySize
    {
        public Ret()
            :base("ret")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Sar Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Sar : DestinationSourceSize
    {
        public Sar()
            : base("sar")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Seta Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Seta : Instruction
    {
        public Register DestinationReg;

        public Seta()
            : base("seta")
        {

        }

        public override string ToString()
        {
            return string.Format("{0} {1}", Mnemonic, DestinationReg);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Setb Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Setb : Instruction
    {
        public Register DestinationReg;

        public Setb()
            : base("setb")
        {

        }

        public override string ToString()
        {
            return string.Format("{0} {1}", Mnemonic, DestinationReg);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Sete Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Sete : Instruction
    {
        public Register DestinationReg;

        public Sete()
            : base("sete")
        {

        }

        public override string ToString()
        {
            return string.Format("{0} {1}", Mnemonic, DestinationReg);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Setg Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Setg : Instruction
    {
        public Register DestinationReg;

        public Setg()
            : base("setg")
        {

        }

        public override string ToString()
        {
            return string.Format("{0} {1}", Mnemonic, DestinationReg);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Setne Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Setne : Instruction
    {
        public Register DestinationReg;

        public Setne()
            : base("setne")
        {

        }

        public override string ToString()
        {
            return string.Format("{0} {1}", Mnemonic, DestinationReg);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Shl Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Shl : DestinationSourceSize
    {
        public Shl()
            : base("shl")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Cmp Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Shr : DestinationSourceSize
    {
        public Shr()
            : base("shr")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shr_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Shr_Un)]
    internal class Shr_Un_il : MSIL
    {
        public Shr_Un_il()
            : base(ILCode.Shr_Un)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Shr_Un(v=vs.110).aspx
         * Description : Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            var size = Math.Max(Helper.GetTypeSize(itemA.OperandType, Config.TargetPlatform),
                Helper.GetTypeSize(itemB.OperandType, Config.TargetPlatform));

            /* The stack transitional behavior, in sequential order, is:
             * A value is pushed onto the stack.
             * The amount of bits to be shifted is pushed onto the stack.
             * The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.
             * The result is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (itemA.IsFloat || itemB.IsFloat || size > 4)
                            throw new Exception(string.Format("UnImplemented '{0}'", msIL));

                        if (!itemA.SystemStack || !itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.ECX };
                        new Shr { DestinationReg = Register.ESP, SourceReg = Register.CL, DestinationIndirect = true };

                        Optimizer.vStack.Push(new StackItem(itemB.OperandType));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sizeof MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Sizeof)]
    internal class Sizeof_il : MSIL
    {
        public Sizeof_il()
            : base(ILCode.Sizeof)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Sizeof(v=vs.110).aspx
         * Description : Pushes the size, in bytes, of a supplied value type onto the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            var type = ((OpType)xOp).Value;

            /* The stack transitional behavior, in sequential order, is:
             * The size (in bytes) of the supplied value type (valType) is pushed onto the stack.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        new Push { DestinationRef = "0x" + Helper.GetTypeSize(type, Config.TargetPlatform).ToString("X") };
                        Optimizer.vStack.Push(new StackItem(typeof(uint)));
                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿using System;

namespace Atomixilc
{
    internal class StackItem
    {
        internal readonly bool SystemStack;
        internal readonly Type OperandType;

        internal StackItem(Type aType)
        {
            SystemStack = true;
            OperandType = aType;
        }

        internal bool IsFloat
        {
            get
            {
                return ((OperandType == typeof(float))
                    || (OperandType == typeof(decimal))
                    || (OperandType == typeof(double)));
            }
        }

        internal bool IsInteger
        {
            get
            {
                return ((OperandType == typeof(char))
                    || (OperandType == typeof(int))
                    || (OperandType == typeof(uint))
                    || (OperandType == typeof(long))
                    || (OperandType == typeof(ulong))
                    || (OperandType == typeof(byte))
                    || (OperandType == typeof(sbyte))
                    || (OperandType == typeof(short))
                    || (OperandType == typeof(ushort)));
            }
        }

        public bool Equals(StackItem aItem)
        {
            return (SystemStack == aItem.SystemStack) &&
                   (OperandType == aItem.OperandType);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Starg MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Starg)]
    internal class Starg_il : MSIL
    {
        public Starg_il()
            : base(ILCode.Starg)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Starg(v=vs.110).aspx
         * Description : Stores the value on top of the evaluation stack in the argument slot at a specified index.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var index = ((OpVar)xOp).Value;

            int EBPoffset = Ldarg_il.GetArgumentOffset(Config, method, index);

            Type ArgType = null;
            if (!method.IsStatic)
            {
                if (index == 0)
                {
                    ArgType = method.DeclaringType;
                    if (method.DeclaringType.IsValueType)
                        ArgType = ArgType.MakeByRefType();
                }
                else
                    ArgType = method.GetParameters()[index - 1].ParameterType;
            }
            else
                ArgType = method.GetParameters()[index].ParameterType;

            int ArgSize = Helper.GetTypeSize(ArgType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * The value currently on top of the stack is popped and placed in argument slot num.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (ArgSize > 4)
                            throw new Exception("Unsupported ArgSize");

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Mov
                        {
                            DestinationReg = Register.EBP,
                            DestinationIndirect = true,
                            DestinationDisplacement = EBPoffset,
                            SourceReg = Register.EAX
                        };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stelem MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stelem)]
    internal class Stelem_il : MSIL
    {
        public Stelem_il()
            : base(ILCode.Stelem)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stelem(v=vs.110).aspx
         * Description : Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 3)
                throw new Exception("Internal Compiler Error: vStack.Count < 3");

            var operand = ((OpType)xOp).Value;
            var size = Helper.GetTypeSize(operand, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * An object reference to an array, array, is pushed onto the stack.
             * An index value, index, to an element in array is pushed onto the stack.
             * A value of the type specified in the instruction is pushed onto the stack.
             * The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();
            var itemC = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (size > 4)
                            throw new Exception("LocalVariable size > 4 not supported");

                        if (!itemA.SystemStack || !itemB.SystemStack || !itemC.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Executex86(size);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }

        internal static void Executex86(int size)
        {
            new Pop { DestinationReg = Register.EDI };
            new Pop { DestinationReg = Register.EAX };

            switch (size)
            {
                case 1: break;
                case 2:
                    new Add { DestinationReg = Register.EAX, SourceReg = Register.EAX };
                    break;
                case 4:
                    new Shl { DestinationReg = Register.EAX, SourceRef = "0x2" };
                    break;
                default:
                    throw new Exception("size not supported");
            }

            new Pop { DestinationReg = Register.EDX };
            new Add { DestinationReg = Register.EAX, SourceReg = Register.EDX };
            new Mov { DestinationReg = Register.EDX, SourceReg = Register.EDI };

            switch (size)
            {
                case 0: break;
                case 1:
                    {
                        new Mov
                        {
                            DestinationReg = Register.EAX,
                            DestinationDisplacement = 0x10,
                            DestinationIndirect = true,
                            SourceReg = Register.DL,
                            Size = 8
                        };
                    }
                    break;
                case 2:
                    {
                        new Mov
                        {
                            DestinationReg = Register.EAX,
                            DestinationDisplacement = 0x10,
                            DestinationIndirect = true,
                            SourceReg = Register.DX,
                            Size = 16
                        };
                    }
                    break;
                case 4:
                    {
                        new Mov
                        {
                            DestinationReg = Register.EAX,
                            DestinationDisplacement = 0x10,
                            DestinationIndirect = true,
                            SourceReg = Register.EDX,
                            Size = 32
                        };
                    }
                    break;
                default:
                    throw new Exception("not implemented");
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stelem_I1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stelem_I1)]
    internal class Stelem_I1_il : MSIL
    {
        public Stelem_I1_il()
            : base(ILCode.Stelem_I1)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stelem_I1(v=vs.110).aspx
         * Description : Replaces the array element at a given index with the int8 value on the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 3)
                throw new Exception("Internal Compiler Error: vStack.Count < 3");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference to an array, array, is pushed onto the stack.
             * An index value, index, to an element in array is pushed onto the stack.
             * A value of the type specified in the instruction is pushed onto the stack.
             * The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();
            var itemC = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack || !itemB.SystemStack || !itemC.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stelem_il.Executex86(1);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stelem_I2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stelem_I2)]
    internal class Stelem_I2_il : MSIL
    {
        public Stelem_I2_il()
            : base(ILCode.Stelem_I2)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stelem_I2(v=vs.110).aspx
         * Description : Replaces the array element at a given index with the int16 value on the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 3)
                throw new Exception("Internal Compiler Error: vStack.Count < 3");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference to an array, array, is pushed onto the stack.
             * An index value, index, to an element in array is pushed onto the stack.
             * A value of the type specified in the instruction is pushed onto the stack.
             * The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();
            var itemC = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack || !itemB.SystemStack || !itemC.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stelem_il.Executex86(2);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stelem_I4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stelem_I4)]
    internal class Stelem_I4_il : MSIL
    {
        public Stelem_I4_il()
            : base(ILCode.Stelem_I4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stelem_I4(v=vs.110).aspx
         * Description : Replaces the array element at a given index with the int32 value on the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 3)
                throw new Exception("Internal Compiler Error: vStack.Count < 3");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference to an array, array, is pushed onto the stack.
             * An index value, index, to an element in array is pushed onto the stack.
             * A value of the type specified in the instruction is pushed onto the stack.
             * The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();
            var itemC = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack || !itemB.SystemStack || !itemC.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stelem_il.Executex86(4);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stelem_I MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stelem_I)]
    internal class Stelem_I_il : MSIL
    {
        public Stelem_I_il()
            : base(ILCode.Stelem_I)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stelem_I(v=vs.110).aspx
         * Description : Replaces the array element at a given index with the native int value on the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 3)
                throw new Exception("Internal Compiler Error: vStack.Count < 3");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference to an array, array, is pushed onto the stack.
             * An index value, index, to an element in array is pushed onto the stack.
             * A value of the type specified in the instruction is pushed onto the stack.
             * The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();
            var itemC = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack || !itemB.SystemStack || !itemC.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stelem_il.Executex86(4);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stelem_Ref MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stelem_Ref)]
    internal class Stelem_Ref_il : MSIL
    {
        public Stelem_Ref_il()
            : base(ILCode.Stelem_Ref)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stelem_Ref(v=vs.110).aspx
         * Description : Replaces the array element at a given index with the object ref value (type O) on the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 3)
                throw new Exception("Internal Compiler Error: vStack.Count < 3");

            /* The stack transitional behavior, in sequential order, is:
             * An object reference to an array, array, is pushed onto the stack.
             * An index value, index, to an element in array is pushed onto the stack.
             * A value of the type specified in the instruction is pushed onto the stack.
             * The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();
            var itemC = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemC.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stelem_il.Executex86(4);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stfld MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stfld)]
    internal class Stfld_il : MSIL
    {
        public Stfld_il()
            : base(ILCode.Stfld)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stfld(v=vs.110).aspx
         * Description : Replaces the value stored in the field of an object reference or pointer with a new value.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            var field = ((OpField)xOp).Value;
            var offset = Helper.GetFieldOffset(field.DeclaringType, field, Config.TargetPlatform);
            var size = Helper.GetTypeSize(field.FieldType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * An object reference or pointer is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the object reference/pointer are popped from the stack; the value of field in the object is replaced with the supplied value.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (size > 4)
                            throw new Exception("Field Size > 4 not supported");

                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Pop { DestinationReg = Register.EDX };

                        switch(size)
                        {
                            case 1:
                                {
                                    new Mov { DestinationReg = Register.EDX, DestinationDisplacement = offset, DestinationIndirect = true, SourceReg = Register.AL, Size = 8 };
                                }
                                break;
                            case 2:
                                {
                                    new Mov { DestinationReg = Register.EDX, DestinationDisplacement = offset, DestinationIndirect = true, SourceReg = Register.AX, Size = 16 };
                                }
                                break;
                            case 4:
                                {
                                    new Mov { DestinationReg = Register.EDX, DestinationDisplacement = offset, DestinationIndirect = true, SourceReg = Register.EAX };
                                }
                                break;
                            case 3:
                                {
                                    new Mov { DestinationReg = Register.EDX, DestinationDisplacement = offset, DestinationIndirect = true, SourceReg = Register.AX, Size = 16 };
                                    new Shr { DestinationReg = Register.EAX, SourceRef = "0x10" };
                                    new Mov { DestinationReg = Register.EDX, DestinationIndirect = true, DestinationDisplacement = 2 + offset, SourceReg = Register.AL, Size = 8 };
                                }
                                break;
                        }
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Sti Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Sti : Instruction
    {
        public Sti()
            : base("sti")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_I1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stind_I1)]
    internal class Stind_I1_il : MSIL
    {
        public Stind_I1_il()
            : base(ILCode.Stind_I1)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stind_I1(v=vs.110).aspx
         * Description : Stores a value of type int8 at a supplied address.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the address are popped from the stack; the value is stored at the address.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stind_I_il.Executex86(1);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_I2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stind_I2)]
    internal class Stind_I2_il : MSIL
    {
        public Stind_I2_il()
            : base(ILCode.Stind_I2)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stind_I2(v=vs.110).aspx
         * Description : Stores a value of type int16 at a supplied address.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the address are popped from the stack; the value is stored at the address.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stind_I_il.Executex86(2);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_I4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stind_I4)]
    internal class Stind_I4_il : MSIL
    {
        public Stind_I4_il()
            : base(ILCode.Stind_I4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stind_I4(v=vs.110).aspx
         * Description : Stores a value of type int32 at a supplied address.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the address are popped from the stack; the value is stored at the address.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stind_I_il.Executex86(4);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_I8 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stind_I8)]
    internal class Stind_I8_il : MSIL
    {
        public Stind_I8_il()
            : base(ILCode.Stind_I8)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stind_I8(v=vs.110).aspx
         * Description : Stores a value of type int64 at a supplied address.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the address are popped from the stack; the value is stored at the address.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stind_I_il.Executex86(8);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_I MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stind_I)]
    internal class Stind_I_il : MSIL
    {
        public Stind_I_il()
            : base(ILCode.Stind_I)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stind_I(v=vs.110).aspx
         * Description : Stores a value of type native int at a supplied address.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the address are popped from the stack; the value is stored at the address.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Executex86(4);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }

        internal static void Executex86(int size)
        {
            new Pop { DestinationReg = Register.EDX };
            new Pop { DestinationReg = Register.EAX };

            switch(size)
            {
                case 0: throw new Exception("Invalid call to Stind");
                case 1:
                    {
                        new Mov
                        {
                            DestinationReg = Register.EAX,
                            DestinationIndirect = true,
                            SourceReg = Register.DL,
                            Size = 8
                        };
                    }
                    break;
                case 2:
                    {
                        new Mov
                        {
                            DestinationReg = Register.EAX,
                            DestinationIndirect = true,
                            SourceReg = Register.DX,
                            Size = 16
                        };
                    }
                    break;
                case 4:
                    {
                        new Mov
                        {
                            DestinationReg = Register.EAX,
                            DestinationIndirect = true,
                            SourceReg = Register.EDX,
                            Size = 32
                        };
                    }
                    break;
                case 8:
                    {
                        // Low := EDX
                        // High := EAX
                        new Pop { DestinationReg = Register.EDI };
                        new Mov { DestinationReg = Register.EDI, DestinationIndirect = true, SourceReg = Register.EDX };
                        new Mov { DestinationReg = Register.EDI, DestinationDisplacement = 4, DestinationIndirect = true, SourceReg = Register.EAX };
                    }
                    break;
                default:
                    throw new Exception("not implemented");
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_R4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stind_R4)]
    internal class Stind_R4_il : MSIL
    {
        public Stind_R4_il()
            : base(ILCode.Stind_R4)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stind_R4(v=vs.110).aspx
         * Description : Stores a value of type float32 at a supplied address.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the address are popped from the stack; the value is stored at the address.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stind_I_il.Executex86(4);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_R8 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stind_R8)]
    internal class Stind_R8_il : MSIL
    {
        public Stind_R8_il()
            : base(ILCode.Stind_R8)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stind_R8(v=vs.110).aspx
         * Description : Stores a value of type float64 at a supplied address.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the address are popped from the stack; the value is stored at the address.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stind_I_il.Executex86(8);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_Ref MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stind_Ref)]
    internal class Stind_Ref_il : MSIL
    {
        public Stind_Ref_il()
            : base(ILCode.Stind_Ref)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stind_Ref(v=vs.110).aspx
         * Description : Stores a object reference value at a supplied address.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 2)
                throw new Exception("Internal Compiler Error: vStack.Count < 2");

            /* The stack transitional behavior, in sequential order, is:
             * An address is pushed onto the stack.
             * A value is pushed onto the stack.
             * The value and the address are popped from the stack; the value is stored at the address.
             */

            var itemA = Optimizer.vStack.Pop();
            var itemB = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!itemA.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        if (!itemB.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        Stind_I_il.Executex86(4);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stloc MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stloc)]
    internal class Stloc_il : MSIL
    {
        public Stloc_il()
            : base(ILCode.Stloc)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stloc(v=vs.110).aspx
         * Description : Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var index = ((OpVar)xOp).Value;

            var body = method.GetMethodBody();
            var EBPoffset = Helper.GetVariableOffset(body, index, Config.TargetPlatform);

            var varType = body.LocalVariables[index].LocalType;
            var size = Helper.GetTypeSize(varType, Config.TargetPlatform);

            /* The stack transitional behavior, in sequential order, is:
             * A value is popped off of the stack and placed in local variable index.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (size > 4)
                            throw new Exception("LocalVariable size > 4 not supported");

                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        new Mov
                        {
                            DestinationReg = Register.EBP,
                            DestinationIndirect = true,
                            DestinationDisplacement = -EBPoffset,
                            SourceReg = Register.EAX
                        };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          System.String Plugs
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.Lib.Plugs
{
    internal unsafe static class StringImpl
    {
        [NoException]
        [Plug("System_Void_System_String__ctor_System_Char___")]
        internal static void String(byte* aStr, char[] aArray)
        {
            String(aStr, aArray, 0, aArray.Length);
        }

        [NoException]
        [Plug("System_Void_System_String__ctor_System_Char__")]
        internal static void String(byte* aStr, char* aArray)
        {
            var aChar = (char*)(aStr + 0x10);

            int len = 0;
            while (*aArray != '\0')
            {
                *(aChar++) = *(aArray++);
                len++;
            }

            *((int*)(aStr + 0xC)) = len;
        }

        [NoException]
        [Plug("System_Void_System_String__ctor_System_SByte__")]
        internal static void String(byte* aStr, sbyte* aArray)
        {
            var aChar = (char*)(aStr + 0x10);

            int len = 0;
            while (*aArray != 0)
            {
                *(aChar++) = (char)*(aArray++);
                len++;
            }

            *((int*)(aStr + 0xC)) = len;
        }

        [NoException]
        [Plug("System_Void_System_String__ctor_System_SByte___System_Int32__System_Int32_")]
        internal static void String(byte* aStr, sbyte* aArray, int start, int length)
        {
            var aChar = (char*)(aStr + 0x10);
            aArray += start;

            int len = 0;
            while (*aArray != 0)
            {
                *(aChar++) = (char)*(aArray++);
                len++;

                if (len == length) break;
            }

            *((int*)(aStr + 0xC)) = len;
        }

        [NoException]
        [Assembly(true)]
        [Plug("System_Void_System_String__ctor_System_Char____System_Int32__System_Int32_")]
        internal static void String(byte* aStr, char[] aArray, int aStart, int aLength)
        {
            new Mov { DestinationReg = Register.ECX, SourceReg = Register.EBP, SourceDisplacement = 8, SourceIndirect = true };
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 12, SourceIndirect = true };
            new Add { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 12, SourceIndirect = true };
            new Add { DestinationReg = Register.EAX, SourceRef = "0x10" };

            new Mov { DestinationReg = Register.ESI, SourceReg = Register.EBP, SourceDisplacement = 16, SourceIndirect = true };
            new Add { DestinationReg = Register.ESI, SourceReg = Register.EAX };

            new Mov { DestinationReg = Register.EDI, SourceReg = Register.EBP, SourceDisplacement = 20, SourceIndirect = true };
            new Mov { DestinationReg = Register.EDI, DestinationDisplacement = 0xC, DestinationIndirect = true, SourceReg = Register.ECX };
            new Add { DestinationReg = Register.EDI, SourceRef = "0x10" };
            new Literal("rep movsw");
        }
        
        [NoException]
        [Plug("System_Char_System_String_get_Chars_System_Int32_")]
        internal static char GetChar(byte* aStr, int index)
        {
            return *((char*)(aStr + 0x10 + (index<<1)));
        }

        [NoException]
        [Plug("System_Int32_System_String_get_Length__")]
        internal static int GetLength(byte* aStr)
        {
            return *((int*)(aStr + 0xC));
        }

        [NoException]
        [Label("GetLength.System.Char*")]
        internal static int GetLength(char* aArray)
        {
            int len = 0;
            while (*(aArray++) != '\0')
                len++;
            return len;
        }

        [NoException]
        [Label("GetLength.System.SByte*")]
        internal static int GetLength(sbyte* aArray)
        {
            int len = 0;
            while (*(aArray++) != 0)
                len++;
            return len;
        }

        [NoException]
        [Plug("System_Char___System_String_ToCharArray__")]
        internal static char[] ToCharArray(string aStr)
        {
            int len = aStr.Length;
            var aArray = new char[len];
            Memory.FastCopy(aArray.GetDataOffset(), aStr.GetDataOffset(), (uint)(len << 1));

            return aArray;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stsfld MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;
using System.Linq;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;
using Atomixilc.IL.CodeType;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Stsfld)]
    internal class Stsfld_il : MSIL
    {
        public Stsfld_il()
            : base(ILCode.Stsfld)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Stsfld(v=vs.110).aspx
         * Description : Replaces the value of a static field with a value from the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var field = ((OpField)xOp).Value;
            var fieldName = field.FullName();
            var size = Helper.GetTypeSize(field.FieldType, Config.TargetPlatform);

            string cctor_addref = null;

            var cctor = (field.DeclaringType.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public) ?? new ConstructorInfo[0]).SingleOrDefault();
            if (cctor != null)
                cctor_addref = cctor.FullName();

            /* The stack transitional behavior, in sequential order, is:
             * A value is pushed onto the stack.
             * A value is popped from the stack and stored in field.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        for (int i = 0; i < (size / 4); i++)
                        {
                            new Pop { DestinationReg = Register.EAX };
                            new Mov { DestinationRef = fieldName, DestinationIndirect = true, DestinationDisplacement = (i * 4), SourceReg = Register.EAX };
                        }

                        int offset = size / 4;
                        switch (size % 4)
                        {
                            case 0: break;
                            case 1:
                                {
                                    new Pop { DestinationReg = Register.EAX };
                                    new Mov { DestinationRef = fieldName, DestinationIndirect = true, DestinationDisplacement = offset * 4, SourceReg = Register.AL, Size = 8 };
                                }
                                break;
                            case 2:
                                {
                                    new Pop { DestinationReg = Register.EAX };
                                    new Mov { DestinationRef = fieldName, DestinationIndirect = true, DestinationDisplacement = offset * 4, SourceReg = Register.AX, Size = 16 };
                                }
                                break;
                            default:
                                throw new Exception("Unsupported Size");
                        }
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }

            Optimizer.SaveStack(xOp.NextPosition);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Sub Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Sub : DestinationSourceSize
    {
        public Sub()
            : base("sub")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Switch MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.IL.CodeType;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Switch)]
    internal class Switch_il : MSIL
    {
        public Switch_il()
            : base(ILCode.Switch)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Switch(v=vs.110).aspx
         * Description : Implements a jump table.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var branches = ((OpSwitch)xOp).Value;

            /* The stack transitional behavior, in sequential order, is:
             * A value is pushed onto the stack.
             * The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than N.
             */

            var item = Optimizer.vStack.Pop();

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.EAX };
                        for (int i = 0; i < branches.Length; i++)
                        {
                            new Cmp { DestinationReg = Register.EAX, SourceRef = "0x" + i.ToString("X") };
                            new Jmp { Condition = ConditionalJump.JE, DestinationRef = Helper.GetLabel(branches[i]) };
                            Optimizer.SaveStack(branches[i]);
                        }

                        Optimizer.SaveStack(xOp.NextPosition);
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Test Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Test : DestinationSourceSize
    {
        public Test()
            : base("test")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Throw MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomixilc.IL
{
    [ILImpl(ILCode.Throw)]
    internal class Throw_il : MSIL
    {
        public Throw_il()
            : base(ILCode.Throw)
        {

        }

        /*
         * URL : https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.Throw(v=vs.110).aspx
         * Description : Throws the exception object currently on the evaluation stack.
         */
        internal override void Execute(Options Config, OpCodeType xOp, MethodBase method, Optimizer Optimizer)
        {
            if (Optimizer.vStack.Count < 1)
                throw new Exception("Internal Compiler Error: vStack.Count < 1");

            var item = Optimizer.vStack.Pop();

            /* The stack transitional behavior, in sequential order, is:
             * An object reference (to an exception) is pushed onto the stack.
             * The object reference is popped from the stack and the exception thrown.
             */

            switch (Config.TargetPlatform)
            {
                case Architecture.x86:
                    {
                        if (!item.SystemStack)
                            throw new Exception(string.Format("UnImplemented-RegisterType '{0}'", msIL));

                        new Pop { DestinationReg = Register.ECX };
                        new Jmp { DestinationRef = xOp.HandlerRef };
                    }
                    break;
                default:
                    throw new Exception(string.Format("Unsupported target platform '{0}' for MSIL '{1}'", Config.TargetPlatform, msIL));
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace Atomixilc
{
    internal static class Verbose
    {
        internal static void Warning(string message, params object[] args)
        {
            var oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine(string.Format(message, args));
            Console.ForegroundColor = oldColor;
        }

        public static int ErrorCounter { get; private set; }
        internal static void Error(string message, params object[] args)
        {
            ErrorCounter++;
            var oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(string.Format(message, args));
            Console.ForegroundColor = oldColor;
        }

        internal static void Message(string message, params object[] args)
        {
            var oldColor = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine(string.Format(message, args));
            Console.ForegroundColor = oldColor;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Virtual Table Get Entry Implementation
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Attributes;

namespace Atomixilc.Lib
{
    internal class VTable
    {
        [Label(Helper.VTable_Label)]
        internal static unsafe int GetEntry(int* FlushTable, int MethodUID, int TypeID)
        {
            while(*FlushTable != 0)
            {
                var xUID = *(FlushTable + 1);
                if (xUID == MethodUID)
                {
                    FlushTable += 2;
                    while(*FlushTable != 0)
                    {
                        var xTypeID = *(FlushTable + 1);
                        if (xTypeID == TypeID)
                            return *FlushTable;
                        FlushTable += 2;
                    }

                    throw new Exception("virtual method not found");
                }

                FlushTable += *FlushTable;
            }

            throw new Exception("virtual method not found");
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          x86 Xor Instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomixilc.Machine.x86
{
    public class Xor : DestinationSourceSize
    {
        public Xor()
            : base("xor")
        {

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Add MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Add)]
    public class ILAdd : MSIL
    {
        public ILAdd(Compiler Cmp)
            : base("add", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Tell virtual stack that we want to pop
            var xItem = Core.vStack.Pop();
            //Get Size of pop content and align it to 4, i mean multiple of 4
            var xSize = xItem.Size;

            /*
                    The stack transitional behavior, in sequential order, is:
                    value1 is pushed onto the stack.
                    value2 is pushed onto the stack.
                    value2 and value1 are popped from the stack; value1 is added to value2.
                    The result is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //So, we have again both floating point in stack
                                //http://rayseyfarth.com/asm/pdf/ch11-floating-point.pdf#6

                                //***What we are going to do is***
                                //1) Copy ESP value 2 to XMM0 register
                                //2) Add ESP by 4 to move stack pointer
                                //3) Copy ESP value 1 to XMM1
                                //4) Add both values are take result to XMM0
                                //5) Copy the value to memory at ESP --> Just like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });
                                Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });
                                Core.AssemblerCode.Add(new Addss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, SourceReg = Registers.XMM0, DestinationIndirect = true });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop the value 2 from the stack into EAX
                                //2) Add the content of EAX to the 32bit memory at ESP
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceReg = Registers.EAX, DestinationIndirect = true });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //I got the idea of this implementation from GCC, i build simple code and decompile it with gcc
                                // and look at its assembly code
                                //      a+=b;
                                //18:   dd 45 f8                fld    QWORD PTR [ebp-0x8]
                                //1b:   dc 45 f0                fadd   QWORD PTR [ebp-0x10]
                                //1e:   dd 5d f8                fstp   QWORD PTR [ebp-0x8]

                                //***What we are going to do is***
                                //1) Load the 64 bit memory at ESP into FLD stack
                                //2) Add ESP by 0x8 --> To shift pointer
                                //3) Use Float Add to add value in float stack to 64 bit memory at ESP, And store result in float stack
                                //4) Just like Pop, we pop the iteam from float stack and put it into 64 bit memory at ESP
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, Size = 64, DestinationIndirect = true });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fadd { DestinationReg = Registers.ESP, Size = 64, DestinationIndirect = true });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, Size = 64, DestinationIndirect = true });
                            }
                            else
                            {
                                //Two Qword parameters are in stack, so first pop it into edx:eax and add it to [ESP + 4] : [ESP] with carry
                                //http://stackoverflow.com/questions/7865511/qword-storing-implementing-using-32-bit-regs

                                //***What we are going to do is***
                                //1) Pop the low part of value 2 into EAX
                                //2) Pop the high part of value 2 into EDX
                                //3) Add the EAX to 32 bit Memory at ESP --> Low part of value 1
                                //4) Add the EDX to 32 bit Memory at ESP + 4 with carry --> High part of value 1
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //low part
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX }); //High part
                                Core.AssemblerCode.Add(
                                    new Assembler.x86.Add
                                    {
                                        DestinationReg = Registers.ESP,
                                        SourceReg = Registers.EAX,
                                        DestinationIndirect = true
                                    });

                                Core.AssemblerCode.Add(
                                    new AddWithCarry
                                    {
                                        DestinationReg = Registers.ESP,
                                        SourceReg = Registers.EDX,
                                        DestinationIndirect = true,
                                        DestinationDisplacement = 4
                                    });
                            }
                        }
                        else
                            //Add of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Add: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          And MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.And)]
    public class ILAnd : MSIL
    {
        public ILAnd(Compiler Cmp)
            : base("and", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We pop first content and peek second because we just want what's the maximum size of content
            var xSize1 = Core.vStack.Pop().Size;
            var xSize2 = Core.vStack.Peek().Size;
            var xSize = Math.Max(xSize1, xSize2);

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value1 and value2 are popped from the stack; the bitwise AND of the two values is computed.
                The result is pushed onto the stack.
            */

            //If stack size of operands are not same, than we can't do And operation
            if (xSize1.Align() != xSize2.Align())
                throw new Exception("@And: Size of operands are different");

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Perform And Operation on 32 bit memory at ESP to EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Low part of value 2 into EAX
                            //2) Pop High part of value 1 into EDX
                            //3) Perform And operation of EAX and 32 bit memory at ESP
                            //4) Perform And operation of EAX and 32 bit memory at ESP + 0x4
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low part
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high part

                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EDX, DestinationDisplacement = 0x4 });
                        }
                        else
                            //Case of And operation more than 8 is not usually called
                            throw new Exception("@And: bitwise and operation more than size 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Add MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Add)]
    public class ILAdd : MSIL
    {
        public ILAdd(Compiler Cmp)
            : base("add", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Tell virtual stack that we want to pop
            var xItem = Core.vStack.Pop();
            //Get Size of pop content and align it to 4, i mean multiple of 4
            var xSize = xItem.Size;

            /*
                    The stack transitional behavior, in sequential order, is:
                    value1 is pushed onto the stack.
                    value2 is pushed onto the stack.
                    value2 and value1 are popped from the stack; value1 is added to value2.
                    The result is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //So, we have again both floating point in stack
                                //http://rayseyfarth.com/asm/pdf/ch11-floating-point.pdf#6

                                //***What we are going to do is***
                                //1) Copy ESP value 2 to XMM0 register
                                //2) Add ESP by 4 to move stack pointer
                                //3) Copy ESP value 1 to XMM1
                                //4) Add both values are take result to XMM0
                                //5) Copy the value to memory at ESP --> Just like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });
                                Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });
                                Core.AssemblerCode.Add(new Addss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, SourceReg = Registers.XMM0, DestinationIndirect = true });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop the value 2 from the stack into EAX
                                //2) Add the content of EAX to the 32bit memory at ESP
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceReg = Registers.EAX, DestinationIndirect = true });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //I got the idea of this implementation from GCC, i build simple code and decompile it with gcc
                                // and look at its assembly code
                                //      a+=b;
                                //18:   dd 45 f8                fld    QWORD PTR [ebp-0x8]
                                //1b:   dc 45 f0                fadd   QWORD PTR [ebp-0x10]
                                //1e:   dd 5d f8                fstp   QWORD PTR [ebp-0x8]

                                //***What we are going to do is***
                                //1) Load the 64 bit memory at ESP into FLD stack
                                //2) Add ESP by 0x8 --> To shift pointer
                                //3) Use Float Add to add value in float stack to 64 bit memory at ESP, And store result in float stack
                                //4) Just like Pop, we pop the iteam from float stack and put it into 64 bit memory at ESP
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, Size = 64, DestinationIndirect = true });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fadd { DestinationReg = Registers.ESP, Size = 64, DestinationIndirect = true });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, Size = 64, DestinationIndirect = true });
                            }
                            else
                            {
                                //Two Qword parameters are in stack, so first pop it into edx:eax and add it to [ESP + 4] : [ESP] with carry
                                //http://stackoverflow.com/questions/7865511/qword-storing-implementing-using-32-bit-regs

                                //***What we are going to do is***
                                //1) Pop the low part of value 2 into EAX
                                //2) Pop the high part of value 2 into EDX
                                //3) Add the EAX to 32 bit Memory at ESP --> Low part of value 1
                                //4) Add the EDX to 32 bit Memory at ESP + 4 with carry --> High part of value 1
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //low part
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX }); //High part
                                Core.AssemblerCode.Add(
                                    new Assembler.x86.Add
                                    {
                                        DestinationReg = Registers.ESP,
                                        SourceReg = Registers.EAX,
                                        DestinationIndirect = true
                                    });

                                Core.AssemblerCode.Add(
                                    new AddWithCarry
                                    {
                                        DestinationReg = Registers.ESP,
                                        SourceReg = Registers.EDX,
                                        DestinationIndirect = true,
                                        DestinationDisplacement = 4
                                    });
                            }
                        }
                        else
                            //Add of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Add: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          And MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.And)]
    public class ILAnd : MSIL
    {
        public ILAnd(Compiler Cmp)
            : base("and", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We pop first content and peek second because we just want what's the maximum size of content
            var xSize1 = Core.vStack.Pop().Size;
            var xSize2 = Core.vStack.Peek().Size;
            var xSize = Math.Max(xSize1, xSize2);

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value1 and value2 are popped from the stack; the bitwise AND of the two values is computed.
                The result is pushed onto the stack.
            */

            //If stack size of operands are not same, than we can't do And operation
            if (xSize1.Align() != xSize2.Align())
                throw new Exception("@And: Size of operands are different");

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Perform And Operation on 32 bit memory at ESP to EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Low part of value 2 into EAX
                            //2) Pop High part of value 1 into EDX
                            //3) Perform And operation of EAX and 32 bit memory at ESP
                            //4) Perform And operation of EAX and 32 bit memory at ESP + 0x4
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low part
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high part

                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EDX, DestinationDisplacement = 0x4 });
                        }
                        else
                            //Case of And operation more than 8 is not usually called
                            throw new Exception("@And: bitwise and operation more than size 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Beq MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Beq)]
    public class Beq : MSIL
    {
        public Beq(Compiler Cmp)
            : base("beq", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._beq_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();
            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is equal to value2, the branch operation is performed. --> value1 = value2
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 into EAX
                            //2) Pop Value 1 into EBX
                            //3) Xor EAX and EBX, Jump to Branch when the result is zero
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EAX, SourceReg = Registers.EBX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 low into EAX and high into EBX
                            //2) Pop Value 1 low into ECX and high into EDX
                            //3) Xor low values and check if zero than continue else if not than jump to Not Equal
                            //4) Xor high values and check if zero than jump to Branch else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//high

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high

                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNZ, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EBX, SourceReg = Registers.EDX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Beq: Branch operation beq for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bge MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bge)]
    public class Bge : MSIL
    {
        public Bge(Compiler Cmp)
            : base("bge", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bge_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();
            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is greater than or equal to value2, the branch operation is performed. --> value1 ≥ value2
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 into EAX
                            //2) Pop Value 1 into EBX
                            //3) Compare EBX and EAX and jump if greator than equals to
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });//value1 - value2
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JGE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//high

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JGE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bge: Branch operation bge for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bg2_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bge_Un)]
    public class Bge_Un : MSIL
    {
        public Bge_Un(Compiler Cmp)
            : base("bge_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bge_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();
            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is greater than or equal to value2, the branch operation is performed. --> value1 ≥ value2
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 into EAX
                            //2) Pop Value 1 into EBX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });//value1 - value2
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JAE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//high

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JAE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bge_Un: Branch operation bge_un for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bgt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bgt)]
    public class Bgt : MSIL
    {
        public Bgt(Compiler Cmp)
            : base("bgt", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bgt_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is greater than value2, the branch operation is performed. --> value1 > value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if greator than
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if greator than true else if less than jump false
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bgt: Branch operation bgt for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bgt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bgt_Un)]
    public class Bgt_Un : MSIL
    {
        public Bgt_Un(Compiler Cmp)
            : base("bgt_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bgt_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is greater than value2, the branch operation is performed. --> value1 > value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if greator than
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if greator than true else if less than jump false
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bgt: Branch operation bgt for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ble MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Ble)]
    public class Ble : MSIL
    {
        public Ble(Compiler Cmp)
            : base("ble", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._ble_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is less than or equals to value2, the branch operation is performed. --> value1 ≤ value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if less than or equals to
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JLE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JLE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Ble: Branch operation ble for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ble_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Ble_Un)]
    public class Ble_Un : MSIL
    {
        public Ble_Un(Compiler Cmp)
            : base("ble_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._ble_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is less than or equals to value2, the branch operation is performed. --> value1 ≤ value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if less than or equals to
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JBE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JBE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Ble_Un: Branch operation ble_un for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Blt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Blt)]
    public class Blt : MSIL
    {
        public Blt(Compiler Cmp)
            : base("blt", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._blt_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is less than value2, the branch operation is performed. --> value1 < value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if less than
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Ble: Branch operation ble for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Blt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Blt_Un)]
    public class Blt_Un : MSIL
    {
        public Blt_Un(Compiler Cmp)
            : base("blt_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._blt_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is less than value2, the branch operation is performed. --> value1 < value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if less than or equals to
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Ble: Branch operation ble for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bne_un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bne_Un)]
    public class Bne_Un : MSIL
    {
        public Bne_Un(Compiler Cmp)
            : base("bne_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bne_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();
            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is not equal to value2, the branch operation is performed. --> value1 ≠ value2
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 into EAX
                            //2) Pop Value 1 into EBX
                            //3) Compare EAX and EBX, Jump to Branch when the result is not zero
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.EBX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 low into EAX and high into EBX
                            //2) Pop Value 1 low into ECX and high into EDX
                            //3) Compare low values and check if zero than continue else if not than jump to Not Equal
                            //4) Compare high values and check if zero than jump to Branch else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//high

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EDX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bne_Un: Branch operation bne_un for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Br MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Br)]
    public class Br : MSIL
    {
        public Br(Compiler Cmp)
            : base("br", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            //The target branch
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);

            //Just make the jump to given target branch
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Just make a jump as simple as that =)
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xTrueLabel });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Brfalse MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Brfalse)]
    public class Brfalse : MSIL
    {
        public Brfalse(Compiler Cmp)
            : base("brfalse", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            //The brach label
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            //Just make a pop because we want only size of it
            var xSize = Core.vStack.Pop().Size;

            /*
                value is pushed onto the stack by a previous operation.
                value is popped from the stack;
                if value is false, branch to target.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    //***What we are going to do is***
                                    //1) Pop the content into EAX
                                    //2) Compare the content with 0x0 --> False
                                    //3) If they are equal than jump to branch
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xTrueLabel });
                                }
                                break;
                            case 8:
                                {
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });

                                    string xFalseLabel = xTrueLabel + ".false";
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xFalseLabel });
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xTrueLabel });
                                    Core.AssemblerCode.Add(new Label(xFalseLabel));
                                }
                                break;
                            default:
                                //Size > 4 is never called don't know why
                                throw new Exception("@Brfalse: Unexpected size called := " + xSize);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Brtrue MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Brtrue)]
    public class Brtrue : MSIL
    {
        public Brtrue(Compiler Cmp)
            : base("brtrue", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            //The brach label
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            //Just make a pop because we want only size of it
            var xSize = Core.vStack.Pop().Size;

            /*
                value is pushed onto the stack by a previous operation.
                value is popped from the stack;
                if value is true, branch to target.
            */

            //Branch to target
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    //***What we are going to do is***
                                    //1) Pop the content into EAX
                                    //2) Compare the content with 0x0 --> False
                                    //3) If they are equal than jump to branch
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                                }
                                break;
                            case 8:
                                {
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });

                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                                }
                                break;
                            default:
                                //Size > 4 is never called don't know why
                                throw new Exception("@Brtrue: Unexpected size called := " + xSize);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Call MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Call)]
    public class ILCall : MSIL
    {
        public ILCall(Compiler Cmp)
            : base("call", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //The Target method base which we have to call
            var xTarget = ((OpMethod)instr).Value;
            //Try to get if there is any method info of target method
            var xTargetInfo = xTarget as MethodInfo;
            var xNormalAddress = xTarget.FullName(); //Target method full name
            var xParams = xTarget.GetParameters();
            var xNextAddress = ILHelper.GetLabel(aMethod, instr.NextPosition);//Next address after call IL instruction

            /* Now to find error handling label
               This is because if the called method throwed any exception than to handle that we need something.
             */
            var xEndException = aMethod.FullName() + ".Error";//Current method exception label
            //Check if there is any try catch field after this call instruction
            if (instr.Ehc != null && instr.Ehc.HandlerOffset > instr.Position)
            {
                //If yes take that label as excpetion handling label
                xEndException = ILHelper.GetLabel(aMethod, instr.Ehc.HandlerOffset);
            }

            //If method have any method info than check what is its return size
            //And also align it to stack pointer
            var xReturnSize = 0;
            if (xTargetInfo != null)
                xReturnSize = xTargetInfo.ReturnType.SizeOf().Align();

            /* Size to reserve can be viewed as the segment of stack that is require to call a function
             * where function can put it all its parameters/local variables
             * And finally the return size */
            #region Size2Reserve
            int SizeToReserve = xReturnSize;
            if (SizeToReserve > 0)
            {
                foreach (var xp in xTarget.GetParameters())
                {
                    SizeToReserve -= xp.ParameterType.SizeOf().Align();
                    Core.vStack.Pop();
                }
                if (!xTargetInfo.IsStatic)
                {
                    SizeToReserve -= (ILCompiler.CPUArchitecture == CompilerExt.CPUArch.x86 ? 4 : 8);
                    Core.vStack.Pop();
                }
            }
            #endregion

            /*
                Method arguments arg1 through argN are pushed onto the stack.
                Method arguments arg1 through argN are popped from the stack;
                the method call is performed with these arguments and control is transferred,
                to the method referred to by the method descriptor. When complete,
                a return value is generated by the callee method and sent to the caller.
                The return value is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Make Space for extra requirements of function
                        if (SizeToReserve > 0)
                            Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + SizeToReserve.ToString("X") });

                        Core.AssemblerCode.Add(new Call(xNormalAddress));

                        if (aMethod != null)
                        {
                            //Check if ECX register has no error value that is 0x1
                            //If yes than jump to next instruction
                            Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xNextAddress });

                            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x" + xReturnSize.ToString("x") });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xEndException });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            ///If there is not method info than why push anything to virtual stack
            if (xTargetInfo == null || xReturnSize == 0)
                return;

            Core.vStack.Push(xReturnSize, xTargetInfo.ReturnType);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          CallVirt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Callvirt)]
    public class ILCallvirt : MSIL
    {
        public ILCallvirt(Compiler Cmp)
            : base("callvirt", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOp = (OpMethod)instr;
            //The Target method base which we have to call
            var xTarget = xOp.Value;
            //Try to get if there is any method info of target method
            var xTargetInfo = xTarget as MethodInfo;
            var xNormalAddress = string.Empty;

            if (xTarget.IsStatic || !xTarget.IsVirtual || xTarget.IsFinal)
                xNormalAddress = xTarget.FullName();//Target method full name

            var xParams = xTarget.GetParameters();
            var xNextAddress = ILHelper.GetLabel(aMethod, instr.NextPosition);//Next address after call IL instruction

            /* Now to find error handling label
               This is because if the called method throwed any exception than to handle that we need something.
             */
            var xEndException = aMethod.FullName() + ".Error";//Current method exception label
            //Check if there is any try catch field after this call instruction
            if (instr.Ehc != null && instr.Ehc.HandlerOffset > instr.Position)
            {
                //If yes take that label as excpetion handling label
                xEndException = ILHelper.GetLabel(aMethod, instr.Ehc.HandlerOffset);
            }

            //If method have any method info than check what is its return size
            //And also align it to stack pointer
            var xReturnSize = 0;
            if (xTargetInfo != null)
                xReturnSize = xTargetInfo.ReturnType.SizeOf().Align();

            /* Size to reserve can be viewed as the segment of stack that is require to call a function
             * where function can put it all its parameters/local variables
             * And finally the return size */
            #region Size2Reserve
            int SizeToReserve = xReturnSize;
            if (SizeToReserve > 0)
            {
                foreach (var xp in xTarget.GetParameters())
                {
                    SizeToReserve -= xp.ParameterType.SizeOf().Align();
                }
                if (!xTargetInfo.IsStatic)
                {
                    SizeToReserve -= (ILCompiler.CPUArchitecture == CompilerExt.CPUArch.x86 ? 4 : 8);
                }
            }
            #endregion

            int xThisOffset = 0;
            var xParameters = xTarget.GetParameters();
            foreach (var xItem in xParameters)
            {
                xThisOffset += xItem.ParameterType.SizeOf().Align();
                Core.vStack.Pop();
            }
            if (!xTarget.IsStatic)
            {
                Core.vStack.Pop();
            }

            /*
                Method arguments arg1 through argN are pushed onto the stack.
                Method arguments arg1 through argN are popped from the stack;
                the method call is performed with these arguments and control is transferred,
                to the method referred to by the method descriptor. When complete,
                a return value is generated by the callee method and sent to the caller.
                The return value is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (!String.IsNullOrEmpty(xNormalAddress))
                        {
                            //Make Space for extra requirements of function
                            if (SizeToReserve > 0)
                                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + SizeToReserve.ToString("X") });

                            Core.AssemblerCode.Add(new Call(xNormalAddress));
                        }
                        else
                        {
                            if (xOp.MethodUID == 0)
                            {
                                //Same as above
                                if (SizeToReserve > 0)
                                    Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + SizeToReserve.ToString("X") });

                                Core.AssemblerCode.Add(new Call(xTarget.FullName()));
                            }
                            else
                            {
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = (int)xThisOffset });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EAX, SourceIndirect = true });

                                Core.AssemblerCode.Add(new Push { DestinationRef = "__VTable_Flush__" });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Push { DestinationRef = "0x" + xOp.MethodUID.ToString("X") });
                                Core.AssemblerCode.Add(new Call(Helper.lblVTable, true));
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });

                                if (xTarget.DeclaringType == typeof(object))
                                    throw new Exception("@Callvirt:: Not implemented");

                                if (SizeToReserve > 0)
                                    Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + SizeToReserve.ToString("X") });

                                Core.AssemblerCode.Add(new Call("EAX"));
                            }
                        }

                        //Check if ECX register has no error value that is 0x1
                        //If yes than jump to next instruction
                        Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xNextAddress });

                        //If they are not equal it mean throwed exception,
                        //then jump to next exception & firstly change the stack frame back to original
                        //one as we are not going to return anything from this method
                        for (int i = 0; i < xReturnSize / 4; i++)
                            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xEndException });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            ///If there is not method info than why push anything to virtual stack
            if (xTargetInfo == null || xReturnSize == 0)
                return;

            Core.vStack.Push(xReturnSize, typeof(Int32));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I1)]
    public class Conv_I1 : MSIL
    {
        public Conv_I1(Compiler Cmp)
            : base("convi1", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Pop the item on stack
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I1 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Just Pop into EAX, zero extend and push it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AL, Size = 8 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I1 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte manily 1 byte of it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AL, Size = 8 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_I1 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            //We have to push the result to stack
            Core.vStack.Push(4, typeof(int));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I2)]
    public class Conv_I2 : MSIL
    {
        public Conv_I2(Compiler Cmp)
            : base("convi2", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I2 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Just Pop into EAX, zero extend and push it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AX, Size = 16 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I2 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte manily 2 byte of it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AX, Size = 16 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_I2 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(short));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I4)]
    public class Conv_I4 : MSIL
    {
        public Conv_I4(Compiler Cmp)
            : base("convi4", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I4 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Not Required because it is already what we want, So Never called
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I4 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_I4 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(Int32));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I8 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I8)]
    public class Conv_I8 : MSIL
    {
        public Conv_I8(Compiler Cmp)
            : base("convi8", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true });//fld [ESP]
                                        Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x4" });//sub ESP, 0x4
                                        Core.AssemblerCode.Add(new Fisttp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });//fisttp [ESP]
                                    }
                                    else
                                    {
                                        //First Pop into EAX, convert it to long and push back
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I8 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Not Required because it is already what we want, So Never called
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_I8 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(8, typeof(Int64));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.CompilerExt;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I)]
    [ILOp(ILCode.Conv_Ovf_I)]
    public class Conv_I : MSIL
    {
        public Conv_I(Compiler Cmp)
            : base("convi", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Conversion of pointer
            switch (ILCompiler.CPUArchitecture)
            {
                case CPUArch.x86:
                    {
                        Compiler.MSIL[ILCode.Conv_I4].Execute(instr, aMethod);
                    }
                    break;
                case CPUArch.x64:
                    {
                        Compiler.MSIL[ILCode.Conv_I8].Execute(instr, aMethod);
                    }
                    break;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U1)]
    public class Conv_U1 : MSIL
    {
        public Conv_U1(Compiler Cmp)
            : base("convu1", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U1 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Just Pop into EAX, zero extend and push it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AL, Size = 8 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U1 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte manily 1 byte of it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AL, Size = 8 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_U1 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(uint));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U2)]
    public class Conv_U2 : MSIL
    {
        public Conv_U2(Compiler Cmp)
            : base("convu2", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U2 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Just Pop into EAX, zero extend and push it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AX, Size = 16 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U2 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte manily 2 byte of it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AX, Size = 16 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default :
                                throw new Exception("Not Yet Implemented Conv_U2 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(ushort));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U4)]
    public class Conv_U4 : MSIL
    {
        public Conv_U4(Compiler Cmp)
            : base("convu4", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        Core.AssemblerCode.Add(new Cvttss2si { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                                    }
                                    else
                                    {
                                        //Not Required because it is already what we want, So Never called
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U4 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;

                            default:
                                throw new Exception("Not Yet Implemented Conv_U4 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(UInt32));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U8)]
    public class Conv_U8 : MSIL
    {
        public Conv_U8(Compiler Cmp)
            : base("convu8", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true });//fld [ESP]
                                        Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x4" });//sub ESP, 0x4
                                        Core.AssemblerCode.Add(new Fisttp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });//fisttp [ESP]
                                    }
                                    else
                                    {
                                        //First Pop into EAX, convert it to long and push back
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U8 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Not Required because it is already what we want, So Never called
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_U8 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(8, typeof(UInt64));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.CompilerExt;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U)]
    public class Conv_U : MSIL
    {
        public Conv_U(Compiler Cmp)
            : base("convu", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Conversion of unsigned pointer
            switch (ILCompiler.CPUArchitecture)
            {
                case CPUArch.x86:
                    {
                        var IL = new Conv_U4(this.Compiler);
                        IL.Execute(instr, aMethod);
                    }
                    break;
                case CPUArch.x64:
                    {
                        var IL = new Conv_U8(this.Compiler);
                        IL.Execute(instr, aMethod);
                    }
                    break;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Div MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Div)]
    public class ILDiv : MSIL
    {
        public ILDiv(Compiler Cmp)
            : base("div", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xItem = Core.vStack.Pop();
            var xSize = xItem.Size;

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                value1 is divided by value2.
                The result is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Check the size of item first
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Take the divisor value into XMM0 register
                                //2) Add ESP by 0x4 --> Like pop
                                //3) Take dividend value into XMM1 register
                                //4) Perform float division value1/value2
                                //5) Mov that value to 32 bit memory at ESP --> Like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });//value2 -> Divisor
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });//value1 -> Dividend
                                Core.AssemblerCode.Add(new Divss { DestinationReg = Registers.XMM1, SourceReg = Registers.XMM0 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.XMM1 });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop Divisor into EBX register
                                //2) Pop Dividend into EAX register
                                //3) Convert Dividend to 64 bit EDX:EAX
                                //4) Divide the content of EDX:EAX by EBX
                                //5) Push quotient in EAX to stack
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//value2 --> Divisor
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//value1 --> Dividend
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord});
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.EBX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Load Dividend at 64 bit memory of ESP + 0x8 into floating stack
                                //2) Divide the floating stack content by 64bit memory at ESP
                                //3) Add ESP by 0x8 --> Just like Pop
                                //4) Pop Floating stack into 64 bit memory at ESP
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64, DestinationDisplacement = 0x8 });//value1 --> Dividend
                                Core.AssemblerCode.Add(new Fidiv { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });//value2 --> Divisor
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                            }
                            else
                            {
                                string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                                string LabelShiftRight = BaseLabel + "ShiftRightLoop";
                                string LabelNoLoop = BaseLabel + "NoLoop";
                                string LabelEnd = BaseLabel + "End";

                                // divisor
                                //low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                                //high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });

                                //dividend
                                // low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8 });
                                //high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });

                                // pop both 8 byte values
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x10" });

                                // set flags
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                                // if high dword of divisor is already zero, we dont need the loop
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelNoLoop });

                                // set ecx to zero for counting the shift operations
                                Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.ECX });

                                Core.AssemblerCode.Add(new Label(LabelShiftRight));

                                // shift divisor 1 bit right
                                Core.AssemblerCode.Add(new Literal("shrd ESI, EDI, 0x1"));
                                Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDI, SourceRef = "0x1" });

                                // increment shift counter
                                Core.AssemblerCode.Add(new Literal("inc dword ECX"));

                                // set flags
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                                // loop while high dword of divisor till it is zero
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNZ, DestinationRef = LabelShiftRight });

                                // shift the divident now in one step
                                // shift divident CL bits right
                                Core.AssemblerCode.Add(new Literal("shrd EAX, EDX, CL"));
                                Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDX, SourceReg = Registers.CL });

                                // so we shifted both, so we have near the same relation as original values
                                // divide this
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.ESI });

                                // sign extend
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });

                                // save result to stack
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                                //TODO: implement proper derivation correction and overflow detection

                                Core.AssemblerCode.Add(new Jmp { DestinationRef = LabelEnd });

                                Core.AssemblerCode.Add(new Label(LabelNoLoop));
                                //save high dividend
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDX });
                                // extend that sign is in edx
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });
                                // divide high part
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.ESI });
                                // save high result
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                                // divide low part
                                Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                                // save low result
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                                Core.AssemblerCode.Add(new Label(LabelEnd));
                            }
                        }
                        else
                            //Division of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Div: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Div_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Div_Un)]
    public class Div_Un : MSIL
    {
        public Div_Un(Compiler Cmp)
            : base("div_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xItem = Core.vStack.Pop();
            var xSize = xItem.Size;

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                value1 is divided by value2.
                The result is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Check the size of item first
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Take the divisor value into XMM0 register
                                //2) Add ESP by 0x4 --> Like pop
                                //3) Take dividend value into XMM1 register
                                //4) Perform float division value1/value2
                                //5) Mov that value to 32 bit memory at ESP --> Like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });//value2 -> Divisor
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });//value1 -> Dividend
                                Core.AssemblerCode.Add(new Divss { DestinationReg = Registers.XMM1, SourceReg = Registers.XMM0 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.XMM1 });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop Divisor into EBX register
                                //2) Pop Dividend into EAX register
                                //3) XOR EDX Don't use cdq { http://www.asmcommunity.net/forums/topic/?id=9684 }
                                //4) Divide the content of EDX:EAX by EBX
                                //5) Push quotient in EAX to stack
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//value2 --> Divisor
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//value1 --> Dividend
                                Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EDX, SourceReg =Registers.EDX });
                                Core.AssemblerCode.Add(new Div { DestinationReg = Registers.EBX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Load Dividend at 64 bit memory of ESP + 0x8 into floating stack
                                //2) Divide the floating stack content by 64bit memory at ESP
                                //3) Add ESP by 0x8 --> Just like Pop
                                //4) Pop Floating stack into 64 bit memory at ESP
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64, DestinationDisplacement = 0x8 });//value1 --> Dividend
                                Core.AssemblerCode.Add(new Fdiv { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });//value2 --> Divisor
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                            }
                            else
                            {
                                string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                                string LabelShiftRight = BaseLabel + "ShiftRightLoop";
                                string LabelNoLoop = BaseLabel + "NoLoop";
                                string LabelEnd = BaseLabel + "End";

                                // divisor
                                //low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                                //high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });

                                //dividend
                                // low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8 });
                                //high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });

                                // pop both 8 byte values
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x10" });

                                // set flags
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                                // if high dword of divisor is already zero, we dont need the loop
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelNoLoop });

                                // set ecx to zero for counting the shift operations
                                Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.ECX });

                                Core.AssemblerCode.Add(new Label(LabelShiftRight));

                                // shift divisor 1 bit right
                                Core.AssemblerCode.Add(new Literal("shrd ESI, EDI, 0x1"));
                                Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDI, SourceRef = "0x1" });

                                // increment shift counter
                                Core.AssemblerCode.Add(new Literal("inc dword ECX"));

                                // set flags
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                                // loop while high dword of divisor till it is zero
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNZ, DestinationRef = LabelShiftRight });

                                // shift the divident now in one step
                                // shift divident CL bits right
                                Core.AssemblerCode.Add(new Literal("shrd EAX, EDX, CL"));
                                Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDX, SourceReg = Registers.CL });

                                // so we shifted both, so we have near the same relation as original values
                                // divide this
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.ESI });

                                // sign extend
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });

                                // save result to stack
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                                //TODO: implement proper derivation correction and overflow detection

                                Core.AssemblerCode.Add(new Jmp { DestinationRef = LabelEnd });

                                Core.AssemblerCode.Add(new Label(LabelNoLoop));
                                //save high dividend
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDX });
                                // extend that sign is in edx
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });
                                // divide high part
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.ESI });
                                // save high result
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                                // divide low part
                                Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                                // save low result
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                                Core.AssemblerCode.Add(new Label(LabelEnd));
                            }
                        }
                        else
                            //Division of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Div_Un: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Dup MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Dup)]
    public class Dup : MSIL
    {
        public Dup(Compiler Cmp)
            : base("dup", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We just want the size so we peek
            var xStack = Core.vStack.Peek();
            var xStackCount = (int)(xStack.Size.Align() / 4);//Calculate Stack Size

            /*
                value is pushed onto the stack.
                value is popped off of the stack for duplication.
                value is pushed back onto the stack.
                A duplicate value is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //***What we are going to do is***
                        //1) Just Push the memory at ESP with size as given above
                        for (int i = xStackCount; i > 0; i--)
                        {
                            Core.AssemblerCode.Add(
                                new Assembler.x86.Push {
                                    DestinationReg = Registers.ESP,
                                    DestinationIndirect = true,
                                    DestinationDisplacement = (int)((xStackCount - 1) * 4) });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            //Push the duplicate one
            Core.vStack.Push(xStack.Size, xStack.Type);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          InitObj MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Initobj)]
    public class Initobj : MSIL
    {
        public Initobj(Compiler Cmp)
            : base("initobj", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var mType = ((OpType)instr).Value;
            int mObjSize = mType.SizeOf();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                        for (int i = 0; i < (mObjSize / 4); i++)
                        {
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = i * 4, SourceRef = "0x0", Size = 32 });
                        }
                        switch (mObjSize % 4)
                        {
                            case 0:
                                break;
                            case 1:
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (int)((mObjSize / 4) * 4), SourceRef = "0x0", Size = 8 });
                                    break;
                                }
                            case 2:
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (int)((mObjSize / 4) * 4), SourceRef = "0x0", Size = 16 });
                                    break;
                                }
                            case 3:
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (int)((mObjSize / 4) * 4), SourceRef = "0x0", Size = 8 });
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (int)(((mObjSize / 4) * 4) + 1), SourceRef = "0x0", Size = 16 });
                                    break;
                                }
                            default:
                                    throw new NotImplementedException("@InitObj: Remainder size " + mObjSize % 4 + " not supported yet! (Type = '" + mType.FullName + "')");
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Pop();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Leave MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Leave)]
    public class ILLeave : MSIL
    {
        public ILLeave(Compiler Cmp)
            : base("leave", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOffset = ((OpBranch)instr).Value;
            var xAddr = ILHelper.GetLabel(aMethod, xOffset);

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xAddr });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    public abstract class MSIL
    {
        protected Compiler Compiler;
        protected CPUArch CPUArch;
        protected string IL;

        public MSIL(string aMnemonic, Compiler aCompiler)
        {
            IL = aMnemonic;
            Compiler = aCompiler;
            CPUArch = ILCompiler.CPUArchitecture;
            ILCompiler.Logger.Write(aMnemonic + "...Loaded");
        }

        public virtual void Execute(ILOpCode instr, MethodBase aMethod)
        {
            Core.AssemblerCode.Add(new Literal(IL));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Mul MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Mul)]
    public class Mul : MSIL
    {
        public Mul(Compiler Cmp)
            : base("mul", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xItem = Core.vStack.Pop();
            var xSize = xItem.Size;

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Take the value2 into XMM0 register
                                //2) Add ESP by 0x4 --> Like pop
                                //3) Take value1 into XMM1 register
                                //4) Perform float multiplication value1*value2
                                //5) Mov that value to 32 bit memory at ESP --> Like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });//value2
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });//value1
                                Core.AssemblerCode.Add(new Mulss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.XMM0 });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop value2 into EAX register
                                //2) Multiply EAX content with 32 bit memory at ESP and save result into EAX
                                //3) Add ESP by 0x4 --> Like pop
                                //4) Push Content of EAX into stack
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Load 64 bit memory (value2) at ESP into floating stack
                                //2) Add ESP by 0x8 --> like pop
                                //3) Multiply 64 bit memory (value1) at ESP by content in floating stack
                                //4) Pop and store floating stack value into 64 bit memory at ESP --> Push
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fmul { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                            }
                            else
                            {
                                // div of both == LEFT_LOW * RIGHT_LOW + ((LEFT_LOW * RIGHT_HIGH + RIGHT_LOW * LEFT_HIGH) << 32)
                                string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                                string Simple32Multiply = BaseLabel + "Simple32Multiply";
                                string MoveReturnValue = BaseLabel + "MoveReturnValue";

                                // right value
                                // low
                                //  SourceReg = Registers.ESP, SourceIndirect = true
                                // high
                                //  SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4

                                // left value
                                // low
                                //  SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8
                                // high
                                //  SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12

                                // compair LEFT_HIGH, RIGHT_HIGH , on zero only simple multiply is used
                                //mov RIGHT_HIGH to eax, is useable on Full 64 multiply
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = Simple32Multiply });
                                // Full 64 Multiply

                                // copy again, or could change EAX
                                //TODO is there an opcode that does OR without change EAX?
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });
                                // eax contains already RIGHT_HIGH
                                // multiply with LEFT_LOW
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 8, Size = 32 });
                                // save result of LEFT_LOW * RIGHT_HIGH
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });

                                //mov RIGHT_LOW to eax
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                // multiply with LEFT_HIGH
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 12, Size = 32 });
                                // add result of LEFT_LOW * RIGHT_HIGH + RIGHT_LOW + LEFT_HIGH
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });

                                //mov RIGHT_LOW to eax
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                // multiply with LEFT_LOW
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 8, Size = 32 });
                                // add LEFT_LOW * RIGHT_HIGH + RIGHT_LOW + LEFT_HIGH to high dword of last result
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EDX, SourceReg = Registers.ECX });

                                Core.AssemblerCode.Add(new Jmp { DestinationRef = MoveReturnValue });

                                Core.AssemblerCode.Add(new Label(Simple32Multiply));
                                //mov RIGHT_LOW to eax
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                // multiply with LEFT_LOW
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 8, Size = 32 });

                                Core.AssemblerCode.Add(new Label(MoveReturnValue));
                                // move high result to left high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 12, SourceReg = Registers.EDX });
                                // move low result to left low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 8, SourceReg = Registers.EAX });
                                // pop right 64 value
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                            }
                        }
                        else
                            //Multiplication of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Mul: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Neg MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Neg)]
    public class ILNeg : MSIL
    {
        public ILNeg(Compiler Cmp)
            : base("neg", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xItem = Core.vStack.Peek();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xItem.Size > 4)
                        {
                            throw new Exception("@Neg: xItem size > 4 not implemented!");
                        }
                        else
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EAX, SourceRef = "0xFFFFFFFF" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Newarr MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Newarr)]
    public class Newarr : MSIL
    {
        public Newarr(Compiler Cmp)
            : base("newarr", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOperand = ((OpType)instr);
            var xTargetType = xOperand.Value;
            //Size of one entry of array i.e. Size_of_one_entry.
            var xSize = xTargetType.SizeOf();

            var xTypeID = ILHelper.GetTypeID(typeof(Array));

            //HACK: this is a kind of hack :D
            var xArray_ctor = typeof(Array).GetConstructors(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance)[0];
            var xArray_ctor_label = xArray_ctor.FullName();

            Compiler.QueuedMember.Enqueue(xArray_ctor);

            //Number of elements
            Core.vStack.Pop();

            /*
                The number of elements in the array is pushed onto the stack.
                The number of elements is popped from the stack and the array is created.
                An object reference to the new array is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceRef = "0x" + xSize.ToString("X") });
                        Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESI });
                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EAX, SourceRef = "0x10" });
                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                        //Call our Heap
                        Core.AssemblerCode.Add(new Call(Helper.lblHeap, true));

                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Address
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ESI });//Number of Elements

                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, SourceRef = "0x" + xTypeID.ToString("X") });
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 4, SourceRef = "0x2" });//Array Signature here 0x2
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 8, SourceReg = Registers.ESI });
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 12, SourceRef = "0x" + xSize.ToString("X") });

                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });//For final array refernce
                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });//For ctor
                        Core.AssemblerCode.Add(new Call(xArray_ctor_label));
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(Array));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          NewObj MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Linq;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Newobj)]
    public class NewObj : MSIL
    {
        public NewObj(Compiler Cmp)
            : base("newobj", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOperand = ((OpMethod)instr);
            var xTargetMethod = xOperand.Value;
            var xTargetType = xTargetMethod.DeclaringType;
            var xCurrentLabel = ILHelper.GetLabel(aMethod, xOperand.Position);

            var xEndException = aMethod.FullName() + ".Error";
            if (instr.Ehc != null && instr.Ehc.HandlerOffset > instr.Position)
            {
                xEndException = ILHelper.GetLabel(aMethod, instr.Ehc.HandlerOffset);
            }

            string xCctorAddress = null;
            if (aMethod != null)
            {
                var xCctor = (xTargetType.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic) ?? new ConstructorInfo[0]).SingleOrDefault();
                if (xCctor != null)
                    xCctorAddress = xCctor.FullName();
            }

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xCctorAddress != null)
                        {
                            Core.AssemblerCode.Add(new Call(xCctorAddress));
                            Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xEndException });
                        }

                        if (xTargetType.IsValueType)
                        {
                            int xStorageSize = xTargetType.SizeOf().Align();
                            int xArgSize = 0;

                            var xParameterList = xTargetMethod.GetParameters();
                            foreach (var xParam in xParameterList)
                            {
                                xArgSize += xParam.ParameterType.SizeOf().Align();
                            }

                            int xShift = (int)(xArgSize - xStorageSize);
                            if (xShift < 0)
                            {
                                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + Math.Abs(xShift).ToString("X") });
                            }
                            else if (xShift > 0)
                            {
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x" + xShift.ToString("X") });
                            }

                            //Create space for struc. pointer
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP });
                            Core.vStack.Push(4, typeof(IntPtr));

                            foreach (var xParam in xParameterList)
                            {
                                int xArgSizeForThis = xParam.ParameterType.SizeOf().Align();
                                Core.vStack.Push(xArgSizeForThis, xParam.ParameterType);
                                for (int i = 1; i <= xArgSizeForThis / 4; i++)
                                {
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = (int)xStorageSize });
                                }
                            }

                            new ILCall(this.Compiler).Execute(xOperand, aMethod);
                            Core.vStack.Push(xStorageSize, xTargetType);
                        }
                        else
                        {
                            var xParams = xTargetMethod.GetParameters();
                            for (int i = 0; i < xParams.Length; i++)
                            {
                                Core.vStack.Pop();
                            }

                            bool xHasCalcSize = false;

                            if (xTargetType.ToString() == "System.String")
                            {
                                xHasCalcSize = true;

                                if (xParams.Length == 1 && xParams[0].ParameterType.ToString() == "System.Char[]")
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EAX, SourceIndirect = true, SourceDisplacement = 8 });
                                    Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                }
                                else if (xParams.Length == 1 && xParams[0].ParameterType.ToString() == "System.Char*")
                                {
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true });
                                    Core.AssemblerCode.Add(new Call("getLength_System_Char__", true));
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                }
                                else if (xParams.Length == 3 && xParams[0].ParameterType.ToString() == "System.Char[]" && xParams[1].ParameterType.ToString() == "System.Int32" && xParams[2].ParameterType.ToString() == "System.Int32")
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                    Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                }
                                else if (xParams.Length == 2 && xParams[0].ParameterType.ToString() == "System.Char" && xParams[1].ParameterType.ToString() == "System.Int32")
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                    Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                }
                                else
                                    throw new NotImplementedException("In NewObj is a string ctor implementation missing!`" + xParams[0].ParameterType.ToString() + "`");
                            }

                            int xMemSize = ILHelper.StorageSize(xTargetType) + 12;
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x" + xMemSize.ToString("X") });
                            if (xHasCalcSize)
                            {
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                            }

                            //Call our Heap
                            Core.AssemblerCode.Add(new Call(Helper.lblHeap, true));
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true });

                            int xGCFieldCount = xTargetType.GetFields().Count(x => x.FieldType.IsValueType);

                            var xTypeID = ILHelper.GetTypeID(xTargetType);

                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, SourceRef = "0x" + xTypeID.ToString("X") });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 4, SourceRef = "0x1" });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 8, SourceRef = "0x" + xMemSize.ToString("X") });
                            uint xSize = (uint)(((from item in xParams
                                                  let xQSize = item.ParameterType.SizeOf().Align()
                                                  select (int)xQSize).Take(xParams.Length).Sum()));

                            foreach (var xParam in xParams)
                            {
                                int xParamSize = xParam.ParameterType.SizeOf().Align();
                                for (int i = 0; i < xParamSize; i += 4)
                                {
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = (int)(xSize + 4) });
                                }
                            }

                            Core.AssemblerCode.Add(new Call(xTargetMethod.FullName()));
                            if (aMethod != null)
                            {
                                Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                                string xNoErrorLabel = xCurrentLabel + ".NoError";
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xNoErrorLabel });

                                PushAlignedParameterSize(xTargetMethod);
                                // an exception occurred, we need to cleanup the stack, and jump to the exit
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });

                                int xESPOffset = 0;
                                foreach (var xParam in xParams)
                                {
                                    xESPOffset += xParam.ParameterType.SizeOf().Align();
                                }
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x" + xESPOffset.ToString("X") });

                                Core.AssemblerCode.Add(new Jmp { DestinationRef = aMethod.FullName() + ".Error" });
                                Core.AssemblerCode.Add(new Label(xNoErrorLabel));
                            }
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });

                            PushAlignedParameterSize(xTargetMethod);

                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            Core.vStack.Push(4, xTargetType);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
        private static void PushAlignedParameterSize(System.Reflection.MethodBase aMethod)
        {
            System.Reflection.ParameterInfo[] xParams = aMethod.GetParameters();

            int xSize = 0;
            for (int i = 0; i < xParams.Length; i++)
                xSize += xParams[i].ParameterType.SizeOf().Align();
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x" + xSize.ToString("X") });
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Nop MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.IL
{
    [ILOp(ILCode.Nop)]
    public class Nop : MSIL
    {
        /* Do nothing (No operation).*/
        public Nop(Compiler Cmp)
            : base("nop", Cmp) { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Not MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Not)]
    public class ILNot : MSIL
    {
        public ILNot(Compiler Cmp)
            : base("not", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We need size only
            var xSize = Core.vStack.Peek().Size;

            /*
                value is pushed onto the stack.
                value is popped from the stack and its bitwise complement computed.
                The result is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Perform not Operation on EAX
                            //3) Push EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Not { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Low part of value 2 into EAX
                            //2) Pop High part of value 1 into EDX
                            //3) Perform not Operation on EAX
                            //4) Perform not Operation on EDX
                            //5) Push EDX --> High part first
                            //6) Push EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low part
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high part

                            Core.AssemblerCode.Add(new Not { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Not { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });//high part
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });//low part
                        }
                        else
                            //Case of And operation more than 8 is not usually called
                            throw new Exception("@Not: bitwise and operation more than size 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Or MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Or)]
    public class ILOr : MSIL
    {
        public ILOr(Compiler Cmp)
            : base("or", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We pop first content and peek second because we just want what's the maximum size of content
            var xSize1 = Core.vStack.Pop().Size;
            var xSize2 = Core.vStack.Peek().Size;
            var xSize = Math.Max(xSize1, xSize2);

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value1 and value2 are popped from the stack; the bitwise OR of the two values is computed.
                The result is pushed onto the stack.
            */

            //If stack size of operands are not same, than we can't do And operation
            if (xSize1.Align() != xSize2.Align())
                throw new Exception("@Or: Size of operands are different");

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Perform Or Operation on 32 bit memory at ESP to EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Low part of value 2 into EAX
                            //2) Pop High part of value 1 into EDX
                            //3) Perform Or operation of EAX and 32 bit memory at ESP
                            //4) Perform Or operation of EAX and 32 bit memory at ESP + 0x4
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low part
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high part

                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EDX, DestinationDisplacement = 0x4 });
                        }
                        else
                            //Case of And operation more than 8 is not usually called
                            throw new Exception("@Or: bitwise and operation more than size 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Pop MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Pop)]
    public class ILPop : MSIL
    {
        public ILPop(Compiler Cmp)
            : base("pop", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Just make a pop as simple as that
            Core.vStack.Pop();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //We are just popping nothing else =) but we don't want to put it anywhere
                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Rem MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Rem)]
    public class Rem : MSIL
    {
        public Rem(Compiler Cmp)
            : base("rem", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var FirstItem = Core.vStack.Peek();
            var SecondItem = Core.vStack.Pop();

            var xSize = Math.Max(FirstItem.Size, SecondItem.Size);

            /*
             * We have divisor and dividend in the stack so first pop give us divisor
             * Task is to divide them and push the remainder to the stack
             */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize > 4)
                        {
                            if (FirstItem.IsFloat)
                                throw new Exception("You Can't get remainder of floating point division");

                            string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                            string LabelShiftRight = BaseLabel + "ShiftRightLoop";
                            string LabelNoLoop = BaseLabel + "NoLoop";
                            string LabelEnd = BaseLabel + "End";

                            // divisor
                            //low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                            //high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });

                            //dividend
                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8 });
                            //high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });

                            // pop both 8 byte values
                            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x10" });

                            // set flags
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                            // if high dword of divisor is already zero, we dont need the loop
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelNoLoop });

                            // set ecx to zero for counting the shift operations
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.ECX });

                            Core.AssemblerCode.Add(new Label(LabelShiftRight));

                            // shift divisor 1 bit right
                            Core.AssemblerCode.Add(new Literal("shrd ESI, EDI, 0x1"));
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDI, SourceRef = "0x1" });

                            // increment shift counter
                            Core.AssemblerCode.Add(new Literal("inc ECX"));

                            // set flags
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                            // loop while high dword of divisor till it is zero
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelShiftRight });

                            // shift the divident now in one step
                            // shift divident CL bits right
                            Core.AssemblerCode.Add(new Literal("shrd EAX, EDX, CL"));
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDX, SourceReg = Registers.CL });

                            // so we shifted both, so we have near the same relation as original values
                            // divide this
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });

                            // save remainder to stack
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Jmp { DestinationRef = LabelEnd });

                            Core.AssemblerCode.Add(new Label(LabelNoLoop));

                            //save high dividend
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDX });
                            // zero EDX, so that high part is zero -> reduce overflow case
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EDX, SourceReg = Registers.EDX });
                            // divide high part
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                            // divide low part
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                            // save remainder result
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Label(LabelEnd));
                        }
                        else
                        {
                            if (FirstItem.IsFloat)
                                throw new Exception("You Can't get remainder of floating point division");

                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Rem_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Rem_Un)]
    public class Rem_Un : MSIL
    {
        public Rem_Un(Compiler Cmp)
            : base("rem_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var FirstItem = Core.vStack.Peek();
            var SecondItem = Core.vStack.Pop();

            var xSize = Math.Max(FirstItem.Size, SecondItem.Size);

            /*
             * We have divisor and dividend in the stack so first pop give us divisor
             * Task is to divide them and push the remainder to the stack
             */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize > 4)
                        {
                            if (FirstItem.IsFloat)
                                throw new Exception("You Can't get remainder of floating point division");

                            string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                            string LabelShiftRight = BaseLabel + "ShiftRightLoop";
                            string LabelNoLoop = BaseLabel + "NoLoop";
                            string LabelEnd = BaseLabel + "End";

                            // divisor
                            //low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                            //high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });

                            //dividend
                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8 });
                            //high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });

                            // pop both 8 byte values
                            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x10" });

                            // set flags
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                            // if high dword of divisor is already zero, we dont need the loop
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelNoLoop });

                            // set ecx to zero for counting the shift operations
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.ECX });

                            Core.AssemblerCode.Add(new Label(LabelShiftRight));

                            // shift divisor 1 bit right
                            Core.AssemblerCode.Add(new Literal("shrd ESI, EDI, 0x1"));
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDI, SourceRef = "0x1" });

                            // increment shift counter
                            Core.AssemblerCode.Add(new Literal("inc ECX"));

                            // set flags
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                            // loop while high dword of divisor till it is zero
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelShiftRight });

                            // shift the divident now in one step
                            // shift divident CL bits right
                            Core.AssemblerCode.Add(new Literal("shrd EAX, EDX, CL"));
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDX, SourceReg = Registers.CL });

                            // so we shifted both, so we have near the same relation as original values
                            // divide this
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });

                            // save remainder to stack
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Jmp { DestinationRef = LabelEnd });

                            Core.AssemblerCode.Add(new Label(LabelNoLoop));

                            //save high dividend
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDX });
                            // zero EDX, so that high part is zero -> reduce overflow case
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EDX, SourceReg = Registers.EDX });
                            // divide high part
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                            // divide low part
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                            // save remainder result
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Label(LabelEnd));
                        }
                        else
                        {
                            if (FirstItem.IsFloat)
                                throw new Exception("You Can't get remainder of floating point division");

                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EDX, SourceReg = Registers.EDX });
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ret MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Ret)]
    public class ILRet : MSIL
    {
        public ILRet(Compiler Cmp)
            : base("ret", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Current method end label without exception
            var xTargetLabel = aMethod.FullName() + ".End";

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Just jump to End of label of current method as simple as that
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xTargetLabel });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shl MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Shl)]
    public class ILShl : MSIL
    {
        public ILShl(Compiler Cmp)
            : base("shl", Cmp)
        { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xStackItem_ShiftAmount = Core.vStack.Pop();
            var xStackItem_Value = Core.vStack.Peek();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xStackItem_Value.Size > 4)
                        {
                            // stack item 1 - arg (x)
                            // stack item 2 - shift amount (y)

                            // x.High = (x.High << y) | (x.Low & ~((1 << y) - 1))
                            // x.Low = x.Low << y
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });

                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceRef = "0x20" });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = ".LessThan32" });
                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceRef = "0x0" });
                            // high
                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ECX, SourceRef = "0x1F" });
                            Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceReg = Registers.CL });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 4, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { DestinationRef = ".ShlComplete" });

                            Core.AssemblerCode.Add(new Label(".LessThan32"));
                            // High
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceDisplacement = 4, SourceIndirect = true });
                            // shift lower
                            Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.CL });
                            // shift high
                            Core.AssemblerCode.Add(new Literal("shld dword EDX, EAX, CL"));
                            Core.AssemblerCode.Add(new Label(".ShlComplete"));
                        }
                        else
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX }); //Shift Amount
                            Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.CL });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                    #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shr MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Shr)]
    public class ILShr : MSIL
    {
        public ILShr(Compiler Cmp)
            : base("shr", Cmp)
        { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xStackItem_ShiftAmount = Core.vStack.Pop();
            var xStackItem_Value = Core.vStack.Peek();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xStackItem_Value.Size > 4)
                        {
                            // stack item 1 - arg (x)
                            // stack item 2 - shift amount (y)

                            // x.Low = (x.Low >> y) | (x.High & ((1 << y) - 1)) << ((1 << (32 - y)) - 1)
                            // x.High = (x.High >> y)
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });

                            // high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceDisplacement = 4, SourceIndirect = true });

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceRef = "0x20" });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = ".LessThan32" });
                            // high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationDisplacement = 4, DestinationIndirect = true, SourceRef = "0x0" });
                            // low
                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ECX, SourceRef = "0x1F" });
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EAX, SourceReg = Registers.CL });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 4, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { DestinationRef = ".ShrComplete" });

                            Core.AssemblerCode.Add(new Label(".LessThan32"));
                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true });
                            // shift high
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 4, SourceReg = Registers.CL });
                            // shift low
                            Core.AssemblerCode.Add(new Literal("shrd dword EDX, EAX, CL"));
                            Core.AssemblerCode.Add(new Label(".ShrComplete"));
                        }
                        else
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX }); // Shift Amount
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.CL });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                    #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shr_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Shr_Un)]
    public class Shr_Un : MSIL
    {
        public Shr_Un(Compiler Cmp)
            : base("shr_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xStackItem_ShiftAmount = Core.vStack.Pop();
            var xStackItem_Value = Core.vStack.Peek();

            /*
            This is almost same as Shr_Un, just the difference in size > 4
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xStackItem_Value.Size > 4)
                        {
                            throw new Exception("Not Yet implemented");
                        }
                        else
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX }); //Shift Amount
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.ESP, DestinationIndirect = true,SourceReg = Registers.CL });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          SizeOf MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Sizeof)]
    public class SizeOf : MSIL
    {
        public SizeOf(Compiler Cmp)
            : base("sizeof", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOp = ((OpType)instr).Value;
            var xSize = xOp.SizeOf();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x" + xSize.ToString("X") });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(UInt32));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sub MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Sub)]
    public class ILSub : MSIL
    {
        public ILSub(Compiler Cmp)
            : base("sub", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We pop first content and peek second because we just want size of content
            var xItem = Core.vStack.Pop();
            var xSize = xItem.Size;

            //If stack size of operands are not same, than we can't do Sub operation
            if (xSize != Core.vStack.Peek().Size)
                throw new Exception("@Sub: different size in subtraction is not possible :(; Sizes=" + xSize + ", " + Core.vStack.Peek().Size);

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                value2 is subtracted from value1.
                The result is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Copy ESP value 2 to XMM0 register
                                //2) Add ESP by 4 to move stack pointer
                                //3) Copy ESP value 1 to XMM1
                                //4) Sub both values are take result to XMM1 --> XMM1 = XMM1 - XMM2
                                //5) Copy the value to memory at ESP --> Just like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });//1st value
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });//2nd value
                                Core.AssemblerCode.Add(new Subss { DestinationReg = Registers.XMM1, SourceReg = Registers.XMM0 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.XMM1 });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop the value 2 from the stack into EBX
                                //2) Pop the value 1 from the stack into EAX
                                //3) Sub EBX from EAX and save value into EAX
                                //4) Push content of EAX to stack
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.EAX, SourceReg = Registers.EBX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Load the 64 bit memory at ESP + 0x8 into FLD stack
                                //2) Use Float Sub to add value in float stack to 64 bit memory at ESP, And store result in float stack
                                //3) Add ESP by 0x8 --> To shift pointer
                                //4) Just like Pop, we pop the iteam from float stack and put it into 64 bit memory at ESP
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64, DestinationDisplacement = 0x8 });
                                Core.AssemblerCode.Add(new Fsub { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                            }
                            else
                            {
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });

                                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                                Core.AssemblerCode.Add(new SubWithCarry { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 4, SourceReg = Registers.EDX });
                            }
                        }
                        else
                            //Subtraction of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Sub: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Switch MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Switch)]
    public class Switch : MSIL
    {
        public Switch(Compiler Cmp)
            : base("switch", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xBranchs = ((OpSwitch)instr).Value;

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                        for (int i = 0; i < xBranchs.Length; i++)
                        {
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x" + i.ToString("X") });
                            string xLabel = ILHelper.GetLabel(aMethod, xBranchs[i]);
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xLabel });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Pop();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_Ref MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Throw)]
    public class Throw : MSIL
    {
        public Throw(Compiler Cmp)
            : base("throw", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xEndException = aMethod.FullName() + ".Error";
            if (instr.Ehc != null && instr.Ehc.HandlerOffset > instr.Position)
            {
                xEndException = ILHelper.GetLabel(aMethod, instr.Ehc.HandlerOffset);
            }
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Call(Helper.lblSetException, true));
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xEndException });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Pop();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Volatile MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.CompilerExt;

namespace Atomix.IL
{
    [ILOp(ILCode.Volatile)]
    public class Volatile : MSIL
    {
        public Volatile(Compiler Cmp)
            : base("volatile", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Nothing here
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Xor MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Xor)]
    public class ILXor : MSIL
    {
        public ILXor(Compiler Cmp)
            : base("xor", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We pop first content and peek second because we just want what's the maximum size of content
            var xSize1 = Core.vStack.Pop().Size;
            var xSize2 = Core.vStack.Peek().Size;
            var xSize = Math.Max(xSize1, xSize2);

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value1 and value2 are popped from the stack; the bitwise XOR of the two values is computed.
                The result is pushed onto the stack.
            */

            //If stack size of operands are not same, than we can't do And operation
            if (xSize1.Align() != xSize2.Align())
                throw new Exception("@Xor: Size of operands are different");

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Perform Or Operation on 32 bit memory at ESP to EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Low part of value 2 into EAX
                            //2) Pop High part of value 1 into EDX
                            //3) Perform Or operation of EAX and 32 bit memory at ESP
                            //4) Perform Or operation of EAX and 32 bit memory at ESP + 0x4
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low part
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high part

                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EDX, DestinationDisplacement = 0x4 });
                        }
                        else
                            //Case of And operation more than 8 is not usually called
                            throw new Exception("@Xor: bitwise and operation more than size 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Beq MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Beq)]
    public class Beq : MSIL
    {
        public Beq(Compiler Cmp)
            : base("beq", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._beq_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();
            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is equal to value2, the branch operation is performed. --> value1 = value2
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 into EAX
                            //2) Pop Value 1 into EBX
                            //3) Xor EAX and EBX, Jump to Branch when the result is zero
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EAX, SourceReg = Registers.EBX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 low into EAX and high into EBX
                            //2) Pop Value 1 low into ECX and high into EDX
                            //3) Xor low values and check if zero than continue else if not than jump to Not Equal
                            //4) Xor high values and check if zero than jump to Branch else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//high

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high

                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNZ, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EBX, SourceReg = Registers.EDX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Beq: Branch operation beq for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bge MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bge)]
    public class Bge : MSIL
    {
        public Bge(Compiler Cmp)
            : base("bge", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bge_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();
            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is greater than or equal to value2, the branch operation is performed. --> value1 ≥ value2
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 into EAX
                            //2) Pop Value 1 into EBX
                            //3) Compare EBX and EAX and jump if greator than equals to
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });//value1 - value2
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JGE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//high

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JGE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bge: Branch operation bge for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bg2_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bge_Un)]
    public class Bge_Un : MSIL
    {
        public Bge_Un(Compiler Cmp)
            : base("bge_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bge_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();
            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is greater than or equal to value2, the branch operation is performed. --> value1 ≥ value2
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 into EAX
                            //2) Pop Value 1 into EBX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });//value1 - value2
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JAE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//high

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JAE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bge_Un: Branch operation bge_un for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bgt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bgt)]
    public class Bgt : MSIL
    {
        public Bgt(Compiler Cmp)
            : base("bgt", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bgt_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is greater than value2, the branch operation is performed. --> value1 > value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if greator than
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if greator than true else if less than jump false
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bgt: Branch operation bgt for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bgt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bgt_Un)]
    public class Bgt_Un : MSIL
    {
        public Bgt_Un(Compiler Cmp)
            : base("bgt_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bgt_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is greater than value2, the branch operation is performed. --> value1 > value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if greator than
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if greator than true else if less than jump false
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bgt: Branch operation bgt for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ble MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Ble)]
    public class Ble : MSIL
    {
        public Ble(Compiler Cmp)
            : base("ble", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._ble_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is less than or equals to value2, the branch operation is performed. --> value1 ≤ value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if less than or equals to
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JLE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JLE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Ble: Branch operation ble for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ble_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Ble_Un)]
    public class Ble_Un : MSIL
    {
        public Ble_Un(Compiler Cmp)
            : base("ble_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._ble_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is less than or equals to value2, the branch operation is performed. --> value1 ≤ value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if less than or equals to
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JBE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JBE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Ble_Un: Branch operation ble_un for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Blt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Blt)]
    public class Blt : MSIL
    {
        public Blt(Compiler Cmp)
            : base("blt", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._blt_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is less than value2, the branch operation is performed. --> value1 < value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if less than
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Ble: Branch operation ble for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Blt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Blt_Un)]
    public class Blt_Un : MSIL
    {
        public Blt_Un(Compiler Cmp)
            : base("blt_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._blt_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is less than value2, the branch operation is performed. --> value1 < value2
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Pop value 1 into EBX
                            //3) Compare EBX and EAX and jump if less than or equals to
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 low into EAX and high into EBX
                            //2) Pop value 1 low into ECX and high into EDX
                            //3) Compare High parts of value 1 and value 2, if less than false  else if greator than jump true
                            //4) Compare Low parts of value 1 and value 2, if greator than jump true else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//High

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//Low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//High

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EDX, SourceReg = Registers.EBX });//value1_HI - value2_HI
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xFalseLabel });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });//value1_LO - value2_LO
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Ble: Branch operation ble for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Bne_un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Bne_Un)]
    public class Bne_Un : MSIL
    {
        public Bne_Un(Compiler Cmp)
            : base("bne_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            var xSize = Core.vStack.Pop().Size;
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            var xFalseLabel = ILHelper.GetLabel(aMethod, instr.Position) + "._bne_un_false";

            //Make a pop because exactly we are popping up two items
            Core.vStack.Pop();
            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                if value1 is not equal to value2, the branch operation is performed. --> value1 ≠ value2
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 into EAX
                            //2) Pop Value 1 into EBX
                            //3) Compare EAX and EBX, Jump to Branch when the result is not zero
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Value 2
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//Value 1
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.EBX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Value 2 low into EAX and high into EBX
                            //2) Pop Value 1 low into ECX and high into EDX
                            //3) Compare low values and check if zero than continue else if not than jump to Not Equal
                            //4) Compare high values and check if zero than jump to Branch else continue

                            //Value 2 EBX:EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//high

                            //Value 1 EDX:ECX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });//low
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EBX, SourceReg = Registers.EDX });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });

                            Core.AssemblerCode.Add(new Label(xFalseLabel));
                        }
                        else
                            //Not called usually
                            throw new Exception("@Bne_Un: Branch operation bne_un for size > 8 is not yet implemented");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Br MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Br)]
    public class Br : MSIL
    {
        public Br(Compiler Cmp)
            : base("br", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            //The target branch
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);

            //Just make the jump to given target branch
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Just make a jump as simple as that =)
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xTrueLabel });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Brfalse MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Brfalse)]
    public class Brfalse : MSIL
    {
        public Brfalse(Compiler Cmp)
            : base("brfalse", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            //The brach label
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            //Just make a pop because we want only size of it
            var xSize = Core.vStack.Pop().Size;

            /*
                value is pushed onto the stack by a previous operation.
                value is popped from the stack;
                if value is false, branch to target.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    //***What we are going to do is***
                                    //1) Pop the content into EAX
                                    //2) Compare the content with 0x0 --> False
                                    //3) If they are equal than jump to branch
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xTrueLabel });
                                }
                                break;
                            case 8:
                                {
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });

                                    string xFalseLabel = xTrueLabel + ".false";
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xFalseLabel });
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xTrueLabel });
                                    Core.AssemblerCode.Add(new Label(xFalseLabel));
                                }
                                break;
                            default:
                                //Size > 4 is never called don't know why
                                throw new Exception("@Brfalse: Unexpected size called := " + xSize);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Brtrue MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Brtrue)]
    public class Brtrue : MSIL
    {
        public Brtrue(Compiler Cmp)
            : base("brtrue", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //This is branch type IL
            var xOffset = ((OpBranch)instr).Value;
            //The brach label
            var xTrueLabel = ILHelper.GetLabel(aMethod, xOffset);
            //Just make a pop because we want only size of it
            var xSize = Core.vStack.Pop().Size;

            /*
                value is pushed onto the stack by a previous operation.
                value is popped from the stack;
                if value is true, branch to target.
            */

            //Branch to target
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    //***What we are going to do is***
                                    //1) Pop the content into EAX
                                    //2) Compare the content with 0x0 --> False
                                    //3) If they are equal than jump to branch
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                                }
                                break;
                            case 8:
                                {
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });

                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x0" });
                                    Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xTrueLabel });
                                }
                                break;
                            default:
                                //Size > 4 is never called don't know why
                                throw new Exception("@Brtrue: Unexpected size called := " + xSize);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Call MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Call)]
    public class ILCall : MSIL
    {
        public ILCall(Compiler Cmp)
            : base("call", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //The Target method base which we have to call
            var xTarget = ((OpMethod)instr).Value;
            //Try to get if there is any method info of target method
            var xTargetInfo = xTarget as MethodInfo;
            var xNormalAddress = xTarget.FullName(); //Target method full name
            var xParams = xTarget.GetParameters();
            var xNextAddress = ILHelper.GetLabel(aMethod, instr.NextPosition);//Next address after call IL instruction

            /* Now to find error handling label
               This is because if the called method throwed any exception than to handle that we need something.
             */
            var xEndException = aMethod.FullName() + ".Error";//Current method exception label
            //Check if there is any try catch field after this call instruction
            if (instr.Ehc != null && instr.Ehc.HandlerOffset > instr.Position)
            {
                //If yes take that label as excpetion handling label
                xEndException = ILHelper.GetLabel(aMethod, instr.Ehc.HandlerOffset);
            }

            //If method have any method info than check what is its return size
            //And also align it to stack pointer
            var xReturnSize = 0;
            if (xTargetInfo != null)
                xReturnSize = xTargetInfo.ReturnType.SizeOf().Align();

            /* Size to reserve can be viewed as the segment of stack that is require to call a function
             * where function can put it all its parameters/local variables
             * And finally the return size */
            #region Size2Reserve
            int SizeToReserve = xReturnSize;
            if (SizeToReserve > 0)
            {
                foreach (var xp in xTarget.GetParameters())
                {
                    SizeToReserve -= xp.ParameterType.SizeOf().Align();
                    Core.vStack.Pop();
                }
                if (!xTargetInfo.IsStatic)
                {
                    SizeToReserve -= (ILCompiler.CPUArchitecture == CompilerExt.CPUArch.x86 ? 4 : 8);
                    Core.vStack.Pop();
                }
            }
            #endregion

            /*
                Method arguments arg1 through argN are pushed onto the stack.
                Method arguments arg1 through argN are popped from the stack;
                the method call is performed with these arguments and control is transferred,
                to the method referred to by the method descriptor. When complete,
                a return value is generated by the callee method and sent to the caller.
                The return value is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Make Space for extra requirements of function
                        if (SizeToReserve > 0)
                            Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + SizeToReserve.ToString("X") });

                        Core.AssemblerCode.Add(new Call(xNormalAddress));

                        if (aMethod != null)
                        {
                            //Check if ECX register has no error value that is 0x1
                            //If yes than jump to next instruction
                            Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xNextAddress });

                            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x" + xReturnSize.ToString("x") });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xEndException });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            ///If there is not method info than why push anything to virtual stack
            if (xTargetInfo == null || xReturnSize == 0)
                return;

            Core.vStack.Push(xReturnSize, xTargetInfo.ReturnType);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          CallVirt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Callvirt)]
    public class ILCallvirt : MSIL
    {
        public ILCallvirt(Compiler Cmp)
            : base("callvirt", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOp = (OpMethod)instr;
            //The Target method base which we have to call
            var xTarget = xOp.Value;
            //Try to get if there is any method info of target method
            var xTargetInfo = xTarget as MethodInfo;
            var xNormalAddress = string.Empty;

            if (xTarget.IsStatic || !xTarget.IsVirtual || xTarget.IsFinal)
                xNormalAddress = xTarget.FullName();//Target method full name

            var xParams = xTarget.GetParameters();
            var xNextAddress = ILHelper.GetLabel(aMethod, instr.NextPosition);//Next address after call IL instruction

            /* Now to find error handling label
               This is because if the called method throwed any exception than to handle that we need something.
             */
            var xEndException = aMethod.FullName() + ".Error";//Current method exception label
            //Check if there is any try catch field after this call instruction
            if (instr.Ehc != null && instr.Ehc.HandlerOffset > instr.Position)
            {
                //If yes take that label as excpetion handling label
                xEndException = ILHelper.GetLabel(aMethod, instr.Ehc.HandlerOffset);
            }

            //If method have any method info than check what is its return size
            //And also align it to stack pointer
            var xReturnSize = 0;
            if (xTargetInfo != null)
                xReturnSize = xTargetInfo.ReturnType.SizeOf().Align();

            /* Size to reserve can be viewed as the segment of stack that is require to call a function
             * where function can put it all its parameters/local variables
             * And finally the return size */
            #region Size2Reserve
            int SizeToReserve = xReturnSize;
            if (SizeToReserve > 0)
            {
                foreach (var xp in xTarget.GetParameters())
                {
                    SizeToReserve -= xp.ParameterType.SizeOf().Align();
                }
                if (!xTargetInfo.IsStatic)
                {
                    SizeToReserve -= (ILCompiler.CPUArchitecture == CompilerExt.CPUArch.x86 ? 4 : 8);
                }
            }
            #endregion

            int xThisOffset = 0;
            var xParameters = xTarget.GetParameters();
            foreach (var xItem in xParameters)
            {
                xThisOffset += xItem.ParameterType.SizeOf().Align();
                Core.vStack.Pop();
            }
            if (!xTarget.IsStatic)
            {
                Core.vStack.Pop();
            }

            /*
                Method arguments arg1 through argN are pushed onto the stack.
                Method arguments arg1 through argN are popped from the stack;
                the method call is performed with these arguments and control is transferred,
                to the method referred to by the method descriptor. When complete,
                a return value is generated by the callee method and sent to the caller.
                The return value is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (!String.IsNullOrEmpty(xNormalAddress))
                        {
                            //Make Space for extra requirements of function
                            if (SizeToReserve > 0)
                                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + SizeToReserve.ToString("X") });

                            Core.AssemblerCode.Add(new Call(xNormalAddress));
                        }
                        else
                        {
                            if (xOp.MethodUID == 0)
                            {
                                //Same as above
                                if (SizeToReserve > 0)
                                    Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + SizeToReserve.ToString("X") });

                                Core.AssemblerCode.Add(new Call(xTarget.FullName()));
                            }
                            else
                            {
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = (int)xThisOffset });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EAX, SourceIndirect = true });

                                Core.AssemblerCode.Add(new Push { DestinationRef = "__VTable_Flush__" });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Push { DestinationRef = "0x" + xOp.MethodUID.ToString("X") });
                                Core.AssemblerCode.Add(new Call(Helper.lblVTable, true));
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });

                                if (xTarget.DeclaringType == typeof(object))
                                    throw new Exception("@Callvirt:: Not implemented");

                                if (SizeToReserve > 0)
                                    Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + SizeToReserve.ToString("X") });

                                Core.AssemblerCode.Add(new Call("EAX"));
                            }
                        }

                        //Check if ECX register has no error value that is 0x1
                        //If yes than jump to next instruction
                        Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xNextAddress });

                        //If they are not equal it mean throwed exception,
                        //then jump to next exception & firstly change the stack frame back to original
                        //one as we are not going to return anything from this method
                        for (int i = 0; i < xReturnSize / 4; i++)
                            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xEndException });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            ///If there is not method info than why push anything to virtual stack
            if (xTargetInfo == null || xReturnSize == 0)
                return;

            Core.vStack.Push(xReturnSize, typeof(Int32));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I1 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I1)]
    public class Conv_I1 : MSIL
    {
        public Conv_I1(Compiler Cmp)
            : base("convi1", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Pop the item on stack
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I1 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Just Pop into EAX, zero extend and push it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AL, Size = 8 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I1 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte manily 1 byte of it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AL, Size = 8 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_I1 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            //We have to push the result to stack
            Core.vStack.Push(4, typeof(int));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I2 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I2)]
    public class Conv_I2 : MSIL
    {
        public Conv_I2(Compiler Cmp)
            : base("convi2", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I2 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Just Pop into EAX, zero extend and push it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AX, Size = 16 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I2 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte manily 2 byte of it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AX, Size = 16 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_I2 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(short));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I4 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I4)]
    public class Conv_I4 : MSIL
    {
        public Conv_I4(Compiler Cmp)
            : base("convi4", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I4 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Not Required because it is already what we want, So Never called
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I4 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_I4 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(Int32));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I8 MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I8)]
    public class Conv_I8 : MSIL
    {
        public Conv_I8(Compiler Cmp)
            : base("convi8", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true });//fld [ESP]
                                        Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x4" });//sub ESP, 0x4
                                        Core.AssemblerCode.Add(new Fisttp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });//fisttp [ESP]
                                    }
                                    else
                                    {
                                        //First Pop into EAX, convert it to long and push back
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_I8 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Not Required because it is already what we want, So Never called
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_I8 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(8, typeof(Int64));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_I MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.CompilerExt;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_I)]
    [ILOp(ILCode.Conv_Ovf_I)]
    public class Conv_I : MSIL
    {
        public Conv_I(Compiler Cmp)
            : base("convi", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Conversion of pointer
            switch (ILCompiler.CPUArchitecture)
            {
                case CPUArch.x86:
                    {
                        Compiler.MSIL[ILCode.Conv_I4].Execute(instr, aMethod);
                    }
                    break;
                case CPUArch.x64:
                    {
                        Compiler.MSIL[ILCode.Conv_I8].Execute(instr, aMethod);
                    }
                    break;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U1)]
    public class Conv_U1 : MSIL
    {
        public Conv_U1(Compiler Cmp)
            : base("convu1", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U1 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Just Pop into EAX, zero extend and push it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AL, Size = 8 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U1 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte manily 1 byte of it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AL, Size = 8 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_U1 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(uint));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U2)]
    public class Conv_U2 : MSIL
    {
        public Conv_U2(Compiler Cmp)
            : base("convu2", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U2 -> Size 4 : Float");
                                    }
                                    else
                                    {
                                        //Just Pop into EAX, zero extend and push it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AX, Size = 16 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U2 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte manily 2 byte of it.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movzx { DestinationReg = Registers.EAX, SourceReg = Registers.AX, Size = 16 });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            default :
                                throw new Exception("Not Yet Implemented Conv_U2 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(ushort));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U4)]
    public class Conv_U4 : MSIL
    {
        public Conv_U4(Compiler Cmp)
            : base("convu4", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        Core.AssemblerCode.Add(new Cvttss2si { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                                    }
                                    else
                                    {
                                        //Not Required because it is already what we want, So Never called
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U4 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Just Erase The 8 byte as we want only first 4 byte.
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;

                            default:
                                throw new Exception("Not Yet Implemented Conv_U4 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(4, typeof(UInt32));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U8)]
    public class Conv_U8 : MSIL
    {
        public Conv_U8(Compiler Cmp)
            : base("convu8", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xSource = Core.vStack.Pop();

            //Convert to int8, pushing int32 on stack.
            //Mean Just Convert Last 1 byte to Int32
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSource.Size)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true });//fld [ESP]
                                        Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x4" });//sub ESP, 0x4
                                        Core.AssemblerCode.Add(new Fisttp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });//fisttp [ESP]
                                    }
                                    else
                                    {
                                        //First Pop into EAX, convert it to long and push back
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (xSource.IsFloat)
                                    {
                                        throw new Exception("Conv_U8 -> Size 8 : Float");
                                    }
                                    else
                                    {
                                        //Not Required because it is already what we want, So Never called
                                    }
                                }
                                break;
                            default:
                                throw new Exception("Not Yet Implemented Conv_U8 : Size" + xSource.Size);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Push(8, typeof(UInt64));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conv_U MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.CompilerExt;

namespace Atomix.IL
{
    [ILOp(ILCode.Conv_U)]
    public class Conv_U : MSIL
    {
        public Conv_U(Compiler Cmp)
            : base("convu", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Conversion of unsigned pointer
            switch (ILCompiler.CPUArchitecture)
            {
                case CPUArch.x86:
                    {
                        var IL = new Conv_U4(this.Compiler);
                        IL.Execute(instr, aMethod);
                    }
                    break;
                case CPUArch.x64:
                    {
                        var IL = new Conv_U8(this.Compiler);
                        IL.Execute(instr, aMethod);
                    }
                    break;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Div MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Div)]
    public class ILDiv : MSIL
    {
        public ILDiv(Compiler Cmp)
            : base("div", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xItem = Core.vStack.Pop();
            var xSize = xItem.Size;

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                value1 is divided by value2.
                The result is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Check the size of item first
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Take the divisor value into XMM0 register
                                //2) Add ESP by 0x4 --> Like pop
                                //3) Take dividend value into XMM1 register
                                //4) Perform float division value1/value2
                                //5) Mov that value to 32 bit memory at ESP --> Like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });//value2 -> Divisor
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });//value1 -> Dividend
                                Core.AssemblerCode.Add(new Divss { DestinationReg = Registers.XMM1, SourceReg = Registers.XMM0 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.XMM1 });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop Divisor into EBX register
                                //2) Pop Dividend into EAX register
                                //3) Convert Dividend to 64 bit EDX:EAX
                                //4) Divide the content of EDX:EAX by EBX
                                //5) Push quotient in EAX to stack
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//value2 --> Divisor
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//value1 --> Dividend
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord});
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.EBX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Load Dividend at 64 bit memory of ESP + 0x8 into floating stack
                                //2) Divide the floating stack content by 64bit memory at ESP
                                //3) Add ESP by 0x8 --> Just like Pop
                                //4) Pop Floating stack into 64 bit memory at ESP
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64, DestinationDisplacement = 0x8 });//value1 --> Dividend
                                Core.AssemblerCode.Add(new Fidiv { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });//value2 --> Divisor
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                            }
                            else
                            {
                                string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                                string LabelShiftRight = BaseLabel + "ShiftRightLoop";
                                string LabelNoLoop = BaseLabel + "NoLoop";
                                string LabelEnd = BaseLabel + "End";

                                // divisor
                                //low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                                //high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });

                                //dividend
                                // low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8 });
                                //high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });

                                // pop both 8 byte values
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x10" });

                                // set flags
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                                // if high dword of divisor is already zero, we dont need the loop
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelNoLoop });

                                // set ecx to zero for counting the shift operations
                                Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.ECX });

                                Core.AssemblerCode.Add(new Label(LabelShiftRight));

                                // shift divisor 1 bit right
                                Core.AssemblerCode.Add(new Literal("shrd ESI, EDI, 0x1"));
                                Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDI, SourceRef = "0x1" });

                                // increment shift counter
                                Core.AssemblerCode.Add(new Literal("inc dword ECX"));

                                // set flags
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                                // loop while high dword of divisor till it is zero
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNZ, DestinationRef = LabelShiftRight });

                                // shift the divident now in one step
                                // shift divident CL bits right
                                Core.AssemblerCode.Add(new Literal("shrd EAX, EDX, CL"));
                                Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDX, SourceReg = Registers.CL });

                                // so we shifted both, so we have near the same relation as original values
                                // divide this
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.ESI });

                                // sign extend
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });

                                // save result to stack
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                                //TODO: implement proper derivation correction and overflow detection

                                Core.AssemblerCode.Add(new Jmp { DestinationRef = LabelEnd });

                                Core.AssemblerCode.Add(new Label(LabelNoLoop));
                                //save high dividend
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDX });
                                // extend that sign is in edx
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });
                                // divide high part
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.ESI });
                                // save high result
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                                // divide low part
                                Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                                // save low result
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                                Core.AssemblerCode.Add(new Label(LabelEnd));
                            }
                        }
                        else
                            //Division of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Div: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Div_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Div_Un)]
    public class Div_Un : MSIL
    {
        public Div_Un(Compiler Cmp)
            : base("div_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xItem = Core.vStack.Pop();
            var xSize = xItem.Size;

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                value1 is divided by value2.
                The result is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Check the size of item first
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Take the divisor value into XMM0 register
                                //2) Add ESP by 0x4 --> Like pop
                                //3) Take dividend value into XMM1 register
                                //4) Perform float division value1/value2
                                //5) Mov that value to 32 bit memory at ESP --> Like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });//value2 -> Divisor
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });//value1 -> Dividend
                                Core.AssemblerCode.Add(new Divss { DestinationReg = Registers.XMM1, SourceReg = Registers.XMM0 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.XMM1 });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop Divisor into EBX register
                                //2) Pop Dividend into EAX register
                                //3) XOR EDX Don't use cdq { http://www.asmcommunity.net/forums/topic/?id=9684 }
                                //4) Divide the content of EDX:EAX by EBX
                                //5) Push quotient in EAX to stack
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });//value2 --> Divisor
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//value1 --> Dividend
                                Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EDX, SourceReg =Registers.EDX });
                                Core.AssemblerCode.Add(new Div { DestinationReg = Registers.EBX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Load Dividend at 64 bit memory of ESP + 0x8 into floating stack
                                //2) Divide the floating stack content by 64bit memory at ESP
                                //3) Add ESP by 0x8 --> Just like Pop
                                //4) Pop Floating stack into 64 bit memory at ESP
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64, DestinationDisplacement = 0x8 });//value1 --> Dividend
                                Core.AssemblerCode.Add(new Fdiv { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });//value2 --> Divisor
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                            }
                            else
                            {
                                string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                                string LabelShiftRight = BaseLabel + "ShiftRightLoop";
                                string LabelNoLoop = BaseLabel + "NoLoop";
                                string LabelEnd = BaseLabel + "End";

                                // divisor
                                //low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                                //high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });

                                //dividend
                                // low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8 });
                                //high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });

                                // pop both 8 byte values
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x10" });

                                // set flags
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                                // if high dword of divisor is already zero, we dont need the loop
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelNoLoop });

                                // set ecx to zero for counting the shift operations
                                Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.ECX });

                                Core.AssemblerCode.Add(new Label(LabelShiftRight));

                                // shift divisor 1 bit right
                                Core.AssemblerCode.Add(new Literal("shrd ESI, EDI, 0x1"));
                                Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDI, SourceRef = "0x1" });

                                // increment shift counter
                                Core.AssemblerCode.Add(new Literal("inc dword ECX"));

                                // set flags
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                                // loop while high dword of divisor till it is zero
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNZ, DestinationRef = LabelShiftRight });

                                // shift the divident now in one step
                                // shift divident CL bits right
                                Core.AssemblerCode.Add(new Literal("shrd EAX, EDX, CL"));
                                Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDX, SourceReg = Registers.CL });

                                // so we shifted both, so we have near the same relation as original values
                                // divide this
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.ESI });

                                // sign extend
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });

                                // save result to stack
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                                //TODO: implement proper derivation correction and overflow detection

                                Core.AssemblerCode.Add(new Jmp { DestinationRef = LabelEnd });

                                Core.AssemblerCode.Add(new Label(LabelNoLoop));
                                //save high dividend
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDX });
                                // extend that sign is in edx
                                Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });
                                // divide high part
                                Core.AssemblerCode.Add(new IDiv { DestinationReg = Registers.ESI });
                                // save high result
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                                // divide low part
                                Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                                // save low result
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                                Core.AssemblerCode.Add(new Label(LabelEnd));
                            }
                        }
                        else
                            //Division of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Div_Un: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Dup MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Dup)]
    public class Dup : MSIL
    {
        public Dup(Compiler Cmp)
            : base("dup", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We just want the size so we peek
            var xStack = Core.vStack.Peek();
            var xStackCount = (int)(xStack.Size.Align() / 4);//Calculate Stack Size

            /*
                value is pushed onto the stack.
                value is popped off of the stack for duplication.
                value is pushed back onto the stack.
                A duplicate value is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //***What we are going to do is***
                        //1) Just Push the memory at ESP with size as given above
                        for (int i = xStackCount; i > 0; i--)
                        {
                            Core.AssemblerCode.Add(
                                new Assembler.x86.Push {
                                    DestinationReg = Registers.ESP,
                                    DestinationIndirect = true,
                                    DestinationDisplacement = (int)((xStackCount - 1) * 4) });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            //Push the duplicate one
            Core.vStack.Push(xStack.Size, xStack.Type);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          InitObj MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Initobj)]
    public class Initobj : MSIL
    {
        public Initobj(Compiler Cmp)
            : base("initobj", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var mType = ((OpType)instr).Value;
            int mObjSize = mType.SizeOf();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                        for (int i = 0; i < (mObjSize / 4); i++)
                        {
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = i * 4, SourceRef = "0x0", Size = 32 });
                        }
                        switch (mObjSize % 4)
                        {
                            case 0:
                                break;
                            case 1:
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (int)((mObjSize / 4) * 4), SourceRef = "0x0", Size = 8 });
                                    break;
                                }
                            case 2:
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (int)((mObjSize / 4) * 4), SourceRef = "0x0", Size = 16 });
                                    break;
                                }
                            case 3:
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (int)((mObjSize / 4) * 4), SourceRef = "0x0", Size = 8 });
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (int)(((mObjSize / 4) * 4) + 1), SourceRef = "0x0", Size = 16 });
                                    break;
                                }
                            default:
                                    throw new NotImplementedException("@InitObj: Remainder size " + mObjSize % 4 + " not supported yet! (Type = '" + mType.FullName + "')");
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Pop();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Leave MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Leave)]
    public class ILLeave : MSIL
    {
        public ILLeave(Compiler Cmp)
            : base("leave", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOffset = ((OpBranch)instr).Value;
            var xAddr = ILHelper.GetLabel(aMethod, xOffset);

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xAddr });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    public abstract class MSIL
    {
        protected Compiler Compiler;
        protected CPUArch CPUArch;
        protected string IL;

        public MSIL(string aMnemonic, Compiler aCompiler)
        {
            IL = aMnemonic;
            Compiler = aCompiler;
            CPUArch = ILCompiler.CPUArchitecture;
            ILCompiler.Logger.Write(aMnemonic + "...Loaded");
        }

        public virtual void Execute(ILOpCode instr, MethodBase aMethod)
        {
            Core.AssemblerCode.Add(new Literal(IL));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Mul MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Mul)]
    public class Mul : MSIL
    {
        public Mul(Compiler Cmp)
            : base("mul", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xItem = Core.vStack.Pop();
            var xSize = xItem.Size;

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Take the value2 into XMM0 register
                                //2) Add ESP by 0x4 --> Like pop
                                //3) Take value1 into XMM1 register
                                //4) Perform float multiplication value1*value2
                                //5) Mov that value to 32 bit memory at ESP --> Like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });//value2
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });//value1
                                Core.AssemblerCode.Add(new Mulss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.XMM0 });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop value2 into EAX register
                                //2) Multiply EAX content with 32 bit memory at ESP and save result into EAX
                                //3) Add ESP by 0x4 --> Like pop
                                //4) Push Content of EAX into stack
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Load 64 bit memory (value2) at ESP into floating stack
                                //2) Add ESP by 0x8 --> like pop
                                //3) Multiply 64 bit memory (value1) at ESP by content in floating stack
                                //4) Pop and store floating stack value into 64 bit memory at ESP --> Push
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fmul { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                            }
                            else
                            {
                                // div of both == LEFT_LOW * RIGHT_LOW + ((LEFT_LOW * RIGHT_HIGH + RIGHT_LOW * LEFT_HIGH) << 32)
                                string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                                string Simple32Multiply = BaseLabel + "Simple32Multiply";
                                string MoveReturnValue = BaseLabel + "MoveReturnValue";

                                // right value
                                // low
                                //  SourceReg = Registers.ESP, SourceIndirect = true
                                // high
                                //  SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4

                                // left value
                                // low
                                //  SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8
                                // high
                                //  SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12

                                // compair LEFT_HIGH, RIGHT_HIGH , on zero only simple multiply is used
                                //mov RIGHT_HIGH to eax, is useable on Full 64 multiply
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });
                                Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = Simple32Multiply });
                                // Full 64 Multiply

                                // copy again, or could change EAX
                                //TODO is there an opcode that does OR without change EAX?
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });
                                // eax contains already RIGHT_HIGH
                                // multiply with LEFT_LOW
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 8, Size = 32 });
                                // save result of LEFT_LOW * RIGHT_HIGH
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });

                                //mov RIGHT_LOW to eax
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                // multiply with LEFT_HIGH
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 12, Size = 32 });
                                // add result of LEFT_LOW * RIGHT_HIGH + RIGHT_LOW + LEFT_HIGH
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });

                                //mov RIGHT_LOW to eax
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                // multiply with LEFT_LOW
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 8, Size = 32 });
                                // add LEFT_LOW * RIGHT_HIGH + RIGHT_LOW + LEFT_HIGH to high dword of last result
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EDX, SourceReg = Registers.ECX });

                                Core.AssemblerCode.Add(new Jmp { DestinationRef = MoveReturnValue });

                                Core.AssemblerCode.Add(new Label(Simple32Multiply));
                                //mov RIGHT_LOW to eax
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                // multiply with LEFT_LOW
                                Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 8, Size = 32 });

                                Core.AssemblerCode.Add(new Label(MoveReturnValue));
                                // move high result to left high
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 12, SourceReg = Registers.EDX });
                                // move low result to left low
                                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 8, SourceReg = Registers.EAX });
                                // pop right 64 value
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                            }
                        }
                        else
                            //Multiplication of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Mul: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Neg MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Neg)]
    public class ILNeg : MSIL
    {
        public ILNeg(Compiler Cmp)
            : base("neg", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xItem = Core.vStack.Peek();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xItem.Size > 4)
                        {
                            throw new Exception("@Neg: xItem size > 4 not implemented!");
                        }
                        else
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EAX, SourceRef = "0xFFFFFFFF" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Newarr MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Newarr)]
    public class Newarr : MSIL
    {
        public Newarr(Compiler Cmp)
            : base("newarr", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOperand = ((OpType)instr);
            var xTargetType = xOperand.Value;
            //Size of one entry of array i.e. Size_of_one_entry.
            var xSize = xTargetType.SizeOf();

            var xTypeID = ILHelper.GetTypeID(typeof(Array));

            //HACK: this is a kind of hack :D
            var xArray_ctor = typeof(Array).GetConstructors(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance)[0];
            var xArray_ctor_label = xArray_ctor.FullName();

            Compiler.QueuedMember.Enqueue(xArray_ctor);

            //Number of elements
            Core.vStack.Pop();

            /*
                The number of elements in the array is pushed onto the stack.
                The number of elements is popped from the stack and the array is created.
                An object reference to the new array is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceRef = "0x" + xSize.ToString("X") });
                        Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESI });
                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EAX, SourceRef = "0x10" });
                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });

                        //Call our Heap
                        Core.AssemblerCode.Add(new Call(Helper.lblHeap, true));

                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//Address
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ESI });//Number of Elements

                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, SourceRef = "0x" + xTypeID.ToString("X") });
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 4, SourceRef = "0x2" });//Array Signature here 0x2
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 8, SourceReg = Registers.ESI });
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 12, SourceRef = "0x" + xSize.ToString("X") });

                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });//For final array refernce
                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });//For ctor
                        Core.AssemblerCode.Add(new Call(xArray_ctor_label));
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(Array));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          NewObj MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Linq;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Newobj)]
    public class NewObj : MSIL
    {
        public NewObj(Compiler Cmp)
            : base("newobj", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOperand = ((OpMethod)instr);
            var xTargetMethod = xOperand.Value;
            var xTargetType = xTargetMethod.DeclaringType;
            var xCurrentLabel = ILHelper.GetLabel(aMethod, xOperand.Position);

            var xEndException = aMethod.FullName() + ".Error";
            if (instr.Ehc != null && instr.Ehc.HandlerOffset > instr.Position)
            {
                xEndException = ILHelper.GetLabel(aMethod, instr.Ehc.HandlerOffset);
            }

            string xCctorAddress = null;
            if (aMethod != null)
            {
                var xCctor = (xTargetType.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic) ?? new ConstructorInfo[0]).SingleOrDefault();
                if (xCctor != null)
                    xCctorAddress = xCctor.FullName();
            }

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xCctorAddress != null)
                        {
                            Core.AssemblerCode.Add(new Call(xCctorAddress));
                            Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xEndException });
                        }

                        if (xTargetType.IsValueType)
                        {
                            int xStorageSize = xTargetType.SizeOf().Align();
                            int xArgSize = 0;

                            var xParameterList = xTargetMethod.GetParameters();
                            foreach (var xParam in xParameterList)
                            {
                                xArgSize += xParam.ParameterType.SizeOf().Align();
                            }

                            int xShift = (int)(xArgSize - xStorageSize);
                            if (xShift < 0)
                            {
                                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + Math.Abs(xShift).ToString("X") });
                            }
                            else if (xShift > 0)
                            {
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x" + xShift.ToString("X") });
                            }

                            //Create space for struc. pointer
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP });
                            Core.vStack.Push(4, typeof(IntPtr));

                            foreach (var xParam in xParameterList)
                            {
                                int xArgSizeForThis = xParam.ParameterType.SizeOf().Align();
                                Core.vStack.Push(xArgSizeForThis, xParam.ParameterType);
                                for (int i = 1; i <= xArgSizeForThis / 4; i++)
                                {
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = (int)xStorageSize });
                                }
                            }

                            new ILCall(this.Compiler).Execute(xOperand, aMethod);
                            Core.vStack.Push(xStorageSize, xTargetType);
                        }
                        else
                        {
                            var xParams = xTargetMethod.GetParameters();
                            for (int i = 0; i < xParams.Length; i++)
                            {
                                Core.vStack.Pop();
                            }

                            bool xHasCalcSize = false;

                            if (xTargetType.ToString() == "System.String")
                            {
                                xHasCalcSize = true;

                                if (xParams.Length == 1 && xParams[0].ParameterType.ToString() == "System.Char[]")
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EAX, SourceIndirect = true, SourceDisplacement = 8 });
                                    Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                }
                                else if (xParams.Length == 1 && xParams[0].ParameterType.ToString() == "System.Char*")
                                {
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true });
                                    Core.AssemblerCode.Add(new Call("getLength_System_Char__", true));
                                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                    Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                }
                                else if (xParams.Length == 3 && xParams[0].ParameterType.ToString() == "System.Char[]" && xParams[1].ParameterType.ToString() == "System.Int32" && xParams[2].ParameterType.ToString() == "System.Int32")
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                    Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                }
                                else if (xParams.Length == 2 && xParams[0].ParameterType.ToString() == "System.Char" && xParams[1].ParameterType.ToString() == "System.Int32")
                                {
                                    Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                    Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceRef = "0x1" });
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                                }
                                else
                                    throw new NotImplementedException("In NewObj is a string ctor implementation missing!`" + xParams[0].ParameterType.ToString() + "`");
                            }

                            int xMemSize = ILHelper.StorageSize(xTargetType) + 12;
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x" + xMemSize.ToString("X") });
                            if (xHasCalcSize)
                            {
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                            }

                            //Call our Heap
                            Core.AssemblerCode.Add(new Call(Helper.lblHeap, true));
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true });

                            int xGCFieldCount = xTargetType.GetFields().Count(x => x.FieldType.IsValueType);

                            var xTypeID = ILHelper.GetTypeID(xTargetType);

                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, SourceRef = "0x" + xTypeID.ToString("X") });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 4, SourceRef = "0x1" });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 8, SourceRef = "0x" + xMemSize.ToString("X") });
                            uint xSize = (uint)(((from item in xParams
                                                  let xQSize = item.ParameterType.SizeOf().Align()
                                                  select (int)xQSize).Take(xParams.Length).Sum()));

                            foreach (var xParam in xParams)
                            {
                                int xParamSize = xParam.ParameterType.SizeOf().Align();
                                for (int i = 0; i < xParamSize; i += 4)
                                {
                                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = (int)(xSize + 4) });
                                }
                            }

                            Core.AssemblerCode.Add(new Call(xTargetMethod.FullName()));
                            if (aMethod != null)
                            {
                                Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                                string xNoErrorLabel = xCurrentLabel + ".NoError";
                                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xNoErrorLabel });

                                PushAlignedParameterSize(xTargetMethod);
                                // an exception occurred, we need to cleanup the stack, and jump to the exit
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });

                                int xESPOffset = 0;
                                foreach (var xParam in xParams)
                                {
                                    xESPOffset += xParam.ParameterType.SizeOf().Align();
                                }
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x" + xESPOffset.ToString("X") });

                                Core.AssemblerCode.Add(new Jmp { DestinationRef = aMethod.FullName() + ".Error" });
                                Core.AssemblerCode.Add(new Label(xNoErrorLabel));
                            }
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });

                            PushAlignedParameterSize(xTargetMethod);

                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            Core.vStack.Push(4, xTargetType);
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
        private static void PushAlignedParameterSize(System.Reflection.MethodBase aMethod)
        {
            System.Reflection.ParameterInfo[] xParams = aMethod.GetParameters();

            int xSize = 0;
            for (int i = 0; i < xParams.Length; i++)
                xSize += xParams[i].ParameterType.SizeOf().Align();
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x" + xSize.ToString("X") });
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Nop MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.IL
{
    [ILOp(ILCode.Nop)]
    public class Nop : MSIL
    {
        /* Do nothing (No operation).*/
        public Nop(Compiler Cmp)
            : base("nop", Cmp) { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Not MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Not)]
    public class ILNot : MSIL
    {
        public ILNot(Compiler Cmp)
            : base("not", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We need size only
            var xSize = Core.vStack.Peek().Size;

            /*
                value is pushed onto the stack.
                value is popped from the stack and its bitwise complement computed.
                The result is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Perform not Operation on EAX
                            //3) Push EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Not { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Low part of value 2 into EAX
                            //2) Pop High part of value 1 into EDX
                            //3) Perform not Operation on EAX
                            //4) Perform not Operation on EDX
                            //5) Push EDX --> High part first
                            //6) Push EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low part
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high part

                            Core.AssemblerCode.Add(new Not { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Not { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });//high part
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });//low part
                        }
                        else
                            //Case of And operation more than 8 is not usually called
                            throw new Exception("@Not: bitwise and operation more than size 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Or MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Or)]
    public class ILOr : MSIL
    {
        public ILOr(Compiler Cmp)
            : base("or", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We pop first content and peek second because we just want what's the maximum size of content
            var xSize1 = Core.vStack.Pop().Size;
            var xSize2 = Core.vStack.Peek().Size;
            var xSize = Math.Max(xSize1, xSize2);

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value1 and value2 are popped from the stack; the bitwise OR of the two values is computed.
                The result is pushed onto the stack.
            */

            //If stack size of operands are not same, than we can't do And operation
            if (xSize1.Align() != xSize2.Align())
                throw new Exception("@Or: Size of operands are different");

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Perform Or Operation on 32 bit memory at ESP to EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Low part of value 2 into EAX
                            //2) Pop High part of value 1 into EDX
                            //3) Perform Or operation of EAX and 32 bit memory at ESP
                            //4) Perform Or operation of EAX and 32 bit memory at ESP + 0x4
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low part
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high part

                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EDX, DestinationDisplacement = 0x4 });
                        }
                        else
                            //Case of And operation more than 8 is not usually called
                            throw new Exception("@Or: bitwise and operation more than size 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Pop MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Pop)]
    public class ILPop : MSIL
    {
        public ILPop(Compiler Cmp)
            : base("pop", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Just make a pop as simple as that
            Core.vStack.Pop();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //We are just popping nothing else =) but we don't want to put it anywhere
                        Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Rem MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Rem)]
    public class Rem : MSIL
    {
        public Rem(Compiler Cmp)
            : base("rem", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var FirstItem = Core.vStack.Peek();
            var SecondItem = Core.vStack.Pop();

            var xSize = Math.Max(FirstItem.Size, SecondItem.Size);

            /*
             * We have divisor and dividend in the stack so first pop give us divisor
             * Task is to divide them and push the remainder to the stack
             */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize > 4)
                        {
                            if (FirstItem.IsFloat)
                                throw new Exception("You Can't get remainder of floating point division");

                            string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                            string LabelShiftRight = BaseLabel + "ShiftRightLoop";
                            string LabelNoLoop = BaseLabel + "NoLoop";
                            string LabelEnd = BaseLabel + "End";

                            // divisor
                            //low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                            //high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });

                            //dividend
                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8 });
                            //high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });

                            // pop both 8 byte values
                            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x10" });

                            // set flags
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                            // if high dword of divisor is already zero, we dont need the loop
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelNoLoop });

                            // set ecx to zero for counting the shift operations
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.ECX });

                            Core.AssemblerCode.Add(new Label(LabelShiftRight));

                            // shift divisor 1 bit right
                            Core.AssemblerCode.Add(new Literal("shrd ESI, EDI, 0x1"));
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDI, SourceRef = "0x1" });

                            // increment shift counter
                            Core.AssemblerCode.Add(new Literal("inc ECX"));

                            // set flags
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                            // loop while high dword of divisor till it is zero
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelShiftRight });

                            // shift the divident now in one step
                            // shift divident CL bits right
                            Core.AssemblerCode.Add(new Literal("shrd EAX, EDX, CL"));
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDX, SourceReg = Registers.CL });

                            // so we shifted both, so we have near the same relation as original values
                            // divide this
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });

                            // save remainder to stack
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Jmp { DestinationRef = LabelEnd });

                            Core.AssemblerCode.Add(new Label(LabelNoLoop));

                            //save high dividend
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDX });
                            // zero EDX, so that high part is zero -> reduce overflow case
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EDX, SourceReg = Registers.EDX });
                            // divide high part
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                            // divide low part
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                            // save remainder result
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Label(LabelEnd));
                        }
                        else
                        {
                            if (FirstItem.IsFloat)
                                throw new Exception("You Can't get remainder of floating point division");

                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Conversion { Type = ConversionCode.SignedDWord_2_SignedQWord });
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Rem_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Rem_Un)]
    public class Rem_Un : MSIL
    {
        public Rem_Un(Compiler Cmp)
            : base("rem_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var FirstItem = Core.vStack.Peek();
            var SecondItem = Core.vStack.Pop();

            var xSize = Math.Max(FirstItem.Size, SecondItem.Size);

            /*
             * We have divisor and dividend in the stack so first pop give us divisor
             * Task is to divide them and push the remainder to the stack
             */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize > 4)
                        {
                            if (FirstItem.IsFloat)
                                throw new Exception("You Can't get remainder of floating point division");

                            string BaseLabel = ILHelper.GetLabel(aMethod, instr.Position) + ".";
                            string LabelShiftRight = BaseLabel + "ShiftRightLoop";
                            string LabelNoLoop = BaseLabel + "NoLoop";
                            string LabelEnd = BaseLabel + "End";

                            // divisor
                            //low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.ESP, SourceIndirect = true });
                            //high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 4 });

                            //dividend
                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 8 });
                            //high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 12 });

                            // pop both 8 byte values
                            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x10" });

                            // set flags
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                            // if high dword of divisor is already zero, we dont need the loop
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelNoLoop });

                            // set ecx to zero for counting the shift operations
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ECX, SourceReg = Registers.ECX });

                            Core.AssemblerCode.Add(new Label(LabelShiftRight));

                            // shift divisor 1 bit right
                            Core.AssemblerCode.Add(new Literal("shrd ESI, EDI, 0x1"));
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDI, SourceRef = "0x1" });

                            // increment shift counter
                            Core.AssemblerCode.Add(new Literal("inc ECX"));

                            // set flags
                            Core.AssemblerCode.Add(new Or { DestinationReg = Registers.EDI, SourceReg = Registers.EDI });
                            // loop while high dword of divisor till it is zero
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JZ, DestinationRef = LabelShiftRight });

                            // shift the divident now in one step
                            // shift divident CL bits right
                            Core.AssemblerCode.Add(new Literal("shrd EAX, EDX, CL"));
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EDX, SourceReg = Registers.CL });

                            // so we shifted both, so we have near the same relation as original values
                            // divide this
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });

                            // save remainder to stack
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Jmp { DestinationRef = LabelEnd });

                            Core.AssemblerCode.Add(new Label(LabelNoLoop));

                            //save high dividend
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDX });
                            // zero EDX, so that high part is zero -> reduce overflow case
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EDX, SourceReg = Registers.EDX });
                            // divide high part
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
                            // divide low part
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ESI });
                            // save remainder result
                            Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });

                            Core.AssemblerCode.Add(new Label(LabelEnd));
                        }
                        else
                        {
                            if (FirstItem.IsFloat)
                                throw new Exception("You Can't get remainder of floating point division");

                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EDX, SourceReg = Registers.EDX });
                            Core.AssemblerCode.Add(new Div { DestinationReg = Registers.ECX });
                            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDX });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ret MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Ret)]
    public class ILRet : MSIL
    {
        public ILRet(Compiler Cmp)
            : base("ret", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Current method end label without exception
            var xTargetLabel = aMethod.FullName() + ".End";

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Just jump to End of label of current method as simple as that
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xTargetLabel });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shl MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Shl)]
    public class ILShl : MSIL
    {
        public ILShl(Compiler Cmp)
            : base("shl", Cmp)
        { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xStackItem_ShiftAmount = Core.vStack.Pop();
            var xStackItem_Value = Core.vStack.Peek();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xStackItem_Value.Size > 4)
                        {
                            // stack item 1 - arg (x)
                            // stack item 2 - shift amount (y)

                            // x.High = (x.High << y) | (x.Low & ~((1 << y) - 1))
                            // x.Low = x.Low << y
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });

                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceRef = "0x20" });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = ".LessThan32" });
                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceRef = "0x0" });
                            // high
                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ECX, SourceRef = "0x1F" });
                            Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.EAX, SourceReg = Registers.CL });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 4, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { DestinationRef = ".ShlComplete" });

                            Core.AssemblerCode.Add(new Label(".LessThan32"));
                            // High
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceDisplacement = 4, SourceIndirect = true });
                            // shift lower
                            Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.CL });
                            // shift high
                            Core.AssemblerCode.Add(new Literal("shld dword EDX, EAX, CL"));
                            Core.AssemblerCode.Add(new Label(".ShlComplete"));
                        }
                        else
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX }); //Shift Amount
                            Core.AssemblerCode.Add(new ShiftLeft { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.CL });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                    #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shr MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Shr)]
    public class ILShr : MSIL
    {
        public ILShr(Compiler Cmp)
            : base("shr", Cmp)
        { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xStackItem_ShiftAmount = Core.vStack.Pop();
            var xStackItem_Value = Core.vStack.Peek();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xStackItem_Value.Size > 4)
                        {
                            // stack item 1 - arg (x)
                            // stack item 2 - shift amount (y)

                            // x.Low = (x.Low >> y) | (x.High & ((1 << y) - 1)) << ((1 << (32 - y)) - 1)
                            // x.High = (x.High >> y)
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });

                            // high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceDisplacement = 4, SourceIndirect = true });

                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.ECX, SourceRef = "0x20" });
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = ".LessThan32" });
                            // high
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationDisplacement = 4, DestinationIndirect = true, SourceRef = "0x0" });
                            // low
                            Core.AssemblerCode.Add(new And { DestinationReg = Registers.ECX, SourceRef = "0x1F" });
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.EAX, SourceReg = Registers.CL });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 4, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Jmp { DestinationRef = ".ShrComplete" });

                            Core.AssemblerCode.Add(new Label(".LessThan32"));
                            // low
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDX, SourceReg = Registers.ESP, SourceIndirect = true });
                            // shift high
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 4, SourceReg = Registers.CL });
                            // shift low
                            Core.AssemblerCode.Add(new Literal("shrd dword EDX, EAX, CL"));
                            Core.AssemblerCode.Add(new Label(".ShrComplete"));
                        }
                        else
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX }); // Shift Amount
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.CL });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                    #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shr_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.CompilerExt;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Shr_Un)]
    public class Shr_Un : MSIL
    {
        public Shr_Un(Compiler Cmp)
            : base("shr_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xStackItem_ShiftAmount = Core.vStack.Pop();
            var xStackItem_Value = Core.vStack.Peek();

            /*
            This is almost same as Shr_Un, just the difference in size > 4
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xStackItem_Value.Size > 4)
                        {
                            throw new Exception("Not Yet implemented");
                        }
                        else
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX }); //Shift Amount
                            Core.AssemblerCode.Add(new ShiftRight { DestinationReg = Registers.ESP, DestinationIndirect = true,SourceReg = Registers.CL });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          SizeOf MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Sizeof)]
    public class SizeOf : MSIL
    {
        public SizeOf(Compiler Cmp)
            : base("sizeof", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOp = ((OpType)instr).Value;
            var xSize = xOp.SizeOf();

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x" + xSize.ToString("X") });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(UInt32));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sub MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Sub)]
    public class ILSub : MSIL
    {
        public ILSub(Compiler Cmp)
            : base("sub", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We pop first content and peek second because we just want size of content
            var xItem = Core.vStack.Pop();
            var xSize = xItem.Size;

            //If stack size of operands are not same, than we can't do Sub operation
            if (xSize != Core.vStack.Peek().Size)
                throw new Exception("@Sub: different size in subtraction is not possible :(; Sizes=" + xSize + ", " + Core.vStack.Peek().Size);

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value2 and value1 are popped from the stack;
                value2 is subtracted from value1.
                The result is pushed onto the stack.
            */

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Copy ESP value 2 to XMM0 register
                                //2) Add ESP by 4 to move stack pointer
                                //3) Copy ESP value 1 to XMM1
                                //4) Sub both values are take result to XMM1 --> XMM1 = XMM1 - XMM2
                                //5) Copy the value to memory at ESP --> Just like push
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });//1st value
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });//2nd value
                                Core.AssemblerCode.Add(new Subss { DestinationReg = Registers.XMM1, SourceReg = Registers.XMM0 });
                                Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.XMM1 });
                            }
                            else
                            {
                                //***What we are going to do is***
                                //1) Pop the value 2 from the stack into EBX
                                //2) Pop the value 1 from the stack into EAX
                                //3) Sub EBX from EAX and save value into EAX
                                //4) Push content of EAX to stack
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.EAX, SourceReg = Registers.EBX });
                                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                            }
                        }
                        else if (xSize <= 8)
                        {
                            if (xItem.IsFloat)
                            {
                                //***What we are going to do is***
                                //1) Load the 64 bit memory at ESP + 0x8 into FLD stack
                                //2) Use Float Sub to add value in float stack to 64 bit memory at ESP, And store result in float stack
                                //3) Add ESP by 0x8 --> To shift pointer
                                //4) Just like Pop, we pop the iteam from float stack and put it into 64 bit memory at ESP
                                Core.AssemblerCode.Add(new Fld { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64, DestinationDisplacement = 0x8 });
                                Core.AssemblerCode.Add(new Fsub { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                Core.AssemblerCode.Add(new Fstp { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 64 });
                            }
                            else
                            {
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });

                                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                                Core.AssemblerCode.Add(new SubWithCarry { DestinationReg = Registers.ESP, DestinationIndirect = true, DestinationDisplacement = 4, SourceReg = Registers.EDX });
                            }
                        }
                        else
                            //Subtraction of more than size 8 is never called i guess :P
                            //But if it is called than will implement later
                            throw new Exception("@Sub: Size greator than 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Switch MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Switch)]
    public class Switch : MSIL
    {
        public Switch(Compiler Cmp)
            : base("switch", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xBranchs = ((OpSwitch)instr).Value;

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                        for (int i = 0; i < xBranchs.Length; i++)
                        {
                            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x" + i.ToString("X") });
                            string xLabel = ILHelper.GetLabel(aMethod, xBranchs[i]);
                            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xLabel });
                        }
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Pop();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stind_Ref MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Throw)]
    public class Throw : MSIL
    {
        public Throw(Compiler Cmp)
            : base("throw", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xEndException = aMethod.FullName() + ".Error";
            if (instr.Ehc != null && instr.Ehc.HandlerOffset > instr.Position)
            {
                xEndException = ILHelper.GetLabel(aMethod, instr.Ehc.HandlerOffset);
            }
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Call(Helper.lblSetException, true));
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xEndException });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Pop();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Volatile MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.CompilerExt;

namespace Atomix.IL
{
    [ILOp(ILCode.Volatile)]
    public class Volatile : MSIL
    {
        public Volatile(Compiler Cmp)
            : base("volatile", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Nothing here
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Xor MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Assembler;
using Atomix.CompilerExt;
using System.Reflection;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Xor)]
    public class ILXor : MSIL
    {
        public ILXor(Compiler Cmp)
            : base("xor", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //We pop first content and peek second because we just want what's the maximum size of content
            var xSize1 = Core.vStack.Pop().Size;
            var xSize2 = Core.vStack.Peek().Size;
            var xSize = Math.Max(xSize1, xSize2);

            /*
                value1 is pushed onto the stack.
                value2 is pushed onto the stack.
                value1 and value2 are popped from the stack; the bitwise XOR of the two values is computed.
                The result is pushed onto the stack.
            */

            //If stack size of operands are not same, than we can't do And operation
            if (xSize1.Align() != xSize2.Align())
                throw new Exception("@Xor: Size of operands are different");

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        if (xSize <= 4)
                        {
                            //***What we are going to do is***
                            //1) Pop value 2 into EAX
                            //2) Perform Or Operation on 32 bit memory at ESP to EAX
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                        }
                        else if (xSize <= 8)
                        {
                            //***What we are going to do is***
                            //1) Pop Low part of value 2 into EAX
                            //2) Pop High part of value 1 into EDX
                            //3) Perform Or operation of EAX and 32 bit memory at ESP
                            //4) Perform Or operation of EAX and 32 bit memory at ESP + 0x4
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });//low part
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });//high part

                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EAX });
                            Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.ESP, DestinationIndirect = true, SourceReg = Registers.EDX, DestinationDisplacement = 0x4 });
                        }
                        else
                            //Case of And operation more than 8 is not usually called
                            throw new Exception("@Xor: bitwise and operation more than size 8 is not yet supported");
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Box MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Box)]
    public class Box : MSIL
    {
        public Box(Compiler Cmp)
            : base("box", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xOpType = ((OpType)instr).Value;
            var xSize = xOpType.SizeOf().Align();
            var xTypeID = ILHelper.GetTypeID(xOpType);

            /*
                A value type is pushed onto the stack.
                The value type is popped from the stack; the box operation is performed.
                An object reference to the resulting "boxed" value type is pushed onto the stack.
            */
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        #warning Have to check memory allocation here, so don't use it now
                        //Why i did this? well box is nothing but it converts object type so, lets assume it is already what we want :P
                        Console.WriteLine("Box Operation is being called by " + aMethod.FullName() + "\n" + xOpType);
                        break;
                        throw new Exception("Not yet implemented");
                        //***What we are going to do is***
                        //1) Push the size of object + 0xC --> The 0xC is the offset of object data before this object metadata is stored
                        //2) Call our memory manager
                        //3) After that we have done boxing :P
                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x" + (0xC + xSize).ToString("X") });
                        Core.AssemblerCode.Add(new Call (Helper.lblHeap, true));
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, SourceRef = "0x" + xTypeID.ToString("X") });
                        Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = 4, SourceRef = "0x3" });

                        for (int i = 0; i < (xSize / 4); i++)
                        {
                            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });
                            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, DestinationIndirect = true, DestinationDisplacement = (0xC + (i * 4)), SourceReg = Registers.EDX });
                        }
                        Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }

            Core.vStack.Pop();
            Core.vStack.Push(4, typeof(UIntPtr));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          call x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public class Call : Instruction
    {
        public readonly string Address;
        public readonly bool FunctionLabel;

        public Call(string aAddress, bool aFunctionLabel = false)
            :base ("call")
        {
            Address = aAddress;
            // If FunctionLabel is set then it will look into Label Dictionary for real symbol name
            // check Compiler.FlushAsmFile();
            FunctionLabel = aFunctionLabel;
        }

        public override void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine("call " + Address);
        }

        public static void FlushText(StreamWriter aSW, string aAddress)
        {
            aSW.WriteLine("call " + aAddress);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          CastClass MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/


using System.Reflection;

namespace Atomix.IL
{
    [ILOp(ILCode.Castclass)]
    public class CastClass : MSIL
    {
        public CastClass(Compiler Cmp)
            : base("CastClass", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Do Nothing
            //COMPILER HACK ^^
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ceq MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Ceq)]
    public class Ceq : MSIL
    {
        public Ceq(Compiler Cmp)
            : base("ceq", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var FirstStackItem = Core.vStack.Pop();
            var SecondStackItem = Core.vStack.Pop();

            var xSize = Math.Max(FirstStackItem.Size, SecondStackItem.Size);
            var xCurrentLabel = ILHelper.GetLabel(aMethod, instr.Position);
            var xFinalLabel = ILHelper.GetLabel(aMethod, instr.NextPosition);

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        /*Ceq checks if both values in stack are equal or not, if they are equal then they push 1 onto the stack else
                         * 0 is pushed to the stack
                         */
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (FirstStackItem.IsFloat) //If one item is float then both will
                                    {
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true });
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true });
                                        Core.AssemblerCode.Add(new Cmpss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1, PseudoCode = ComparePseudoOpcodes.Equal });
                                        Core.AssemblerCode.Add(new MovD { SourceReg = Registers.XMM0, DestinationReg = Registers.EBX });
                                        Core.AssemblerCode.Add(new And { DestinationReg = Registers.EBX, SourceRef = "0x1" });
                                        Core.AssemblerCode.Add(new Mov { SourceReg = Registers.EBX, DestinationReg = Registers.ESP, DestinationIndirect = true });
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });
                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xCurrentLabel + ".true" });
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        //Not equal
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //equal
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".true"));
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });
                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (FirstStackItem.IsFloat)
                                    {
                                    }
                                    else
                                    {
                                        //Check Hight Part
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 0x4 });
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xCurrentLabel + ".false" });

                                        //Check Low part
                                        Core.AssemblerCode.Add(new Xor { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true, SourceDisplacement = 0x4 });
                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNZ, DestinationRef = xCurrentLabel + ".false" });

                                        //equal
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //not equal
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".false"));
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x8" });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });
                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                        }

                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(bool));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Cgt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Cgt)]
    public class Cgt : MSIL
    {
        public Cgt(Compiler Cmp)
            : base("cgt", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Cgt just check if value 2 < Value 1, if yes than push 0x1 else push 0x0
            var FirstStackItem = Core.vStack.Pop();
            var SecondStackItem = Core.vStack.Pop();

            //Here Math.Max is not necessary because they should have same size to compare, but i'm not removing this
            var xSize = Math.Max(FirstStackItem.Size, SecondStackItem.Size);
            var xCurrentLabel = ILHelper.GetLabel(aMethod, instr.Position);
            var xFinalLabel = ILHelper.GetLabel(aMethod, instr.NextPosition);

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (FirstStackItem.IsFloat) //If one item is float then both will
                                    {
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true }); //XMM0 => Value 2
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true }); //XMM1 => Value 1
                                        Core.AssemblerCode.Add(new Cmpss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1, PseudoCode = ComparePseudoOpcodes.LessThan });//Value 1 > Value 2
                                        Core.AssemblerCode.Add(new MovD { SourceReg = Registers.XMM0, DestinationReg = Registers.EBX });
                                        Core.AssemblerCode.Add(new And { DestinationReg = Registers.EBX, SourceRef = "0x1" });
                                        Core.AssemblerCode.Add(new Mov { SourceReg = Registers.EBX, DestinationReg = Registers.ESP, DestinationIndirect = true });
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //Value 2
                                        Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });//Value 2 - Value 1
                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xCurrentLabel + ".false" });
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        //Not equal
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //equal
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".false"));
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });
                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (FirstStackItem.IsFloat)
                                    {
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //Value 2
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });

                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX }); //Value 1
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });

                                        Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new SubWithCarry { DestinationReg = Registers.ECX, SourceReg = Registers.EDX });

                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xCurrentLabel + ".false" });

                                        //Less Than
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //Not Less Than
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".false"));
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                        }

                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(bool));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Cgt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Cgt_Un)]
    public class Cgt_Un : MSIL
    {
        public Cgt_Un(Compiler Cmp)
            : base("cgt_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Cgt just check if value 2 < Value 1, if yes than push 0x1 else push 0x0
            var FirstStackItem = Core.vStack.Pop();
            var SecondStackItem = Core.vStack.Pop();

            //Here Math.Max is not necessary because they should have same size to compare, but i'm not removing this
            var xSize = Math.Max(FirstStackItem.Size, SecondStackItem.Size);
            var xCurrentLabel = ILHelper.GetLabel(aMethod, instr.Position);
            var xFinalLabel = ILHelper.GetLabel(aMethod, instr.NextPosition);

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (FirstStackItem.IsFloat) //If one item is float then both will
                                    {
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true }); //XMM0 => Value 2
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true }); //XMM1 => Value 1
                                        Core.AssemblerCode.Add(new Cmpss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1, PseudoCode = ComparePseudoOpcodes.LessThan });//Value 1 > Value 2
                                        Core.AssemblerCode.Add(new MovD { SourceReg = Registers.XMM0, DestinationReg = Registers.EBX });
                                        Core.AssemblerCode.Add(new And { DestinationReg = Registers.EBX, SourceRef = "0x1" });
                                        Core.AssemblerCode.Add(new Mov { SourceReg = Registers.EBX, DestinationReg = Registers.ESP, DestinationIndirect = true });
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //Value 2
                                        Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });//Value 2 - Value 1
                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xCurrentLabel + ".false" });
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        //Not equal
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //equal
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".false"));
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });
                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (FirstStackItem.IsFloat)
                                    {
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //Value 2
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });

                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX }); //Value 1
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });

                                        Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new SubWithCarry { DestinationReg = Registers.ECX, SourceReg = Registers.EDX });

                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xCurrentLabel + ".false" });

                                        //Less Than
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //Not Less Than
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".false"));
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                        }

                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(bool));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          cli x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Cli : Instruction
    {
        public Cli()
            : base("cli") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Clt MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Clt)]
    public class Clt : MSIL
    {
        public Clt(Compiler Cmp)
            : base("clt", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Clt just check if value 2 > Value 1, if yes than push 0x1 else push 0x0
            var FirstStackItem = Core.vStack.Pop();
            var SecondStackItem = Core.vStack.Pop();

            //Here Math.Max is not necessary because they should have same size to compare, but i'm not removing this
            var xSize = Math.Max(FirstStackItem.Size, SecondStackItem.Size);
            var xCurrentLabel = ILHelper.GetLabel(aMethod, instr.Position);
            var xFinalLabel = ILHelper.GetLabel(aMethod, instr.NextPosition);

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (FirstStackItem.IsFloat) //If one item is float then both will
                                    {
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true }); //XMM0 => Value 2
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true }); //XMM1 => Value 1
                                        Core.AssemblerCode.Add(new Cmpss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1, PseudoCode = ComparePseudoOpcodes.NotLessThanOrEqualTo });//Value 1 < Value 2
                                        Core.AssemblerCode.Add(new MovD { SourceReg = Registers.XMM0, DestinationReg = Registers.EBX });
                                        Core.AssemblerCode.Add(new And { DestinationReg = Registers.EBX, SourceRef = "0x1" });
                                        Core.AssemblerCode.Add(new Mov { SourceReg = Registers.EBX, DestinationReg = Registers.ESP, DestinationIndirect = true });
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //Value 2
                                        Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });//Value 2 - Value 1
                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JG, DestinationRef = xCurrentLabel + ".true" });
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        //Not equal
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //equal
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".true"));
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });
                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (FirstStackItem.IsFloat)
                                    {
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //Value 2
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });

                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX }); //Value 1
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });

                                        Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new SubWithCarry { DestinationReg = Registers.ECX, SourceReg = Registers.EDX });

                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JL, DestinationRef = xCurrentLabel + ".true" });

                                        //Not Less Than
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //Less Than
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".true"));
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                        }

                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(bool));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Clt_Un MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Clt_Un)]
    public class Clt_Un : MSIL
    {
        public Clt_Un(Compiler Cmp)
            : base("clt_un", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            //Clt just check if value 2 > Value 1, if yes than push 0x1 else push 0x0
            var FirstStackItem = Core.vStack.Pop();
            var SecondStackItem = Core.vStack.Pop();

            //Here Math.Max is not necessary because they should have same size to compare, but i'm not removing this
            var xSize = Math.Max(FirstStackItem.Size, SecondStackItem.Size);
            var xCurrentLabel = ILHelper.GetLabel(aMethod, instr.Position);
            var xFinalLabel = ILHelper.GetLabel(aMethod, instr.NextPosition);

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        switch (xSize)
                        {
                            case 1:
                            case 2:
                            case 4:
                                {
                                    if (FirstStackItem.IsFloat) //If one item is float then both will
                                    {
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM0, SourceReg = Registers.ESP, SourceIndirect = true }); //XMM0 => Value 2
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Movss { DestinationReg = Registers.XMM1, SourceReg = Registers.ESP, SourceIndirect = true }); //XMM1 => Value 1
                                        Core.AssemblerCode.Add(new Cmpss { DestinationReg = Registers.XMM0, SourceReg = Registers.XMM1, PseudoCode = ComparePseudoOpcodes.NotLessThanOrEqualTo });//Value 1 < Value 2
                                        Core.AssemblerCode.Add(new MovD { SourceReg = Registers.XMM0, DestinationReg = Registers.EBX });
                                        Core.AssemblerCode.Add(new And { DestinationReg = Registers.EBX, SourceRef = "0x1" });
                                        Core.AssemblerCode.Add(new Mov { SourceReg = Registers.EBX, DestinationReg = Registers.ESP, DestinationIndirect = true });
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //Value 2
                                        Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ESP, SourceIndirect = true });//Value 2 - Value 1
                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JA, DestinationRef = xCurrentLabel + ".true" });
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        //Not equal
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //equal
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".true"));
                                        Core.AssemblerCode.Add(new Assembler.x86.Add { DestinationReg = Registers.ESP, SourceRef = "0x4" });
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });
                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                            case 8:
                                {
                                    if (FirstStackItem.IsFloat)
                                    {
                                    }
                                    else
                                    {
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX }); //Value 2
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EDX });

                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX }); //Value 1
                                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });

                                        Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.EBX, SourceReg = Registers.EAX });
                                        Core.AssemblerCode.Add(new SubWithCarry { DestinationReg = Registers.ECX, SourceReg = Registers.EDX });

                                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JB, DestinationRef = xCurrentLabel + ".true" });

                                        //Not Less Than
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        //Less Than
                                        Core.AssemblerCode.Add(new Label(xCurrentLabel + ".true"));
                                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xFinalLabel });

                                        Core.AssemblerCode.Add(new Label(xFinalLabel));
                                    }
                                }
                                break;
                        }

                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
            Core.vStack.Push(4, typeof(bool));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          cmp x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Cmp : DestinationSourceSize
    {
        public Cmp()
            : base("cmp") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          cmpss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public class Cmpss : DestinationSource
    {
        public ComparePseudoOpcodes PseudoCode { get; set; }

        public Cmpss()
            : base("cmpss") { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            aSW.WriteLine(string.Format("{0} {1}, {2}, 0x{3}", Code, des, src, ((byte)PseudoCode).ToString("X")));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          assembly comment
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler
{
    public class Comment : Instruction
    {
        public readonly string Comments;

        public Comment(string aComment)
            :base ("Comment")
        {
            Comments = aComment;
        }

        public override void FlushText(StreamWriter sw)
        {
            sw.WriteLine("; " + Comments);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.IO;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;

using Atomix.IL;
using Atomix.ILOpCodes;

using Atomix.ILOptimizer;

using Atomix.Assembler;
using Atomix.Assembler.x86;

using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix
{
    public class Compiler
    {
        /// <summary>
        /// The Members which are yet to be build
        /// </summary>
        public Queue<_MemberInfo> QueuedMember;

        /// <summary>
        /// The Members which are already build
        /// </summary>
        private List<_MemberInfo> BuildDefinations;

        /// <summary>
        /// The Dictionary of Build Target method and its label --> Plug
        /// it can also take integer but the Dummy should present which contains that integer
        /// </summary>
        public Dictionary<MethodBase, string> Plugs;

        /// <summary>
        /// It contains all literal string datamember
        /// </summary>
        private Dictionary<string, string> StringTable;

        /// <summary>
        /// The list of implemented Microsoft IL's by our compiler
        /// </summary>
        public Dictionary<ILCode, MSIL> MSIL;

        private List<MethodInfo> Virtuals;
        private bool DoOptimization;
        /// <summary>
        /// Are we building ELF binary?
        /// </summary>
        private bool BuildingApplication;

        public Compiler(bool aDoOptimization)
        {
            ILCompiler.Logger.Write("@Compiler", "Main Compilation Process", "Loading Non-Static Parameters and starting up Compilation Process...");
            QueuedMember = new Queue<_MemberInfo>();
            BuildDefinations = new List<_MemberInfo>();
            Plugs = new Dictionary<MethodBase, string>();
            StringTable = new Dictionary<string, string>();
            Core.vStack = new VirtualStack();
            Core.NasmHeaders = new List<string>();
            Core.DataMember = new List<AsmData>();
            Core.AssemblerCode = new List<Instruction>();
            MSIL = new Dictionary<ILCode, MSIL>();
            Virtuals = new List<MethodInfo>();
            DoOptimization = aDoOptimization;
            Core.StaticLabels = new Dictionary<string, _MemberInfo>();

            ILHelper.Compiler = this;
            ILCompiler.Logger.Write("Parameters Initialized");
        }

        public void Start()
        {
            ILCompiler.Logger.Write("Compiler :: Start()");

            // Load the type of Kernel Start, it depends on CPU Arch. we have choosed.
            var xType = LoadKernel(ILCompiler.CPUArchitecture);

            ILCompiler.Logger.Write(string.Format("{0} Kernel Type Found :: {1}", ILCompiler.CPUArchitecture.ToString(), xType.ToString()));
            // Just find the start method, which is constant label method inside the kernel type
            var xStartup = xType.GetMethod(Helper.StartupMethod, BindingFlags.Static | BindingFlags.Public);

            if (xStartup == null)
            {
                if (BuildingApplication)
                    ILCompiler.Logger.Write("Application has no entry point :: " + Helper.StartupMethod);
                else
                    throw new Exception("No startup found");
            }
            else
                ILCompiler.Logger.Write("Found Startup Method :: " + Helper.StartupMethod);

            // Load our MSIL implementation (basically init it and save into memory)
            LoadMSIL();
            // It just make up the MSIL array, Low and High
            BodyProcesser.Start();
            /*
             * From now onwards we enquque methods, but as you see we do first Enqueue of startup method
             * it is because startup method contains some header code,
             * if it will not be in assembly header than multiboot signature will be disturbed.
             * Just after this we scan plugs and enquque them
             */
            if (xStartup != null)
                QueuedMember.Enqueue(xStartup);

            ScanPlugs();

            /* Compiler Included Code */
            LoadCompilerLibrary();

            ILCompiler.Logger.Write("Enququed Start Method");
            while (QueuedMember.Count > 0)
            {
                // Man we do scarifice to code, first come first process policy is our
                var xMethod = QueuedMember.Dequeue();
                /* Build Only when it is not yet processed mean not in build definations */
                if (!BuildDefinations.Contains(xMethod))
                {
                    // Process MethodBase
                    if (xMethod is MethodBase)
                    {
                        var Method = xMethod as MethodBase;

                        // Check if we want to build it inline assembly
                        if (Method.GetCustomAttribute(typeof(AssemblyAttribute)) != null)
                            ExecutableMethod(Method);
                        else if (Method.GetCustomAttribute(typeof(DllImportAttribute)) != null)
                            ProcessExternalMethod(Method);
                        else
                            ScanMethod(Method);
                    }
                    // Process Type
                    else if (xMethod is Type)
                    {
                        ScanType((Type)xMethod);
                    }
                    // Process FieldInfo
                    else if (xMethod is FieldInfo)
                    {
                        var xField = ((FieldInfo)xMethod);
                        ProcessField(xField);
                    }
                }
            }
        }

        /// <summary>
        /// Loading Microsoft IL's implementations to memory --> I mean list
        /// </summary>
        private void LoadMSIL()
        {
            // Tell logger we are loading msil into memory
            ILCompiler.Logger.Write("Loading MSIL into memory...");
            foreach (Type xType in Assembly.GetExecutingAssembly().GetTypes())
            {
                foreach (var attrib in xType.GetCustomAttributes(typeof(ILOpAttribute)))
                {
                    var Attribute = attrib as ILOpAttribute;
                    if (Attribute != null)
                    {
                        MSIL.Add(Attribute.ILCode, (MSIL)Activator.CreateInstance(xType, this));
                    }
                }
            }
        }

        /// <summary>
        /// Load Kernel startup type in input dll, by scanning Kernel attribute
        /// </summary>
        /// <param name="cpu">The Current target platform</param>
        /// <returns></returns>
        private Type LoadKernel(CPUArch cpu)
        {
            var xAssembly = Assembly.LoadFile(ILCompiler.InputDll);

            /* Search For Kernel Attribute */
            foreach (var xType in xAssembly.GetExportedTypes())
            {
                foreach (var xAttr in xType.CustomAttributes)
                {
                    if (xAttr.AttributeType == typeof(KernelAttribute))
                    {
                        if ((CPUArch)xAttr.ConstructorArguments[0].Value == cpu)
                        {
                            Core.NasmHeaders.Add("global Kernel_Main");
                            Core.NasmHeaders.Add(string.Format("Kernel_Main equ (_Kernel_Main - {0})", xAttr.ConstructorArguments[1].Value));

                            return xType;
                        }
                    }
                    else if (xAttr.AttributeType == typeof(ApplicationAttribute))
                    {
                        if ((CPUArch)xAttr.ConstructorArguments[0].Value == cpu)
                        {
                            BuildingApplication = true;
                            return xType;
                        }
                    }
                }
            }
            throw new Exception("No Input kernel found");
        }

        /// <summary>
        /// This method crawl all assemblies except the compiler and mscorlib
        /// and check for our attributes and add it to attribute list and Enqueue them all =P
        /// </summary>
        private void ScanPlugs()
        {
            var AssembliesLocation = ILCompiler.InputFiles;
            AssembliesLocation.Add(ILCompiler.InputDll);

            foreach (var xFile in AssembliesLocation)
            {
                // Just a basic check if it is not dll than remove it from this list
                // it is basic also because only we dev are going to work on this...and we will work in limit
                // we are not going to hack our own compiler man...so don't worry of this implementations
                if (!xFile.EndsWith(".dll"))
                    AssembliesLocation.Remove(xFile);
            }

            var xAssemblies = new List<Assembly>();
            ILCompiler.Logger.Write("@Compiler", "Reference Scanner", "Scanning References Assemblies");

            foreach (var xLoc in AssembliesLocation)
            {
                // Load the assembly which we want and add it to assemblies list
                var xAss = Assembly.LoadFile(xLoc);
                if (xAss != null)
                {
                    xAssemblies.Add(xAss);
                    //For now i don't want this
                    //It is also because i got error...hehe =P
                    /*
                    foreach (var xRef in xAss.GetReferencedAssemblies())
                    {
                        var xRefAssembly = Assembly.Load(xRef);
                        if (xRef.Name == "mscorlib"
                            || xRef.Name == "CompilerExt"
                            || xRef.Name == "ILCompiler.Assembler")
                            continue;
                        else
                        {
                            xAssemblies.Add(xRefAssembly);
                            ILCompiler.Logger.Write(string.Format("Found Assembly: {0}; {1}", xAss.FullName, xRef.Name));
                        }
                    }*/
                }
            }

            // Now we scan whole source i mean billions of lines kernel code, will be in future so no need to laugh
            ILCompiler.Logger.Write("@Compiler", "Plug Scanner", "Scanning plug Initialized");
            foreach (var xAssembly in xAssemblies)
            {
                // Firstly we scan types for label attribute, well if i tell seriously than it is of no use, but for future implementations
                foreach (var xType in xAssembly.GetTypes())
                {
                    foreach (var xMethod in xType.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static))
                    {
                        // TODO: review the below code
                        foreach (var xAttr in xMethod.CustomAttributes)
                        {
                            if (xAttr.AttributeType == typeof(PlugAttribute))
                            {
                                if ((CPUArch)xAttr.ConstructorArguments[1].Value == ILCompiler.CPUArchitecture)
                                {
                                    var xLbl = (string)xAttr.ConstructorArguments[0].Value;
                                    if (xLbl != "#" && xLbl != "0" && xLbl != string.Empty)
                                        Plugs.Add(xMethod, xLbl);
                                    QueuedMember.Enqueue(xMethod);
                                    ILCompiler.Logger.Write(string.Format(
                                        "<b>Plug Found <u>PlugAttribute</u></b> :: {0}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=>{1}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=>{2}",
                                        xMethod.Name,
                                        xType.FullName,
                                        xAssembly.FullName));
                                }
                            }
                            else if (xAttr.AttributeType == typeof(LabelAttribute))
                            {
                                var xLbl = (string)xAttr.ConstructorArguments[0].Value;
                                if (xLbl != "#" && xLbl != "0" && xLbl != string.Empty)
                                    Core.StaticLabels.Add(xLbl, xMethod);
                                QueuedMember.Enqueue(xMethod);
                                ILCompiler.Logger.Write(string.Format(
                                        "<b>Plug Found <u>LabelAttribute</u></b> :: {0}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=>{1}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=>{2}",
                                        xMethod.Name,
                                        xType.FullName,
                                        xAssembly.FullName));
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Process the field and add to datamember
        /// </summary>
        /// <param name="aField">The field to process</param>
        private void ProcessField(FieldInfo aField)
        {
            var xName = aField.FullName();
            int xTheSize = 4;

            Type xFieldTypeDef = aField.FieldType;
            if (!xFieldTypeDef.IsClass || xFieldTypeDef.IsValueType)
                xTheSize = aField.FieldType.SizeOf();

            // We use marshal and read c# assembly memory to get the value of static field
            byte[] xData = new byte[xTheSize];
            try
            {
                object xValue = aField.GetValue(null);
                if (xValue != null)
                {
                    try
                    {
                        xData = new byte[xTheSize];
                        if (xValue.GetType().IsValueType)
                            for (int x = 0; x < xTheSize; x++)
                                xData[x] = Marshal.ReadByte(xValue, x);
                    }
                    catch
                    {
                        // Do nothing, if error...we won't care it
                    }
                }
            }
            catch
            {
                // Do nothing, if error...we won't care it
            }
            // Add it to data member
            Core.InsertData(new AsmData(xName, xData));

            // Add it build definations
            BuildDefinations.Add(aField);
        }

        private void LoadCompilerLibrary()
        {
            var xMethod = typeof(VTable).GetMethod("GetEntry", BindingFlags.Public | BindingFlags.Static);

            Core.StaticLabels.Add(Helper.lblVTable, xMethod);
            QueuedMember.Enqueue(xMethod);
        }

        private void ProcessExternalMethod(MethodBase aMethod)
        {
            ILCompiler.Logger.Write("@Processor", aMethod.FullName(), "Processing External Method");

            if (!aMethod.IsStatic)
                throw new Exception("Non-static extern fields not supported");

            var aAttributeData = (DllImportAttribute)aMethod.GetCustomAttribute(typeof(DllImportAttribute));
            if (aAttributeData == null)
                throw new Exception("[DllImport]: Invalid Build");

            string xLibName = aAttributeData.Value;
            string xMethodLabel = aMethod.FullName();
            string xMethodName = aAttributeData.EntryPoint == null ? aMethod.Name : aAttributeData.EntryPoint;
            int xCalliConvention = (int)aAttributeData.CallingConvention;
            bool IsAtomixCompiled = (xCalliConvention == (int)aMethod.CallingConvention);

            var xParms = aMethod.GetParameters();

            /*
             * For now assume normal calli method
             * - Push Library Name
             * - Push Function Name
             * - Call Kernel API
             * - Jump to function address
             */
            Core.AssemblerCode.Add(new Label(xMethodLabel));

            // standard calli header
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EBP });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EBP, SourceReg = Registers.ESP });

            // load and get address of external function
            Core.AssemblerCode.Add(new Push { DestinationRef = AddStringData(xLibName) });
            Core.AssemblerCode.Add(new Push { DestinationRef = AddStringData(xMethodName) });

            Core.AssemblerCode.Add(new Call(Helper.lblImportDll, true));
            Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });

            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });

            int ArgSize = ILHelper.GetArgumentsSize(aMethod);
            int xReturnSize = ILHelper.GetReturnTypeSize(aMethod);
            int xRetSize = (ArgSize - xReturnSize);

            #region _CALLI_HEADER_
            if (IsAtomixCompiled)
            {

                // push the arguments from left to right
                for (int i = 0; i < xParms.Length; i++)
                {
                    int xDisplacement = ILHelper.GetArgumentDisplacement(aMethod, i);
                    int xArgSize = aMethod.GetParameters()[i].ParameterType.SizeOf().Align();

                    for (int j = 0; j < (xArgSize / 4); j++)
                    {
                        Core.AssemblerCode.Add(
                            new Push
                            {
                                DestinationReg = Registers.EBP,
                                DestinationIndirect = true,
                                DestinationDisplacement = xDisplacement - (j * 4)
                            });
                    }
                }

                if (xRetSize < 0)
                {
                    Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + (-xRetSize).ToString("x") });
                    xRetSize = 0;
                }
            }
            else if (xCalliConvention == (int)CallingConvention.StdCall)
            {
                // push arguments to the stack from right to left
                for (int i = xParms.Length - 1; i >= 0; i--)
                {
                    int xDisplacement = ILHelper.GetArgumentDisplacement(aMethod, i);
                    int xArgSize = aMethod.GetParameters()[i].ParameterType.SizeOf().Align();

                    for (int j = 0; j < (xArgSize / 4); j++)
                    {
                        Core.AssemblerCode.Add(
                            new Push
                            {
                                DestinationReg = Registers.EBP,
                                DestinationIndirect = true,
                                DestinationDisplacement = xDisplacement - (j * 4)
                            });
                    }
                }
            }
            #endregion

            // Call the function
            Core.AssemblerCode.Add(new Call("EAX"));

            #region _CALLI_FOOTER_
            if (xReturnSize > 0)
            {
                var xOffset = ILHelper.GetResultCodeOffset(xReturnSize, ArgSize);
                if (IsAtomixCompiled)
                {
                    // For return type Method
                    for (int i = 0; i < xReturnSize / 4; i++)
                    {
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                        Core.AssemblerCode.Add(new Mov
                        {
                            DestinationReg = Registers.EBP,
                            DestinationIndirect = true,
                            DestinationDisplacement = (xOffset + (i * 4)),
                            SourceReg = Registers.EAX
                        });
                    }
                }
                else if (xCalliConvention == (int)CallingConvention.StdCall)
                {
                    if (xReturnSize > 8)
                        throw new Exception("[Extern]: Unsupported Return Size for StdCall");

                    Core.AssemblerCode.Add(new Mov
                    {
                        DestinationReg = Registers.EBP,
                        DestinationIndirect = true,
                        DestinationDisplacement = xOffset,
                        SourceReg = Registers.EAX
                    });

                    if (xReturnSize == 8)
                    {
                        Core.AssemblerCode.Add(new Mov
                        {
                            DestinationReg = Registers.EBP,
                            DestinationIndirect = true,
                            DestinationDisplacement = (xOffset + 4),
                            SourceReg = Registers.EAX
                        });
                    }
                }
            }
            #endregion

            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceRef = "0x0" });
            Core.AssemblerCode.Add(new Leave());
            Core.AssemblerCode.Add(new Ret { Address = (byte)xRetSize });

            BuildDefinations.Add(aMethod);
        }

        static int CurrentLabel = 0;
        public string AddStringData(string aStr)
        {
            if (StringTable.ContainsKey(aStr))
                return StringTable[aStr];

            var xLabel = "StringContent_" + CurrentLabel.ToString().PadLeft(4, '0');
            StringTable.Add(aStr, xLabel);
            CurrentLabel++;

            return xLabel;
        }

        public void FlushStringDataTable()
        {
            int CurrentLabel = 0;
            string Content, str;
            foreach(var xObj in StringTable)
            {
                str = xObj.Key;
                Content = xObj.Value;
                Encoding xEncoding = Encoding.Unicode;
                var xBytecount = xEncoding.GetByteCount(str);
                var xObjectData = new byte[(xBytecount) + 0x10]; // 0xC is object data offset

                Array.Copy(BitConverter.GetBytes(ILHelper.GetTypeID(typeof(string))), 0, xObjectData, 0, 4);
                Array.Copy(BitConverter.GetBytes(0x1), 0, xObjectData, 4, 4);
                Array.Copy(BitConverter.GetBytes(xObjectData.Length), 0, xObjectData, 8, 4);
                Array.Copy(BitConverter.GetBytes(str.Length), 0, xObjectData, 12, 4);
                Array.Copy(xEncoding.GetBytes(str), 0, xObjectData, 16, xBytecount);

                Core.DataMember.Add(new AsmData(Content, xObjectData));
                CurrentLabel++;
            }
        }

        /// <summary>
        /// Build the Inline assembly method, how? quite simple just invoke that method
        /// So, remember we want use parameters of an assembly method via c#, we have to be completely literal
        /// </summary>
        /// <param name="aMethod"></param>
        private void ExecutableMethod(MethodBase aMethod)
        {
            ILCompiler.Logger.Write("@Processor", aMethod.FullName(), "Scanning Inline Assembly Method()");
            string xMethodLabel = aMethod.FullName();

            TryToMakeGlobalSymbol(aMethod);

            Core.AssemblerCode.Add(new Label(xMethodLabel));

            var Attribute = (AssemblyAttribute)aMethod.GetCustomAttribute(typeof(AssemblyAttribute));
            var NeedCalliHeader = Attribute.NeedCalliHeader;

            /* Well we check if we assign any return size than it means we are lazy
             * and we want compiler to add calli and return code.
             */
            if (NeedCalliHeader)
            {
                Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EBP });
                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EBP, SourceReg = Registers.ESP });
            }

            /* Do Invoke here */
            aMethod.Invoke(null, new object[aMethod.GetParameters().Length]);
            ILCompiler.Logger.Write("Method Successfully Invoked()");

            if (NeedCalliHeader)
            {
                byte RetSize = (byte)Math.Max(0, ILHelper.GetArgumentsSize(aMethod) - ILHelper.GetReturnTypeSize(aMethod));

                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceRef = "0x0" });
                Core.AssemblerCode.Add(new Leave());
                Core.AssemblerCode.Add(new Ret { Address = (byte)RetSize });
            }

            BuildDefinations.Add(aMethod);
            ILCompiler.Logger.Write("Method Build Done()");
        }

        private static string[] RestrictedAssembliesName =
            {
                "mscorlib",
                "System",
                Assembly.GetExecutingAssembly().GetName().Name
            };

        /// <summary>
        /// Scan the normal method and find inline calls of virtual or real method to add it into queue
        /// After that Process method and add its assembly to main Array
        /// </summary>
        /// <param name="aMethod">The normal mathod =)</param>
        private void ScanMethod(MethodBase aMethod)
        {
            // Just a basic patch to fix Null reference exception
            var xBody = aMethod.GetMethodBody();

            var xAssemblyName  = aMethod.DeclaringType.Assembly.GetName().Name;
            if (RestrictedAssembliesName.Contains(xAssemblyName) && Plugs.ContainsValue(aMethod.FullName()))
                return;

            if (ILHelper.IsDelegate(aMethod.DeclaringType))
            {
                ProcessDelegate(aMethod);
                return;
            }

            if (xBody == null) // Don't try to build null method
                return;

            // Tell logger that we are processing a method with given name and declaring type
            // Well declaring type is necessary because when we have a plugged method than
            // Its full name is the plugged value so we will not get where the plug is implemented
            // So declaring type help us to determine that
            ILCompiler.Logger.Write("@Processor", aMethod.FullName(), "Scanning Method()");
            ILCompiler.Logger.Write("Type: " + aMethod.DeclaringType.FullName);
            ILCompiler.Logger.Write("Assembly: " + xAssemblyName);

            /* Scan Method for inline virtual or real methods call */
            var xParams = aMethod.GetParameters();
            var xParamTypes = new Type[xParams.Length];

            for (int i = 0; i < xParams.Length; i++)
            {
                xParamTypes[i] = xParams[i].ParameterType;
                QueuedMember.Enqueue(xParamTypes[i]);
            }

            bool DynamicMethod = (aMethod.DeclaringType == null);

            if (!DynamicMethod)
                QueuedMember.Enqueue(aMethod.DeclaringType);

            if (aMethod is MethodInfo)
                QueuedMember.Enqueue(((MethodInfo)aMethod).ReturnType);

            if (!DynamicMethod && aMethod.IsVirtual)
            {
                #warning Need to implement currently
            }

            /* Process method and get out its IL's array */
            // @Newlabels:   New labels is the branches where we have to assign method
            //               a label for branch/call IL's operations to perform.
            //               we make its array while making the IL's array so its make our task easier
            List<int> NewLabels = new List<int>();
            var OpCodes = aMethod.Process(NewLabels);

            // Here seems to be going something wrong
            ILCompiler.Logger.Write ("MSIL Codes Loaded... Count::" + OpCodes.Count);

            string xMethodLabel = aMethod.FullName();

            /* Method begin */
            Core.AssemblerCode.Add(new Label(xMethodLabel));

            TryToMakeGlobalSymbol(aMethod);

            Core.AssemblerCode.Add(new Comment(Worker.OPTIMIZATION_START_FLAG));
            if (aMethod.IsStatic && aMethod is ConstructorInfo)
            {
                string aData = "cctor_" + xMethodLabel;
                Core.InsertData(new AsmData(aData, new byte[] { 0x00 }));
                Core.AssemblerCode.Add(new Cmp() { DestinationRef = aData, DestinationIndirect = true, SourceRef = "0x0", Size = 8 });
                Core.AssemblerCode.Add(new Jmp() { Condition = ConditionalJumpEnum.JE, DestinationRef = Label.PrimaryLabel + ".Load" });
                /* Footer of method */
                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceRef = "0x0" });
                Core.AssemblerCode.Add(new Ret());

                Core.AssemblerCode.Add(new Label(".Load"));
                Core.AssemblerCode.Add(new Mov() { DestinationRef = aData, DestinationIndirect = true, SourceRef = "0x1", Size = 8 });
            }
            /* Calli instructions */
            Core.AssemblerCode.Add(new Push() { DestinationReg = Registers.EBP });
            Core.AssemblerCode.Add(new Mov() { DestinationReg = Registers.EBP, SourceReg = Registers.ESP });

            /* Calculate Method Variables Size */
            int Size = (from item in xBody.LocalVariables
                        select item.LocalType.SizeOf().Align()).Sum();

            if (Size > 0)
            {
                // Make a space for local variables
                Core.AssemblerCode.Add(new Sub { DestinationReg = Registers.ESP, SourceRef = "0x" + Size.Align().ToString("X") });
            }

            ILCompiler.Logger.Write("Listening OpCodes");

            /* Exceute IL Codes */
            foreach (var Op in OpCodes)
            {
                // Check if we need exception to push?
                var xNeedsExceptionPush = (Op.Ehc != null) && (((Op.Ehc.HandlerOffset > 0 && Op.Ehc.HandlerOffset == Op.Position) || ((Op.Ehc.Flags & ExceptionHandlingClauseOptions.Filter) > 0 && Op.Ehc.FilterOffset > 0 && Op.Ehc.FilterOffset == Op.Position)) && (Op.Ehc.Flags == ExceptionHandlingClauseOptions.Clause));

                ILCompiler.Logger.Write(Op.ToString() + "; Stack Count => " + Core.vStack.Count);
                // Check if current position inside the list of label list, if yes than break label and make a new one
                if (NewLabels.Contains(Op.Position))
                {
                    var xLbl = new Label(ILHelper.GetLabel(aMethod, Op.Position));
                    if (!Core.AssemblerCode.Contains(xLbl))
                        Core.AssemblerCode.Add(xLbl);
                }

                // If catch IL here than push current error so, that catch IL pop and do what it want
                if (xNeedsExceptionPush)
                {
                    Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });
                    Core.AssemblerCode.Add(new Call (Helper.lblGetException, true));
                    Core.vStack.Push(4, typeof(Exception));
                }

                // Well this is just to comment whole output Assembly
                if (!DoOptimization)
                    Core.AssemblerCode.Add(new Comment(Op.ToString() + "; " + Core.vStack.Count));

                // Check if this IL is in out implementation
                if (MSIL.ContainsKey(Op.Code))
                {
                    // If yes than execute it
                    MSIL[Op.Code].Execute(Op, aMethod);
                }
                else
                    // If it is not implementation than throw error while compilation
                    throw new Exception(Op.ToString() + "; " + xMethodLabel);
                #region Queue Inline calls
                if (Op is OpMethod)
                {
                    QueuedMember.Enqueue(((OpMethod)Op).Value);
                }
                else if (Op is OpType)
                {
                    QueuedMember.Enqueue(((OpType)Op).Value);
                }
                else if (Op is OpField)
                {
                    QueuedMember.Enqueue(((OpField)Op).Value.DeclaringType);
                    if (((OpField)Op).Value.IsStatic)
                    {
                        QueuedMember.Enqueue(((OpField)Op).Value);
                    }
                }
                else if (Op is OpToken)
                {
                    var x = ((OpToken)Op);
                    if (x.ValueIsType)
                    {
                        QueuedMember.Enqueue(x.ValueType);
                    }

                    if (x.ValueIsField)
                    {
                        QueuedMember.Enqueue(x.ValueField.DeclaringType);
                        if (x.ValueField.IsStatic)
                        {
                            QueuedMember.Enqueue(x.ValueField);
                        }
                    }
                }
                #endregion
            }
            // End the method and return method, without exception
            Core.AssemblerCode.Add(new Label(xMethodLabel + ".End"));
            // We assume that if the ecx is 0x0 then the method is done without any exception
            // it can be assumed by test instruction followed by conditional jump while calling a function
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceRef = "0x0" });

            Core.AssemblerCode.Add(new Label(xMethodLabel + ".Error"));
            // Now below code save the return value to EBP varaible
            // And calculate size
            int ArgSize = ILHelper.GetArgumentsSize(aMethod);

            int ReturnSize = ILHelper.GetReturnTypeSize(aMethod);
            if (ReturnSize > 0)
            {
                // For return type Method
                var xOffset = ILHelper.GetResultCodeOffset(ReturnSize, ArgSize);
                for (int i = 0; i < ReturnSize / 4; i++)
                {
                    Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                    Core.AssemblerCode.Add(new Mov
                    {
                        DestinationReg = Registers.EBP,
                        DestinationIndirect = true,
                        DestinationDisplacement = (int)(xOffset + ((i + 0) * 4)),
                        SourceReg = Registers.EAX
                    });
                }
            }
            Core.AssemblerCode.Add(new Comment(Worker.OPTIMIAZTION_END_FLAG));

            byte RetSize = (byte)Math.Max(0, ILHelper.GetArgumentsSize(aMethod) - ILHelper.GetReturnTypeSize(aMethod));

            // Leave this method mean regain original EBP and ESP offset
            Core.AssemblerCode.Add(new Leave());
            // Return to parent method with given stack offset
            Core.AssemblerCode.Add(new Ret { Address = RetSize });

            // Add this method to build definations so we will not build it again
            BuildDefinations.Add(aMethod);

            // And log it
            ILCompiler.Logger.Write("Method Build Done()");
        }
        /// <summary>
        /// We just scan type for to Queued methods
        /// </summary>
        /// <param name="aType">The type need to scan</param>
        private void ScanType(Type aType)
        {
            if (aType.BaseType != null)
                QueuedMember.Enqueue(aType.BaseType);

            foreach (var xCctor in aType.GetConstructors(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public))
            {
                if (xCctor.DeclaringType == aType)
                    QueuedMember.Enqueue(xCctor);
            }

            foreach (var xAB in aType.GetMethods())
            {
                /* For abstract methods conditions are :-
                 * 1) Its base defination type is not its declaring type
                 * 2) Its base defination should be Abstract
                 * 3) Its declaring type should not be abstract
                 * 4) Method Body should not be null
                 */
                if (xAB.GetBaseDefinition().DeclaringType != xAB.DeclaringType &&
                    xAB.GetBaseDefinition().IsAbstract &&
                    !xAB.DeclaringType.IsAbstract)
                {
                    QueuedMember.Enqueue(xAB);
                    Virtuals.Add(xAB);
                }
            }
            BuildDefinations.Add(aType);
        }

        private void TryToMakeGlobalSymbol(MethodBase aMethod)
        {
            var xAssemblyName = aMethod.DeclaringType.Assembly.GetName().Name;
            if (aMethod.IsPublic &&
                aMethod.DeclaringType.IsVisible &&
                !RestrictedAssembliesName.Contains(xAssemblyName))
            {
                Core.NasmHeaders.Add("global " + aMethod.FullName());
            }
        }

        private void VTableFlush()
        {
            uint xUID = 0;

            var xDict = new Dictionary<int, List<MethodInfo>>();
            foreach (var xV in Virtuals)
            {
                if (!xV.GetBaseDefinition().IsAbstract) continue;

                var xTypeID = ILHelper.GetTypeID(xV.DeclaringType);
                if (!xDict.ContainsKey(xTypeID))
                    xDict[xTypeID] = new List<MethodInfo>();
                xDict[xTypeID].Add(xV);
            }

            /*
             * Array of Entries
             *      - Size of entry in DWORD
             *      - TypeID
             *      - ARRAY OF {METHOD_ID, LABEL}
             *      - Zero at end
             */

            var xVTableData = new List<string>();
            foreach(var xItem in xDict)
            {
                int xTypeID = xItem.Key;
                int xSize = 3 + (xItem.Value.Count * 2);
                xVTableData.Add(xSize.ToString());
                xVTableData.Add(xTypeID.ToString());

                foreach(var yItem in xItem.Value)
                {
                    string xLabel = yItem.FullName();
                    xUID = (uint)((MethodBase)yItem.GetBaseDefinition()).GetHashCode();
                    xVTableData.Add(xUID.ToString());
                    xVTableData.Add(xLabel);
                }
                xVTableData.Add("0");
            }
            xVTableData.Add("0");
            Core.DataMember.Add(new AsmData("__VTable_Flush__", xVTableData.ToArray()));
        }

        private void ProcessDelegate(MethodBase xMethod)
        {
            var lbl = xMethod.FullName();
            var lbl_exception = lbl + ".Error";
            var lbl_end = lbl + ".End";

            Core.AssemblerCode.Add(new Label(lbl));

            // Calli header
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EBP });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EBP, SourceReg = Registers.ESP });

            if (lbl.Contains("ctor"))
            {
                // Load Argument
                ((Ldarg)MSIL[ILCode.Ldarg]).Execute2(0, xMethod);
                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EBX });

                ((Ldarg)MSIL[ILCode.Ldarg]).Execute2(2, xMethod); // The pointer
                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EBX, SourceRef = "0xC" });
                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EBX, DestinationIndirect = true, SourceReg = Registers.EAX });

                ((Ldarg)MSIL[ILCode.Ldarg]).Execute2(1, xMethod); // The Object
                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EBX, SourceRef = "0x4" });
                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EBX, DestinationIndirect = true, SourceReg = Registers.EAX });

                // calli footer
                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceRef = "0x0" });
                Core.AssemblerCode.Add(new Leave());
                Core.AssemblerCode.Add(new Ret { Address = 0xC }); // Memory location + Object + Intptr
            }
            else if (lbl.Contains("Invoke"))
            {
                // Load Reference
                ((Ldarg)MSIL[ILCode.Ldarg]).Execute2(0, xMethod);

                Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EAX, SourceRef = "0xC" });

                // If it is a non static field than get its parent Type memory location (object in constructor)
                if (!xMethod.IsStatic)
                    Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX, DestinationDisplacement = 0x4, DestinationIndirect = true });

                var xParms = xMethod.GetParameters();
                int xSize = ILHelper.GetArgumentsSize(xMethod);

                // Load arguments to throw
                int xArgSize;
                for (ushort i = 1; i <= xParms.Length; i++)
                {
                    // New Code
                    int xDisplacement = ILHelper.GetArgumentDisplacement(xMethod, i);

                    if (xMethod.IsStatic)
                        xArgSize = xMethod.GetParameters()[i].ParameterType.SizeOf().Align();
                    else
                        xArgSize = xMethod.GetParameters()[i - 1].ParameterType.SizeOf().Align();

                    for (int j = 0; j < (xArgSize / 4); j++)
                    {
                        Core.AssemblerCode.Add(
                            new Push
                            {
                                DestinationReg = Registers.EBP,
                                DestinationIndirect = true,
                                DestinationDisplacement = xDisplacement - (j * 4)
                            });
                    }
                }

                // Call the function
                Core.AssemblerCode.Add(new Call("[EAX]"));

                // Check for anytype of exception
                Core.AssemblerCode.Add(new Test { DestinationReg = Registers.ECX, SourceRef = "0x2" });
                Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = lbl_exception });

                // calli footer
                Core.AssemblerCode.Add(new Label(lbl_end));
                Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceRef = "0x0" });

                Core.AssemblerCode.Add(new Label(lbl_exception));
                int xReturnSize = ILHelper.GetReturnTypeSize(xMethod);

                if (xReturnSize > 0)
                {
                    // For return type Method
                    var xOffset = ILHelper.GetResultCodeOffset(xReturnSize, xSize);
                    for (int i = 0; i < xReturnSize / 4; i++)
                    {
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                        Core.AssemblerCode.Add(new Mov
                        {
                            DestinationReg = Registers.EBP,
                            DestinationIndirect = true,
                            DestinationDisplacement = (int)(xOffset + ((i + 0) * 4)),
                            SourceReg = Registers.EAX
                        });
                    }
                }

                byte xRetSize = (byte)Math.Max(0, xSize - xReturnSize);

                Core.AssemblerCode.Add(new Leave());
                Core.AssemblerCode.Add(new Ret { Address = xRetSize }); // Parameter + Memory
            }

            BuildDefinations.Add(xMethod);
        }

        private static void BssSectionHeader(StreamWriter aSW)
        {
            aSW.WriteLine();
            aSW.WriteLine("section .bss");
        }

        private static void DataSectionHeader(StreamWriter aSW)
        {
            aSW.WriteLine();
            aSW.WriteLine("section .data");
        }

        private static void TextSectionHeader(StreamWriter aSW)
        {
            aSW.WriteLine();
            aSW.WriteLine("section .text");
        }

        public void FlushAsmFile()
        {
            // Flush String Data table
            FlushStringDataTable();

            VTableFlush();

            // Add a label of Kernel End, it is used by our heap to know from where it starts allocating memory
            Core.AssemblerCode.Add(new Label("Compiler_End"));

            using (var xWriter = new StreamWriter(ILCompiler.OutputFile, false))
            {
                foreach (var Header in Core.NasmHeaders)
                    xWriter.WriteLine(Header);

                // if any BSS data is contained or not
                if (Core.DataMemberBssSegmentIndex > 0)
                    BssSectionHeader(xWriter);

                // Firstly add datamember
                bool IsFlagged = true;
                foreach (var AsmData in Core.DataMember)
                {
                    if (AsmData.IsBssData == false && IsFlagged == true)
                    {
                        IsFlagged = false;
                        DataSectionHeader(xWriter);
                    }
                    AsmData.FlushText(xWriter);
                }

                TextSectionHeader(xWriter);

                if (DoOptimization)
                {
                    //Try to execute optimizer
                    try { Core.AssemblerCode = new Worker(Core.AssemblerCode).Start(); }
                    catch (Exception e) { Console.WriteLine("Optimization-Exception:" + e.ToString()); }
                }

                foreach (var instruction in Core.AssemblerCode)
                {
                    if (instruction is Label)
                    {
                        xWriter.WriteLine();
                        instruction.FlushText(xWriter);
                    }
                    else
                    {
                        xWriter.Write("     ");
                        if (instruction is Call)
                        {
                            var InstCall = instruction as Call;
                            if (InstCall.FunctionLabel)
                            {
                                Call.FlushText(xWriter, (Core.StaticLabels[InstCall.Address] as MethodBase).FullName());
                                continue;
                            }
                        }
                        instruction.FlushText(xWriter);
                    }
                }
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          misc function file
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public enum ComparePseudoOpcodes : byte
    {
        Equal = 0,
        LessThan = 1,
        LessThanOrEqualTo = 2,
        Unordered = 3,
        NotEqual = 4,
        NotLessThan = 5,
        NotLessThanOrEqualTo = 6,
        Ordered = 7
    };

    public enum ConditionalJumpEnum
    {
        JMP, JO, JNO, JS, JNS, JE, JZ, JNE, JNZ, JB, JNAE, JC,
        JNB, JAE, JNC, JBE, JNA, JA, JNBE, JL, JNGE, JGE, JNL,
        JLE, JNG, JG, JNLE, JP, JPE, JNP, JPO, JCXZ, JECXZ,
    };

    public enum ConversionCode
    {
        /// <summary>
        /// AL -> AX
        /// </summary>
        Byte_2_Word,
        /// <summary>
        /// AX -> EAX
        /// </summary>
        Word_2_Long,
        /// <summary>
        /// AX -> DX:AX
        /// </summary>
        SignedWord_2_SignedDoubleWord,
        /// <summary>
        /// EAX -> EAX:EDX
        /// </summary>
        SignedLong_2_SignedDoubleLong,
        /// <summary>
        /// EAX -> EAX:EDX
        /// </summary>
        SignedDWord_2_SignedQWord
    };

    public class Const
    {
        public static string SizeToString(byte aSize)
        {
            switch (aSize)
            {
                case 8:
                    return "byte";
                case 16:
                    return "word";
                case 32:
                    return "dword";
                case 64:
                    return "qword";
                default:
                    return "dword";
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conversion type x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.IO;

namespace Atomix.Assembler.x86
{
    public class Conversion : Instruction
    {
        // Based on: http://docs.oracle.com/cd/E19455-01/806-3773/6jct9o0an/index.html

        public ConversionCode Type { get; set; }

        public Conversion()
            : base("conversion") { }

        public override void FlushText(StreamWriter sw)
        {
            switch (Type)
            {
                case ConversionCode.Byte_2_Word:
                    sw.WriteLine("cbtw");
                    break;
                case ConversionCode.Word_2_Long:
                    sw.WriteLine("cwtl");
                    break;
                case ConversionCode.SignedWord_2_SignedDoubleWord:
                    sw.WriteLine("cwtd");
                    break;
                case ConversionCode.SignedLong_2_SignedDoubleLong:
                    sw.WriteLine("cltd");
                    break;
                case ConversionCode.SignedDWord_2_SignedQWord:
                    sw.WriteLine("cdq");
                    break;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          cvttss2si x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Cvttss2si : DestinationSourceSize
    {
        public Cvttss2si()
            : base("cvttss2si") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          DestinationSource type Instructions abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public abstract class DestinationSource : Instruction
    {
        public Registers? DestinationReg;
        public string DestinationRef;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;

        public Registers? SourceReg;
        public string SourceRef;
        public bool SourceIndirect;
        public int? SourceDisplacement;

        public DestinationSource(string aMnemonic)
            : base(aMnemonic)  { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            aSW.WriteLine(string.Format("{0} {1}, {2}", Code, des, src));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          DestinationSourceSize type Instructions abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public abstract class DestinationSourceSize : Instruction
    {
        public Registers? DestinationReg;
        public string DestinationRef;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;

        public Registers? SourceReg;
        public string SourceRef;
        public bool SourceIndirect;
        public int? SourceDisplacement;

        public byte Size;

        public DestinationSourceSize(string aMnemonic)
            : base(aMnemonic)  { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            aSW.WriteLine(string.Format("{0} {3} {1}, {2}", Code, des, src, Const.SizeToString(Size)));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          div x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Div : OnlyDestination
    {
        public Div()
            : base("div") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          divss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Divss : DestinationSourceSize
    {
        public Divss()
            : base("divss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Endfinally MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.CompilerExt;

namespace Atomix.IL
{
    [ILOp(ILCode.Endfinally)]
    public class Endfinally : MSIL
    {
        public Endfinally(Compiler Cmp)
            : base("endfinally", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        //Nothing here
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fadd x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fadd : OnlyDestination
    {
        public Fadd()
            : base("fadd") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fdiv x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fdiv : OnlyDestination
    {
        public Fdiv()
            : base("fdiv") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fidiv x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fidiv : OnlyDestination
    {
        public Fidiv()
            : base("fidiv") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fisttp x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fisttp : OnlyDestination
    {
        public Fisttp()
            : base("fisttp") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fld x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fld : OnlyDestination
    {
        public Fld()
            : base("fld") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fmul x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fmul : OnlyDestination
    {
        public Fmul()
            : base("fmul") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fstp x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fstp : OnlyDestination
    {
        public Fstp()
            : base("fstp") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fsub x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fsub : OnlyDestination
    {
        public Fsub()
            : base("fsub") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          helper class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;

using System.Runtime.InteropServices;

namespace Atomix.Assembler
{
    public static class AssemblyHelper
    {
        public static VirtualStack vStack;
        public static List<string> NasmHeaders;
        public static List<AsmData> DataMember;
        public static List<Instruction> AssemblerCode;
        public static Dictionary<string, _MemberInfo> StaticLabels;

        public static int DataMemberBssSegmentIndex
        {
            get;
            private set;
        }

        public static void InsertData(AsmData aAsmData)
        {
            if (DataMember == null)
                throw new Exception("DataMember not initalized");

            bool IsBssData = aAsmData.IsBssData;
            if (IsBssData)
                DataMember.Insert(DataMemberBssSegmentIndex++, aAsmData);
            else
                DataMember.Add(aAsmData);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          idiv x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class IDiv : OnlyDestination
    {
        public IDiv()
            : base("idiv") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler Implemented MSIL Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomix
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
    public class ILOpAttribute : Attribute
    {
        public readonly ILCode ILCode;

        // Just its presense is necessary
        public ILOpAttribute(ILCode aIL)
        {
            ILCode = aIL;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler Entrypoint
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;
using System.IO;
using Atomix.CompilerExt;

namespace Atomix
{
    public class ILCompiler
    {
        /// <summary>
        /// Kernel Main Dll
        /// </summary>
        public static string InputDll;

        /// <summary>
        /// Other Assembly goes here
        /// </summary>
        public static List<string> InputFiles;

        /// <summary>
        /// Build Output Directory
        /// </summary>
        public static string OutputFile;

        /// <summary>
        /// CPU Architechture i.e. x86, ARM, x64
        /// </summary>
        public static CPUArch CPUArchitecture = CPUArch.none;

        /// <summary>
        /// This logs our every step
        /// </summary>
        public static Logger Logger;

        public static void Main(string[] args)
        {
            InputFiles = new List<string>();
            bool DoLogging = false;
            bool DoOptimization = false;
            try
            {
                #region Parsing
                if (args.Length > 0)
                {
                    for (int i = 0; i < args.Length; i++)
                    {
                        if (args[i] == "-cpu")
                        {
                            switch (args[i + 1])
                            {
                                case "x86":
                                    CPUArchitecture = CPUArch.x86;
                                    break;
                                case "x64":
                                    CPUArchitecture = CPUArch.x64;
                                    break;
                                case "arm":
                                    CPUArchitecture = CPUArch.ARM;
                                    break;
                                default:
                                    CPUArchitecture = CPUArch.none;
                                    break;
                            }
                            i++;
                        }
                        else if (args[i] == "-o")
                        {
                            OutputFile = args[i + 1];
                            i++;
                        }
                        else if (args[i] == "-d")
                        {
                            DoLogging = true;
                        }
                        else if (args[i] == "-i")
                        {
                            var xInput = args[i + 1].Split(';');

                            InputDll = xInput[0];

                            if (!File.Exists(InputDll))
                                throw new Exception("Kernel Assembly not found");

                            for (int j = 1; j < xInput.Length; j++)
                            {
                                if (!File.Exists(xInput[j]))
                                    throw new Exception("Some of binded files does not exist");

                                if (!Path.IsPathRooted(InputDll))
                                    InputFiles.Add(Path.Combine(Environment.CurrentDirectory, xInput[j]));
                                else
                                    InputFiles.Add(xInput[j]);
                            }
                            i++;
                        }
                        else if (args[i] == "-optimize")
                        {
                            DoOptimization = true;
                        }
                    }

                }
                else
                {
                    throw new Exception("No Input Parameter");
                }
                #endregion

                if (CPUArchitecture == CPUArch.none)
                    throw new Exception("No Output Platform Selected");

                if (InputDll == string.Empty || InputDll == null)
                    throw new Exception("No input kernel assembly");
                else if (!Path.IsPathRooted(InputDll))
                    InputDll = Path.Combine(Environment.CurrentDirectory, InputDll);

                if (OutputFile == string.Empty || OutputFile == null)
                    OutputFile = Environment.CurrentDirectory;
                else
                    OutputFile = Path.Combine(Environment.CurrentDirectory, OutputFile);

                //Create missing directory
                Directory.CreateDirectory(Path.GetDirectoryName(OutputFile));

                /* Building Starts Here */
                Logger = new Logger(OutputFile, DoLogging);
                Logger.Write("@ILCompiler", "Initialized parameters", "Building Started...");
                Logger.Write("Architecture     : " + CPUArchitecture);
                Logger.Write("Output Directory : " + OutputFile);
                Logger.Write("Input Assembly   : " + InputDll);
                Compiler xCompiler = new Compiler(DoOptimization);
                try
                {
                    xCompiler.Start();
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.ToString());
                }

                Logger.Dump();
                xCompiler.FlushAsmFile();
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler Helper Function
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Runtime.InteropServices;

using Atomix.CompilerExt;
using Atomix.Assembler;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix
{
    public enum ILCode : ushort
    {
        #region Values
        Nop = 0x0000,
        Break = 0x0001,
        Ldarg_0 = 0x0002,
        Ldarg_1 = 0x0003,
        Ldarg_2 = 0x0004,
        Ldarg_3 = 0x0005,
        Ldloc_0 = 0x0006,
        Ldloc_1 = 0x0007,
        Ldloc_2 = 0x0008,
        Ldloc_3 = 0x0009,
        Stloc_0 = 0x000A,
        Stloc_1 = 0x000B,
        Stloc_2 = 0x000C,
        Stloc_3 = 0x000D,
        Ldarg_S = 0x000E,
        Ldarga_S = 0x000F,
        Starg_S = 0x0010,
        Ldloc_S = 0x0011,
        Ldloca_S = 0x0012,
        Stloc_S = 0x0013,
        Ldnull = 0x0014,
        Ldc_I4_M1 = 0x0015,
        Ldc_I4_0 = 0x0016,
        Ldc_I4_1 = 0x0017,
        Ldc_I4_2 = 0x0018,
        Ldc_I4_3 = 0x0019,
        Ldc_I4_4 = 0x001A,
        Ldc_I4_5 = 0x001B,
        Ldc_I4_6 = 0x001C,
        Ldc_I4_7 = 0x001D,
        Ldc_I4_8 = 0x001E,
        Ldc_I4_S = 0x001F,
        Ldc_I4 = 0x0020,
        Ldc_I8 = 0x0021,
        Ldc_R4 = 0x0022,
        Ldc_R8 = 0x0023,
        Dup = 0x0025,
        Pop = 0x0026,
        Jmp = 0x0027,
        Call = 0x0028,
        Calli = 0x0029,
        Ret = 0x002A,
        Br_S = 0x002B,
        Brfalse_S = 0x002C,
        Brtrue_S = 0x002D,
        Beq_S = 0x002E,
        Bge_S = 0x002F,
        Bgt_S = 0x0030,
        Ble_S = 0x0031,
        Blt_S = 0x0032,
        Bne_Un_S = 0x0033,
        Bge_Un_S = 0x0034,
        Bgt_Un_S = 0x0035,
        Ble_Un_S = 0x0036,
        Blt_Un_S = 0x0037,
        Br = 0x0038,
        Brfalse = 0x0039,
        Brtrue = 0x003A,
        Beq = 0x003B,
        Bge = 0x003C,
        Bgt = 0x003D,
        Ble = 0x003E,
        Blt = 0x003F,
        Bne_Un = 0x0040,
        Bge_Un = 0x0041,
        Bgt_Un = 0x0042,
        Ble_Un = 0x0043,
        Blt_Un = 0x0044,
        Switch = 0x0045,
        Ldind_I1 = 0x0046,
        Ldind_U1 = 0x0047,
        Ldind_I2 = 0x0048,
        Ldind_U2 = 0x0049,
        Ldind_I4 = 0x004A,
        Ldind_U4 = 0x004B,
        Ldind_I8 = 0x004C,
        Ldind_I = 0x004D,
        Ldind_R4 = 0x004E,
        Ldind_R8 = 0x004F,
        Ldind_Ref = 0x0050,
        Stind_Ref = 0x0051,
        Stind_I1 = 0x0052,
        Stind_I2 = 0x0053,
        Stind_I4 = 0x0054,
        Stind_I8 = 0x0055,
        Stind_R4 = 0x0056,
        Stind_R8 = 0x0057,
        Add = 0x0058,
        Sub = 0x0059,
        Mul = 0x005A,
        Div = 0x005B,
        Div_Un = 0x005C,
        Rem = 0x005D,
        Rem_Un = 0x005E,
        And = 0x005F,
        Or = 0x0060,
        Xor = 0x0061,
        Shl = 0x0062,
        Shr = 0x0063,
        Shr_Un = 0x0064,
        Neg = 0x0065,
        Not = 0x0066,
        Conv_I1 = 0x0067,
        Conv_I2 = 0x0068,
        Conv_I4 = 0x0069,
        Conv_I8 = 0x006A,
        Conv_R4 = 0x006B,
        Conv_R8 = 0x006C,
        Conv_U4 = 0x006D,
        Conv_U8 = 0x006E,
        Callvirt = 0x006F,
        Cpobj = 0x0070,
        Ldobj = 0x0071,
        Ldstr = 0x0072,
        Newobj = 0x0073,
        Castclass = 0x0074,
        Isinst = 0x0075,
        Conv_R_Un = 0x0076,
        Unbox = 0x0079,
        Throw = 0x007A,
        Ldfld = 0x007B,
        Ldflda = 0x007C,
        Stfld = 0x007D,
        Ldsfld = 0x007E,
        Ldsflda = 0x007F,
        Stsfld = 0x0080,
        Stobj = 0x0081,
        Conv_Ovf_I1_Un = 0x0082,
        Conv_Ovf_I2_Un = 0x0083,
        Conv_Ovf_I4_Un = 0x0084,
        Conv_Ovf_I8_Un = 0x0085,
        Conv_Ovf_U1_Un = 0x0086,
        Conv_Ovf_U2_Un = 0x0087,
        Conv_Ovf_U4_Un = 0x0088,
        Conv_Ovf_U8_Un = 0x0089,
        Conv_Ovf_I_Un = 0x008A,
        Conv_Ovf_U_Un = 0x008B,
        Box = 0x008C,
        Newarr = 0x008D,
        Ldlen = 0x008E,
        Ldelema = 0x008F,
        Ldelem_I1 = 0x0090,
        Ldelem_U1 = 0x0091,
        Ldelem_I2 = 0x0092,
        Ldelem_U2 = 0x0093,
        Ldelem_I4 = 0x0094,
        Ldelem_U4 = 0x0095,
        Ldelem_I8 = 0x0096,
        Ldelem_I = 0x0097,
        Ldelem_R4 = 0x0098,
        Ldelem_R8 = 0x0099,
        Ldelem_Ref = 0x009A,
        Stelem_I = 0x009B,
        Stelem_I1 = 0x009C,
        Stelem_I2 = 0x009D,
        Stelem_I4 = 0x009E,
        Stelem_I8 = 0x009F,
        Stelem_R4 = 0x00A0,
        Stelem_R8 = 0x00A1,
        Stelem_Ref = 0x00A2,
        Ldelem = 0x00A3,
        Stelem = 0x00A4,
        Unbox_Any = 0x00A5,
        Conv_Ovf_I1 = 0x00B3,
        Conv_Ovf_U1 = 0x00B4,
        Conv_Ovf_I2 = 0x00B5,
        Conv_Ovf_U2 = 0x00B6,
        Conv_Ovf_I4 = 0x00B7,
        Conv_Ovf_U4 = 0x00B8,
        Conv_Ovf_I8 = 0x00B9,
        Conv_Ovf_U8 = 0x00BA,
        Refanyval = 0x00C2,
        Ckfinite = 0x00C3,
        Mkrefany = 0x00C6,
        Ldtoken = 0x00D0,
        Conv_U2 = 0x00D1,
        Conv_U1 = 0x00D2,
        Conv_I = 0x00D3,
        Conv_Ovf_I = 0x00D4,
        Conv_Ovf_U = 0x00D5,
        Add_Ovf = 0x00D6,
        Add_Ovf_Un = 0x00D7,
        Mul_Ovf = 0x00D8,
        Mul_Ovf_Un = 0x00D9,
        Sub_Ovf = 0x00DA,
        Sub_Ovf_Un = 0x00DB,
        Endfinally = 0x00DC,
        Leave = 0x00DD,
        Leave_S = 0x00DE,
        Stind_I = 0x00DF,
        Conv_U = 0x00E0,
        Prefix7 = 0x00F8,
        Prefix6 = 0x00F9,
        Prefix5 = 0x00FA,
        Prefix4 = 0x00FB,
        Prefix3 = 0x00FC,
        Prefix2 = 0x00FD,
        Prefix1 = 0x00FE,
        Prefixref = 0x00FF,
        Arglist = 0xFE00,
        Ceq = 0xFE01,
        Cgt = 0xFE02,
        Cgt_Un = 0xFE03,
        Clt = 0xFE04,
        Clt_Un = 0xFE05,
        Ldftn = 0xFE06,
        Ldvirtftn = 0xFE07,
        Ldarg = 0xFE09,
        Ldarga = 0xFE0A,
        Starg = 0xFE0B,
        Ldloc = 0xFE0C,
        Ldloca = 0xFE0D,
        Stloc = 0xFE0E,
        Localloc = 0xFE0F,
        Endfilter = 0xFE11,
        Unaligned = 0xFE12,
        Volatile = 0xFE13,
        Tailcall = 0xFE14,
        Initobj = 0xFE15,
        Constrained = 0xFE16,
        Cpblk = 0xFE17,
        Initblk = 0xFE18,
        Rethrow = 0xFE1A,
        Sizeof = 0xFE1C,
        Refanytype = 0xFE1D,
        Readonly = 0xFE1E
        #endregion
    }

    public static class ILHelper
    {
        /// <summary>
        /// Just declare the current compiler instance for helping the helper =P
        /// </summary>
        public static Compiler Compiler;
        /// <summary>
        /// The array of assembly Illegal chars, if we won't remove it than we have to face a big legal action ^^
        /// </summary>
        private static HashSet<char> IllegalChars = new HashSet<char>
        { ':', '.', '[', ']',
          '(', ')', '<', '>',
          '|', '/', '=', '+',
          '-', '*', '{', '}',
          '&', '%', '$', '#',
          '@', '!', '~', '`', '?', ' ', ','};

        /*
         * Well the concept of saved labels
         * i adopt just to make compiler fast by wating it time in making the labels which it already done in past
         * By saving the labels in memory and if this label is called again than we just point it to memory
         */

        private static Dictionary<MethodBase, string> CachedMethodLabel = new Dictionary<MethodBase, string>();
        private static Dictionary<FieldInfo, string> CachedFieldLabel = new Dictionary<FieldInfo, string>();

        /// <summary>
        /// Save Label for method Base
        /// </summary>
        /// <param name="xMethod"></param>
        /// <param name="lbl"></param>
        private static void SaveLabel(MethodBase xMethod, string lbl)
        {
            if (!CachedMethodLabel.ContainsKey(xMethod))
                CachedMethodLabel.Add(xMethod, lbl);
        }

        /// <summary>
        /// Save Labels for Field Info
        /// </summary>
        /// <param name="xField"></param>
        /// <param name="lbl"></param>
        private static void SaveLabel(FieldInfo xField, string lbl)
        {
            if (!CachedFieldLabel.ContainsKey(xField))
                CachedFieldLabel.Add(xField, lbl);
        }

        /// <summary>
        /// Get Full name of method base, well because the reflection want give us whole name of method
        /// </summary>
        /// <param name="aMethod"></param>
        /// <param name="RemoveIllegalChars"></param>
        /// <returns></returns>
        public static string FullName(this MethodBase aMethod, bool RemoveIllegalChars = true)
        {
            if (RemoveIllegalChars == false)
            {
                /* In Later version, I'm planning to make the method Label by random label generator, it took less time
                 * But the issue is we are not able to debug assembly code by ourself...
                 * So it can only be done when we have stable assembly debugger
                 * Till than we have to be happy with this method
                 */
                StringBuilder SB = new StringBuilder();
                SB.Append((aMethod is MethodInfo) ? ((MethodInfo)aMethod).ReturnType.FullName : "System.Void.");
                SB.Append(".");
                SB.Append(aMethod.ReflectedType.FullName);
                SB.Append(".");
                SB.Append(aMethod.Name);
                SB.Append("<");
                SB.Append(string.Join(", ", (aMethod.GetParameters()).Select(b => string.Format("{0}", b.ParameterType))));
                SB.Append(">");
                return SB.ToString();
            }

            if (CachedMethodLabel.ContainsKey(aMethod))
                return CachedMethodLabel[aMethod];

            // Check if this method has any plug attribute
            string xLabel = null;
            Compiler.Plugs.TryGetValue(aMethod, out xLabel);

            if (xLabel == null)
                xLabel = aMethod.FullName(false);

            // remove illegal characters
            xLabel = xLabel.RemoveIllegalCharacters();
            SaveLabel(aMethod, xLabel);

            return xLabel;
        }

        /// <summary>
        /// Get Full name of field info
        /// </summary>
        /// <param name="aField"></param>
        /// <param name="RemoveIllegalChars"></param>
        /// <returns></returns>
        public static string FullName(this FieldInfo aField, bool RemoveIllegalChars = true)
        {
            if (RemoveIllegalChars)
            {
                if (CachedFieldLabel.ContainsKey(aField))
                    return CachedFieldLabel[aField];

                var xLabel = aField.FullName(false).RemoveIllegalCharacters();
                SaveLabel(aField, xLabel);

                return xLabel;
            }
            else
                return string.Format("static_Field__{2}.{1}.{0}", aField.Name, aField.DeclaringType, aField.FieldType.FullName);
        }

        public static string RemoveIllegalCharacters(this string aStr)
        {
            char[] xResult = new char[aStr.Length];

            for (int i = 0; i < aStr.Length; i++)
            {
                if (!IllegalChars.Contains(aStr[i]))
                    xResult[i] = aStr[i];
                else
                    xResult[i] = '_';
            }

            return new string(xResult);
        }

        /// <summary>
        /// Align the given value to IntPtr Size
        /// </summary>
        /// <param name="aValue">The Value to be Aligned</param>
        /// <returns></returns>
        public static int Align(this int aValue)
        {
            /* Just we make it a multiple of IntPtr :) */
            int val = (ILCompiler.CPUArchitecture == CPUArch.x86 ? 4 : 8);
            int xResult = aValue / val;
            if (aValue % val != 0)
                xResult += 1;
            return xResult * val;
        }

        /// <summary>
        /// The Label of Method with given offset value
        /// </summary>
        /// <param name="xMethod">Method</param>
        /// <param name="NextPosition">Offset Value</param>
        /// <returns></returns>
        public static string GetLabel(MethodBase xMethod, int NextPosition)
        {
            return string.Format("{0}.IL_{1}", xMethod.FullName(), NextPosition.ToString("X").PadLeft(4, '0'));
        }

        /// <summary>
        /// Very important, it just return the hard coded size of value types
        /// </summary>
        /// <param name="aType"></param>
        /// <returns></returns>
        public static int SizeOf(this Type aType)
        {
            if (aType.FullName == "System.Void")
                return 0;
            else if ((!aType.IsValueType && aType.IsClass) || aType.IsInterface)
                return 4;

            if (aType.IsByRef)
                return 4;

            switch (aType.FullName)
            {
                case "System.Char":
                    return 2;
                case "System.Byte":
                case "System.SByte":
                    return 1;
                case "System.UInt16":
                case "System.Int16":
                    return 2;
                case "System.UInt32":
                case "System.Int32":
                    return 4;
                case "System.UInt64":
                case "System.Int64":
                    return 8;
                case "System.UIntPtr":
                case "System.IntPtr":
                    return ILCompiler.CPUArchitecture == CPUArch.x86 ? 4 : 8;
                case "System.Boolean":
                    return 1;
                case "System.Single":
                    return 4;
                case "System.Double":
                    return 8;
                case "System.Decimal":
                    return 16;
            }

            if (aType.FullName != null && aType.FullName.EndsWith("*"))
                return 4;

            if (aType.IsEnum)
                return SizeOf(aType.GetField("value__").FieldType);

            if (aType.IsValueType)
            {
                var xSla = aType.StructLayoutAttribute;
                if (xSla != null)
                {
                    if (xSla.Size > 0)
                    {
                        return (int)xSla.Size;
                    }
                }
            }

            return 4;
        }

        /// <summary>
        /// Get The return type values offset inside EBP
        /// </summary>
        /// <param name="aResultSize"></param>
        /// <param name="aTotalArgumentSize"></param>
        /// <returns></returns>
        public static int GetResultCodeOffset(int aResultSize, int aTotalArgumentSize)
        {
            int xOffset = 8;
            if ((aTotalArgumentSize > 0) && (aTotalArgumentSize >= aResultSize))
            {
                xOffset += aTotalArgumentSize;
                xOffset -= aResultSize;
            }
            return xOffset;
        }

        /// <summary>
        /// Get memory offset of given variable count inside Method Body
        /// </summary>
        /// <param name="xBody"></param>
        /// <param name="Count"></param>
        /// <returns></returns>
        public static int MemoryOffset(MethodBody xBody, ushort Count)
        {
            var lv = xBody.LocalVariables;
            int xOffset = 0;
            for (int i = 0; i < lv.Count; i++)
            {
                if (i == Count)
                    return xOffset;
                xOffset += lv[i].LocalType.SizeOf().Align();
            }
            throw new Exception("Variable Not found");
        }

        /// <summary>
        /// Get size of whole type or struc
        /// </summary>
        /// <param name="aDeclaringType"></param>
        /// <returns></returns>
        public static int StorageSize(Type aDeclaringType)
        {
            // Here is we do thing same as GetFieldOffset
            // but we want last offset or just sum of sizes

            int xOffset = 0; // This is another way of calculation offset we just add the size of each field


            var xFields = (from item in aDeclaringType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                           orderby item.Name, item.DeclaringType.ToString()
                           select item).ToList();

            if (aDeclaringType.BaseType != null)
                xFields.AddRange((from item in aDeclaringType.BaseType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                                  orderby item.Name, item.DeclaringType.ToString()
                                  select item).ToList());

            // Here reversing is not necessary so why waste time
            for (int i = 0; i < xFields.Count; i++)
            {
                var xField = xFields[i];

                // Maybe the entry is not what we want
                //if (xField.DeclaringType != aDeclaringType)
                //    continue;

                xOffset += xField.FieldType.SizeOf();
            }

            return xOffset;
        }

        /// <summary>
        /// Get the field info with given field ID and also its offset
        /// </summary>
        /// <param name="aDeclaringType"></param>
        /// <param name="aFieldId"></param>
        /// <param name="aFieldInfo"></param>
        /// <returns></returns>
        public static int GetFieldOffset(Type aDeclaringType, string aFieldId, out FieldInfo aFieldInfo)
        {
            /*
             * So what we do is get all fields of structure, than check the which field has
             * same field is as given and than we check the offset attribute ==> This is very necessary that
             * the field has an offset attribute
             */
            int xOffset = 0; // This is another way of calculation offset we just add the size of each field
            var xFields = (from item in aDeclaringType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                           orderby item.Name, item.DeclaringType.ToString()
                           select item).ToList();

            if (aDeclaringType.BaseType != null)
                xFields.AddRange((from item in aDeclaringType.BaseType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                                  orderby item.Name, item.DeclaringType.ToString()
                                  select item).ToList());

            /* Because the array is from bottom to top */
            xFields.Reverse();

            for (int i = 0; i < xFields.Count; i++)
            {
                var xField = xFields[i];

                //Maybe the entry is not what we want
                //if (xField.DeclaringType != aDeclaringType)
                //    continue;

                // Check if this is what we want
                if (xField.FullName() == aFieldId)
                {
                    var xFieldOffsetAttrib = xField.GetCustomAttributes(typeof(FieldOffsetAttribute), true).FirstOrDefault() as FieldOffsetAttribute;
                    aFieldInfo = xField;
                    if (xFieldOffsetAttrib != null)
                        return (int)xFieldOffsetAttrib.Value;
                    else
                        return xOffset;
                }
                xOffset += xField.FieldType.SizeOf();
            }

            // If not found it should throw an error
            throw new Exception("FieldId Not found: " + aDeclaringType + ", " + aFieldId );
        }

        /// <summary>
        /// Simple function which tells given type is signed or not
        /// </summary>
        /// <param name="Vt"></param>
        /// <returns></returns>
        public static bool IsSigned(this Type Vt)
        {
            if (Vt.FullName == "System.Int16" ||
                Vt.FullName == "System.Int32" ||
                Vt.FullName == "System.Int64" ||
                Vt.FullName == "System.SByte")
                return true;
            return false;
        }
        /*
         * Get Type ID Label, it is used mainly in array, because array has a unique header information
         * where we have to set its metadata etc, and also Type ID
         * By assigning each type a unique number
         */
        private static int TypeIdCounter = 1;
        public static Dictionary<string, int> TypeIDLabel = new Dictionary<string, int>();
        public static string GetTypeIDLabel(Type aType)
        {
            var str = aType.FullName;

            char[] xResult = new char[aType.FullName.Length];
            for (int i = 0; i < str.Length; i++)
            {
                if (!IllegalChars.Contains(str[i]))
                    xResult[i] = str[i];
                else
                    xResult[i] = '_';
            }

            string xResult2 = ("TYPE_ID_LABEL__" + new string(xResult));

            // Add it to Data Members
            if (!TypeIDLabel.ContainsKey(xResult2))
            {
                Core.DataMember.Add(new AsmData(xResult2, "dd " + TypeIdCounter));
                TypeIDLabel.Add(xResult2, TypeIdCounter);
                TypeIdCounter++;
            }

            return xResult2;
        }

        public static int GetTypeID(Type aType)
        {
            var str = aType.FullName;

            char[] xResult = new char[aType.FullName.Length];
            for (int i = 0; i < str.Length; i++)
            {
                if (!IllegalChars.Contains(str[i]))
                    xResult[i] = str[i];
                else
                    xResult[i] = '_';
            }

            string xResult2 = ("TYPE_ID_LABEL__" + new string(xResult));

            // Add it to Data Members
            if (!TypeIDLabel.ContainsKey(xResult2))
            {
                // we don't add those labels in output assembly which we don't call literal -- optimization
                // Core.DataMember.Add(new AsmData(xResult2, "dd " + xCounter));
                TypeIDLabel.Add(xResult2, TypeIdCounter);
                TypeIdCounter++;
            }

            return TypeIDLabel[xResult2];
        }

        public static int GetArgumentsSize(MethodBase aMethod)
        {
            int ArgSize = (from item in aMethod.GetParameters()
                           select item.ParameterType.SizeOf().Align()).Sum();

            if (!aMethod.IsStatic)
            {
                if (aMethod.DeclaringType.IsValueType)
                    ArgSize += 4;
                else
                    ArgSize += aMethod.DeclaringType.SizeOf().Align();
            }

            return ArgSize;
        }

        public static int GetReturnTypeSize(MethodBase aMethod)
        {
            if (aMethod is MethodInfo)
                return ((MethodInfo)aMethod).ReturnType.SizeOf().Align();

            // constructors -- no return type
            return 0;
        }

        public static bool IsDelegate(Type type)
        {
            return typeof(Delegate).IsAssignableFrom(type.BaseType);
        }

        public static int GetArgumentDisplacement(MethodBase aMethod, int aParamIndex)
        {
            var xMethodInfo = aMethod as MethodInfo;
            int xReturnSize = 0;

            if (xMethodInfo != null)
                xReturnSize = xMethodInfo.ReturnType.SizeOf().Align();

            int xOffset = 8; // EIP and calli header
            var xCorrectedOpValValue = aParamIndex;

            if (!aMethod.IsStatic)
                aParamIndex--;

            var xParams = aMethod.GetParameters();
            for (int i = xParams.Length - 1; i > aParamIndex; i--)
                xOffset += xParams[i].ParameterType.SizeOf().Align();


            return xOffset;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL Opcode
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix
{
    public abstract class ILOpCode
    {
        public readonly ILCode Code;
        public readonly int Position;
        public readonly int NextPosition;
        public readonly ExceptionHandlingClause Ehc;

        public ILOpCode(ILCode aCode, int aPosition, int aNextPosition, ExceptionHandlingClause aEhc)
        {
            Code = aCode;
            Position = aPosition;
            NextPosition = aNextPosition;
            Ehc = aEhc;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          in x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class In : DestinationSource
    {
        public In()
            : base("in") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Instruction class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;
using Atomix.CompilerExt;

namespace Atomix.Assembler
{
    public abstract class Instruction
    {
        public readonly string Code;
        public readonly CPUArch CPUArch;

        public Instruction(string aMnemonic, CPUArch aCPUArch = CPUArch.x86)
        {
            Code = aMnemonic;
            CPUArch = aCPUArch;
        }

        public virtual void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(Code);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          iret x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Iret : Instruction
    {
        public Iret()
            : base("iret") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          iretd x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Iretd : Instruction
    {
        public Iretd()
            : base("iretd") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Isinst MSIL
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Atomix.ILOpCodes;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.IL
{
    [ILOp(ILCode.Isinst)]
    public class Isinst : MSIL
    {
        public Isinst(Compiler Cmp)
            : base("isinst", Cmp) { }

        public override void Execute(ILOpCode instr, MethodBase aMethod)
        {
            var xType = ((OpType)instr).Value;
            var TypeID  = ILHelper.GetTypeID(xType);
            var xReturnNull = ILHelper.GetLabel(aMethod, instr.Position) + "_Isinst_False";
            var xReturnTrue = ILHelper.GetLabel(aMethod, instr.Position) + "_Isinst_Final";

            switch (ILCompiler.CPUArchitecture)
            {
                #region _x86_
                case CPUArch.x86:
                    {
                        Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.EAX });
                        Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceRef = "0x" + TypeID.ToString("X"), DestinationIndirect = true });
                        Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JNE, DestinationRef = xReturnNull });

                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x1" });
                        Core.AssemblerCode.Add(new Jmp { DestinationRef = xReturnTrue });

                        Core.AssemblerCode.Add(new Label(xReturnNull));
                        Core.AssemblerCode.Add(new Push { DestinationRef = "0x0" });

                        Core.AssemblerCode.Add(new Label(xReturnTrue));
                    }
                    break;
                #endregion
                #region _x64_
                case CPUArch.x64:
                    {

                    }
                    break;
                #endregion
                #region _ARM_
                case CPUArch.ARM:
                    {

                    }
                    break;
                #endregion
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Jmp x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public class Jmp : Instruction
    {
        public ConditionalJumpEnum? Condition;
        public string DestinationRef;

        public Jmp()
            : base("jmp")
        { }

        public override void FlushText(StreamWriter aSW)
        {
            if (!Condition.HasValue)
                Condition = ConditionalJumpEnum.JMP;

            if (DestinationRef.StartsWith("."))
                DestinationRef = Label.PrimaryLabel + DestinationRef;

            var jmpStr = Condition.ToString().ToLower();
            if (Condition == ConditionalJumpEnum.JMP)
                aSW.WriteLine(string.Format("{0} {1}", jmpStr, DestinationRef));
            else
                aSW.WriteLine(string.Format("{0} near {1}", jmpStr, DestinationRef));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Kernel Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomix.CompilerExt.Attributes
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public class KernelAttribute : Attribute
    {
        public readonly CPUArch CPUArch;
        public readonly string Organize;

        public KernelAttribute(CPUArch aCpuArch, string aOrganize)
        {
            CPUArch = aCpuArch;
            Organize = aOrganize;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Label class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler
{
    public class Label : Instruction
    {
        public static string PrimaryLabel;
        public readonly string Name;
        public readonly string FinalisedName;

        public Label(string aName)
            :base ("Label")
        {
            Name = aName;
            if (aName.StartsWith("."))
            {
                FinalisedName = PrimaryLabel + Name;
            }
            else
            {
                FinalisedName = aName;
                PrimaryLabel = FinalisedName;
            }
        }

        public override void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(FinalisedName + ":");
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          lea x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Lea : DestinationSource
    {
        public Lea()
            : base("lea")
        { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          leave x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Leave : Instruction
    {
        public Leave()
            : base("leave") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Literal class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler
{
    public class Literal : Instruction
    {
        public readonly string Assembly;

        public Literal(string aAsm)
            :base ("Literal")
        {
            Assembly = aAsm;
        }

        public Literal(string aFormat, object aObj)
            : base("Literal")
        {
            Assembly = string.Format(aFormat, aObj);
        }

        public Literal(string aFormat, params object[] aObjs)
            : base("Literal")
        {
            Assembly = string.Format(aFormat, aObjs);
        }

        public override void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(Assembly);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler Logger template class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Collections;

namespace Atomix
{
    public partial class log2html
    {
        ArrayList mScript;
        ArrayList mMessage;
        ArrayList mDetail;

        string mExecuteTime;

        public log2html(ArrayList aScript, ArrayList aMessage, ArrayList aDetail, string aExecutionTime)
        {
            mScript = aScript;
            mMessage = aMessage;
            mDetail = aDetail;
            mExecuteTime = aExecutionTime;
        }
    }
}
﻿// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Atomix
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;

    /// <summary>
    /// Class to produce the template output
    /// </summary>

    #line 1 "D:\Atomix\src\Compiler\log2html.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public partial class log2html : log2htmlBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("<html>\r\n\t<head>\r\n\t\t<meta http-equiv=\'Content-Type\' content=\'text/html; charset=UT" +
                    "F-8\'>\r\n\t\t<title>Atomix Builder : Logger</title>  \r\n\t</head>\r\n\t<body>\r\n\t\t<center>" +
                    "\r\n\t\t\t<h1>Atomix Compiler v2.0 Log File</h1>\r\n\t\t\t<p>Build Date: ");

            #line 14 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(System.DateTime.Now.ToString()));

            #line default
            #line hidden
            this.Write(" | Execute Time: ");

            #line 14 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(mExecuteTime));

            #line default
            #line hidden
            this.Write("ms</p>\r\n\t\t</center>\r\n\t\t\r\n\t\t<h3>Logger Index:</h3>\r\n\t\t<ul>\r\n\t\t");

            #line 19 "D:\Atomix\src\Compiler\log2html.tt"
 for(int i=0; i < mScript.Count ; i++)
		   {

            #line default
            #line hidden
            this.Write("\t    <li><a href=\'#D");

            #line 21 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(i));

            #line default
            #line hidden
            this.Write("\'> ");

            #line 21 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(mScript[i].ToString()));

            #line default
            #line hidden
            this.Write(" : ");

            #line 21 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(mMessage[i]));

            #line default
            #line hidden
            this.Write(" </a></li>\r\n\t\t");

            #line 22 "D:\Atomix\src\Compiler\log2html.tt"
 }

            #line default
            #line hidden
            this.Write("\t\t</ul>\r\n\t\t<hr>\r\n\t\t");

            #line 25 "D:\Atomix\src\Compiler\log2html.tt"
 for(int i=0; i < mDetail.Count ; i++)
		   {

            #line default
            #line hidden
            this.Write("\t\t<h4><a name=\'D");

            #line 27 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(i));

            #line default
            #line hidden
            this.Write("\'> ");

            #line 27 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(mScript[i].ToString()));

            #line default
            #line hidden
            this.Write(" : ");

            #line 27 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(mMessage[i]));

            #line default
            #line hidden
            this.Write(" </a></h4>\r\n\t\t<ul><p>");

            #line 28 "D:\Atomix\src\Compiler\log2html.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(mDetail[i].ToString()));

            #line default
            #line hidden
            this.Write("</p></ul>\r\n\t\t<hr>\r\n\t\t");

            #line 30 "D:\Atomix\src\Compiler\log2html.tt"
 }

            #line default
            #line hidden
            this.Write("\t</body>\r\n</html>");
            return this.GenerationEnvironment.ToString();
        }
    }

    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    public class log2htmlBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0)
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Compiler Logger
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Collections;
using System.IO;
using System.Diagnostics;
using Atomix.CompilerExt;

namespace Atomix
{
    public class Logger
    {
        private string LoggerPath;
        private Stopwatch Timer;
        private bool IsLogging;

        ArrayList Script;
        ArrayList Message;
        ArrayList Details;

        public Logger(string aPath, bool aDoLog)
        {
            IsLogging = aDoLog;

            if (!aDoLog)
                return;

            Script = new ArrayList();
            Message = new ArrayList();
            Details = new ArrayList();
            LoggerPath = Path.Combine(Path.GetDirectoryName(aPath), Path.GetFileName(aPath) + Helper.LoggerFile);
            Timer = new Stopwatch();
            Timer.Start();
        }

        public void Write(string aScript, string aMessage, string aDetail)
        {
            if (!IsLogging)
                return;

            Script.Add(aScript);
            Message.Add(aMessage);
            Details.Add(aDetail);
        }

        public void Write(string aAppend, bool aSub = true)
        {
            if (!IsLogging)
                return;
            if (aSub)
                Details[Details.Count - 1] = string.Format("{0}<li>{1}</li>", Details[Details.Count - 1], aAppend);
            else
                Details[Details.Count - 1] = string.Format("{0}<br>{1}", Details[Details.Count - 1], aAppend);
        }

        public void Dump()
        {
            if (!IsLogging)
                return;

            Timer.Stop();
            log2html page = new log2html(Script, Message, Details, Timer.ElapsedMilliseconds.ToString());
            File.WriteAllText(LoggerPath, page.TransformText());
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Mov x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Mov : DestinationSourceSize
    {
        public Mov()
            : base("mov") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MovD x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class MovD : DestinationSourceSize
    {
        public MovD()
            : base("movd") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Movss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Movss : DestinationSource
    {
        public Movss()
            : base("movss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Movsx x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public class Movsx : DestinationSourceSize
    {
        public Movsx()
            : base("movsx") { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            aSW.WriteLine(string.Format("{0} {1}, {3} {2}", Code, des, src, Const.SizeToString(Size)));
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using Atomix.CompilerExt;
using Atomix.Assembler;

namespace Atomix.Assembler.x86
{
    public class Movzx : DestinationSourceSize
    {
        public Movzx()
            : base("movzx") { }

        public override void FlushText(StreamWriter sw)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            sw.WriteLine(string.Format("{0} {1}, {3} {2}", Code, des, src, Const.SizeToString(Size)));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Mulss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Mulss : DestinationSource
    {
        public Mulss()
            : base("mulss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Mul x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Multiply : OnlyDestination
    {
        public Multiply()
            : base("mul") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Not x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Not : OnlyDestination
    {
        public Not()
            : base("not") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          OnlyDestination type Instructions abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public abstract class OnlyDestination : Instruction
    {
        public Registers? DestinationReg;
        public string DestinationRef;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;
        public byte Size;

        public OnlyDestination(string aMnemonic)
            : base(aMnemonic)  { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            aSW.WriteLine(string.Format("{0} {2} {1}", Code, des, Const.SizeToString(Size)));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          OnlySize type Instructions abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public abstract class OnlySize : Instruction
    {
        public byte Address;

        public OnlySize(string aMnemonic)
            : base(aMnemonic)  { }

        public override void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(string.Format("{0} 0x{1}", Code, Address.ToString("X")));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpBranch
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpBranch : ILOpCode
    {
        public readonly int Value;

        public OpBranch(ILCode aCode, int aPosition, int aNextPosition, int aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Branch  [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);                                                    
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL Opcode
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;

namespace Atomix
{
    public static class BodyProcesser
    {
        /// <summary>
        /// MSIL Low
        /// </summary>
        private static OpCode[] OpCodeLo = new OpCode[256];
        /// <summary>
        /// MSIL High
        /// </summary>
        private static OpCode[] OpCodeHi = new OpCode[256];

        /// <summary>
        /// Load MSIL byte codes into array =P
        /// </summary>
        public static void Start()
        {
            // Just lookup into IL list
            foreach (var xField in typeof(OpCodes).GetFields(BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public))
            {
                var xOpCode = (OpCode)xField.GetValue(null);
                var xValue = (ushort)xOpCode.Value;

                // Classify each by high low
                if (xValue <= 0xFF)
                    OpCodeLo[xValue] = xOpCode;
                else
                    OpCodeHi[xValue & 0xFF] = xOpCode;
            }
        }

        /// <summary>
        /// This method just process method and output MSIL List
        /// Here is one more thing i.e. LabelTarget,
        /// Well it is just a list of il position where we have to break and create one more label with give position
        /// This is used when we have to make branch or jump operation to an IL
        /// </summary>
        /// <param name="aMethod"></param>
        /// <param name="LabelTarget"></param>
        /// <returns></returns>
        public static List<ILOpCode> Process(this MethodBase aMethod, List<int> LabelTarget)
        {
            List<ILOpCode> xResult = new List<ILOpCode>();
            var xBody = aMethod.GetMethodBody();
            Type[] xTypeGenArgs = null;
            Type[] xMethodGenArgs = null;

            if (aMethod.DeclaringType.IsGenericType)
                xTypeGenArgs = aMethod.DeclaringType.GetGenericArguments();

            if (aMethod.IsGenericMethod)
                xMethodGenArgs = aMethod.GetGenericArguments();

            if (xBody == null)
                return null;

            // Get IL as a byte Array using microsoft implementation
            var msIL = xBody.GetILAsByteArray();

            /* Exactly below code just simplfy the IL byte array and give us IL class and operand type
             * This is just to make the life easier
             */

            // Set current position of IL as zero
            int xPos = 0;
            while (xPos < msIL.Length)
            {
                /* Calculate Exception handling label for current IL
                 * It just do check if this IL is inside try catch, if yes than set xCurrentHandler else null
                 */
                ExceptionHandlingClause xCurrentHandler = null;
                #region Exception
                foreach (ExceptionHandlingClause xHandler in xBody.ExceptionHandlingClauses)
                {
                    //We can have Try in the beginning so it can be equals to zero :)
                    if (xHandler.TryOffset >= 0)
                    {
                        if (xHandler.TryOffset <= xPos && (xHandler.TryLength + xHandler.TryOffset + 1) > xPos) // + 1 because index should be less than the try
                        {
                            if (xCurrentHandler == null)
                            {
                                xCurrentHandler = xHandler;
                                continue;
                            }
                            else if (xHandler.TryOffset > xCurrentHandler.TryOffset && (xHandler.TryLength + xHandler.TryOffset) < (xCurrentHandler.TryLength + xCurrentHandler.TryOffset))
                            {
                                xCurrentHandler = xHandler;
                                continue;
                            }
                        }
                    }
                    if (xHandler.HandlerOffset > 0)
                    {
                        if (xHandler.HandlerOffset <= xPos && (xHandler.HandlerOffset + xHandler.HandlerLength + 1) > xPos)
                        {
                            if (xCurrentHandler == null)
                            {
                                xCurrentHandler = xHandler;
                                continue;
                            }
                            else if (xHandler.HandlerOffset > xCurrentHandler.HandlerOffset && (xHandler.HandlerOffset + xHandler.HandlerLength) < (xCurrentHandler.HandlerOffset + xCurrentHandler.HandlerLength))
                            {
                                xCurrentHandler = xHandler;
                                continue;
                            }
                        }
                    }
                    if ((xHandler.Flags & ExceptionHandlingClauseOptions.Filter) > 0)
                    {
                        if (xHandler.FilterOffset > 0)
                        {
                            if (xHandler.FilterOffset <= xPos)
                            {
                                if (xCurrentHandler == null)
                                {
                                    xCurrentHandler = xHandler;
                                    continue;
                                }
                                else if (xHandler.FilterOffset > xCurrentHandler.FilterOffset)
                                {
                                    xCurrentHandler = xHandler;
                                    continue;
                                }
                            }
                        }
                    }
                }
                #endregion
                if (xCurrentHandler != null)
                {
                    LabelTarget.Add(xCurrentHandler.HandlerOffset);
                }

                // Well here we have an op code holder and also a operand type holder
                ILCode xOpCodeVal;
                OpCode xOpCode;
                int xOpPos = xPos;
                if (msIL[xPos] == 0xFE)
                {
                    xOpCodeVal = (ILCode)(0xFE00 | msIL[xPos + 1]);
                    xOpCode = OpCodeHi[msIL[xPos + 1]];
                    xPos = xPos + 2;
                }
                else
                {
                    xOpCodeVal = (ILCode)msIL[xPos];
                    xOpCode = OpCodeLo[msIL[xPos]];
                    xPos++;
                }

                // This will be our final OpCode class =)
                // We just set its value and add it to above list
                ILOpCode xILOpCode = null;

                // And below is some magic :P , which give us OpCode class, exactly a hardcoded classification
                // So, i'm not going to take any garrentee if you touch this :P
                // handle with care =P
                // And we also add the labels breakpoints here, so take that in mind before merging IL
                // As we don't want waste labels =)
                switch (xOpCode.OperandType)
                {
                    #region Inline None
                    case OperandType.InlineNone:
                        {
                            switch (xOpCodeVal)
                            {
                                #region Ldarg
                                case ILCode.Ldarg_0:
                                        xILOpCode = new ILOpCodes.OpVar(ILCode.Ldarg, xOpPos, xPos, 0, xCurrentHandler);
                                    break;
                                case ILCode.Ldarg_1:
                                        xILOpCode = new ILOpCodes.OpVar(ILCode.Ldarg, xOpPos, xPos, 1, xCurrentHandler);
                                    break;
                                case ILCode.Ldarg_2:
                                        xILOpCode = new ILOpCodes.OpVar(ILCode.Ldarg, xOpPos, xPos, 2, xCurrentHandler);
                                    break;
                                case ILCode.Ldarg_3:
                                        xILOpCode = new ILOpCodes.OpVar(ILCode.Ldarg, xOpPos, xPos, 3, xCurrentHandler);
                                    break;
                                #endregion
                                #region Ldc_I4
                                case ILCode.Ldc_I4_0:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 0, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_1:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 1, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_2:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 2, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_3:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 3, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_4:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 4, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_5:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 5, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_6:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 6, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_7:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 7, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_8:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, 8, xCurrentHandler);
                                    break;
                                case ILCode.Ldc_I4_M1:
                                    xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos, -1, xCurrentHandler);
                                    break;
                                #endregion
                                #region Ldloc
                                case ILCode.Ldloc_0:
                                    xILOpCode = new ILOpCodes.OpVar(ILCode.Ldloc, xOpPos, xPos, 0, xCurrentHandler);
                                    break;
                                case ILCode.Ldloc_1:
                                    xILOpCode = new ILOpCodes.OpVar(ILCode.Ldloc, xOpPos, xPos, 1, xCurrentHandler);
                                    break;
                                case ILCode.Ldloc_2:
                                    xILOpCode = new ILOpCodes.OpVar(ILCode.Ldloc, xOpPos, xPos, 2, xCurrentHandler);
                                    break;
                                case ILCode.Ldloc_3:
                                    xILOpCode = new ILOpCodes.OpVar(ILCode.Ldloc, xOpPos, xPos, 3, xCurrentHandler);
                                    break;
                                #endregion
                                #region Stloc
                                case ILCode.Stloc_0:
                                    xILOpCode = new ILOpCodes.OpVar(ILCode.Stloc, xOpPos, xPos, 0, xCurrentHandler);
                                    break;
                                case ILCode.Stloc_1:
                                    xILOpCode = new ILOpCodes.OpVar(ILCode.Stloc, xOpPos, xPos, 1, xCurrentHandler);
                                    break;
                                case ILCode.Stloc_2:
                                    xILOpCode = new ILOpCodes.OpVar(ILCode.Stloc, xOpPos, xPos, 2, xCurrentHandler);
                                    break;
                                case ILCode.Stloc_3:
                                    xILOpCode = new ILOpCodes.OpVar(ILCode.Stloc, xOpPos, xPos, 3, xCurrentHandler);
                                    break;
                                #endregion
                                default:
                                    xILOpCode = new ILOpCodes.OpNone(xOpCodeVal, xOpPos, xPos, xCurrentHandler);
                                    break;
                            }
                        }
                        break;
                    #endregion
                    #region Inline Branch
                    case OperandType.ShortInlineBrTarget:
                        {
                            int xTarget = xPos + 1 + (sbyte)msIL[xPos];
                            LabelTarget.Add(xTarget);
                            switch (xOpCodeVal)
                            {
                                case ILCode.Beq_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Beq, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bge_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Bge, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bge_Un_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Bge_Un, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bgt_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Bgt, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bgt_Un_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Bgt_Un, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Ble_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Ble, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Ble_Un_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Ble_Un, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Blt_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Blt, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Blt_Un_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Blt_Un, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Bne_Un_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Bne_Un, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Br_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Br, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Brfalse_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Brfalse, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Brtrue_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Brtrue, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                case ILCode.Leave_S:
                                    xILOpCode = new ILOpCodes.OpBranch(ILCode.Leave, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                                default:
                                    xILOpCode = new ILOpCodes.OpBranch(xOpCodeVal, xOpPos, xPos + 1, xTarget, xCurrentHandler);
                                    break;
                            }
                            xPos += 1;
                        }
                        break;
                    #endregion
                    case OperandType.InlineBrTarget:
                        {
                            int xTarget = xPos + 4 + (Int32)BitConverter.ToInt32(msIL, xPos);
                            LabelTarget.Add(xTarget);
                            xILOpCode = new ILOpCodes.OpBranch(xOpCodeVal, xOpPos, xPos + 4, xTarget, xCurrentHandler);
                            xPos = xPos + 4;
                        }
                        break;
                    case OperandType.ShortInlineI:
                        switch (xOpCodeVal)
                        {
                            case ILCode.Ldc_I4_S:
                                xILOpCode = new ILOpCodes.OpInt(ILCode.Ldc_I4, xOpPos, xPos + 1, ((sbyte)msIL[xPos]), xCurrentHandler);
                                break;
                            default:
                                xILOpCode = new ILOpCodes.OpInt(xOpCodeVal, xOpPos, xPos + 1, ((sbyte)msIL[xPos]), xCurrentHandler);
                                break;
                        }
                        xPos = xPos + 1;
                        break;
                    case OperandType.InlineI:
                        xILOpCode = new ILOpCodes.OpInt(xOpCodeVal, xOpPos, xPos + 4, BitConverter.ToInt32(msIL, xPos), xCurrentHandler);
                        xPos = xPos + 4;
                        break;
                    case OperandType.InlineI8:
                        xILOpCode = new ILOpCodes.OpInt64(xOpCodeVal, xOpPos, xPos + 8, BitConverter.ToUInt64(msIL, xPos), xCurrentHandler);
                        xPos = xPos + 8;
                        break;

                    case OperandType.ShortInlineR:
                        xILOpCode = new ILOpCodes.OpSingle(xOpCodeVal, xOpPos, xPos + 4, BitConverter.ToSingle(msIL, xPos), xCurrentHandler);
                        xPos = xPos + 4;
                        break;
                    case OperandType.InlineR:
                        xILOpCode = new ILOpCodes.OpDouble(xOpCodeVal, xOpPos, xPos + 8, BitConverter.ToDouble(msIL, xPos), xCurrentHandler);
                        xPos = xPos + 8;
                        break;

                    case OperandType.InlineField:
                        {
                            var xValue = aMethod.Module.ResolveField((int)BitConverter.ToInt32(msIL, xPos), xTypeGenArgs, xMethodGenArgs);
                            xILOpCode = new ILOpCodes.OpField(xOpCodeVal, xOpPos, xPos + 4, xValue, xCurrentHandler);
                            xPos = xPos + 4;
                            break;
                        }

                    case OperandType.InlineMethod:
                        {
                            var xValue = aMethod.Module.ResolveMethod((int)BitConverter.ToInt32(msIL, xPos), xTypeGenArgs, xMethodGenArgs);
                            xILOpCode = new ILOpCodes.OpMethod(xOpCodeVal, xOpPos, xPos + 4, xValue, xCurrentHandler);
                            xPos = xPos + 4;
                            break;
                        }

                    case OperandType.InlineSig:
                        xILOpCode = new ILOpCodes.OpSig(xOpCodeVal, xOpPos, xPos + 4, BitConverter.ToInt32(msIL, xPos), xCurrentHandler);
                        xPos = xPos + 4;
                        break;

                    case OperandType.InlineString:
                        xILOpCode = new ILOpCodes.OpString(xOpCodeVal, xOpPos, xPos + 4, aMethod.Module.ResolveString((int)BitConverter.ToInt32(msIL, xPos)), xCurrentHandler);
                        xPos = xPos + 4;
                        break;

                    case OperandType.InlineSwitch:
                        {
                            int xCount = (int)BitConverter.ToInt32(msIL, xPos);
                            xPos = xPos + 4;
                            int xNextOpPos = xPos + xCount * 4;
                            int[] xBranchLocations = new int[xCount];
                            for (int i = 0; i < xCount; i++)
                            {
                                xBranchLocations[i] = xNextOpPos + (int)BitConverter.ToInt32(msIL, xPos + i * 4);
                                LabelTarget.Add(xBranchLocations[i]);
                            }
                            xILOpCode = new ILOpCodes.OpSwitch(xOpCodeVal, xOpPos, xNextOpPos, xBranchLocations, xCurrentHandler);
                            xPos = xNextOpPos;
                            break;
                        }
                    case OperandType.InlineTok:
                        xILOpCode = new ILOpCodes.OpToken(xOpCodeVal, xOpPos, xPos + 4, BitConverter.ToInt32(msIL, xPos), aMethod.Module, xTypeGenArgs, xMethodGenArgs, xCurrentHandler);
                        xPos = xPos + 4;
                        break;
                    case OperandType.InlineType:
                        {
                            var xValue = aMethod.Module.ResolveType((int)BitConverter.ToInt32(msIL, xPos), xTypeGenArgs, xMethodGenArgs);
                            xILOpCode = new ILOpCodes.OpType(xOpCodeVal, xOpPos, xPos + 4, xValue, xCurrentHandler);
                            xPos = xPos + 4;
                            break;
                        }
                    #region ShortInlineVar
                    case OperandType.ShortInlineVar:
                        switch (xOpCodeVal)
                        {
                            case ILCode.Ldloc_S:
                                xILOpCode = new ILOpCodes.OpVar(ILCode.Ldloc, xOpPos, xPos + 1, msIL[xPos], xCurrentHandler);
                                break;
                            case ILCode.Ldloca_S:
                                xILOpCode = new ILOpCodes.OpVar(ILCode.Ldloca, xOpPos, xPos + 1, msIL[xPos], xCurrentHandler);
                                break;
                            case ILCode.Ldarg_S:
                                xILOpCode = new ILOpCodes.OpVar(ILCode.Ldarg, xOpPos, xPos + 1, msIL[xPos], xCurrentHandler);
                                break;
                            case ILCode.Ldarga_S:
                                xILOpCode = new ILOpCodes.OpVar(ILCode.Ldarga, xOpPos, xPos + 1, msIL[xPos], xCurrentHandler);
                                break;
                            case ILCode.Starg_S:
                                xILOpCode = new ILOpCodes.OpVar(ILCode.Starg, xOpPos, xPos + 1, msIL[xPos], xCurrentHandler);
                                break;
                            case ILCode.Stloc_S:
                                xILOpCode = new ILOpCodes.OpVar(ILCode.Stloc, xOpPos, xPos + 1, msIL[xPos], xCurrentHandler);
                                break;
                            default:
                                xILOpCode = new ILOpCodes.OpVar(xOpCodeVal, xOpPos, xPos + 1, msIL[xPos], xCurrentHandler);
                                break;
                        }
                        xPos = xPos + 1;
                        break;
                    #endregion
                    case OperandType.InlineVar:
                        xILOpCode = new ILOpCodes.OpVar(xOpCodeVal, xOpPos, xPos + 2, BitConverter.ToUInt16(msIL, xPos), xCurrentHandler);
                        xPos = xPos + 2;
                        break;
                    default:
                        throw new Exception("Internal Compiler error" + xOpCode.OperandType);
                }
                // Add few more label lists
                switch (xILOpCode.Code)
                {
                    case ILCode.Call:
                    case ILCode.Callvirt:
                    case ILCode.Newobj:
                        LabelTarget.Add(xILOpCode.NextPosition);
                        break;
                    default:
                        break;
                }

                // Add our result of magic code to list
                xResult.Add(xILOpCode);
            }
            // Return the magic code result and be happy =)
            return xResult;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpDouble
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpDouble : ILOpCode
    {
        public readonly double Value;

        public OpDouble(ILCode aCode, int aPosition, int aNextPosition, double aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Double  [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpField
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpField : ILOpCode
    {
        public readonly FieldInfo Value;

        public OpField(ILCode aCode, int aPosition, int aNextPosition, FieldInfo aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Field  [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpInt64
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpInt64 : ILOpCode
    {
        public readonly ulong Value;

        public OpInt64(ILCode aCode, int aPosition, int aNextPosition, ulong aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Int64       [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpField
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpInt : ILOpCode
    {
        public readonly int Value;

        public OpInt(ILCode aCode, int aPosition, int aNextPosition, int aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Int     [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpMethod
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Collections.Generic;
using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpMethod : ILOpCode
    {
        public readonly MethodBase Value;
        public readonly uint MethodUID;

        private static uint Counter = 1;
        //public static Dictionary<MethodBase, uint> MethodUIDs = new Dictionary<MethodBase, uint>();

        public OpMethod(ILCode aCode, int aPosition, int aNextPosition, MethodBase aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
            MethodUID = 0;

            if (aValue.IsAbstract)
            {
                MethodUID = (uint)aValue.GetHashCode();
                /*
                if (MethodUIDs.ContainsKey(aValue))
                {
                    MethodUID = MethodUIDs[aValue];
                }
                else
                {
                    MethodUID = Counter++;
                    MethodUIDs.Add(aValue, MethodUID);
                }*/
            }
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Method   [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpNone
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpNone : ILOpCode
    {
        public OpNone(ILCode aCode, int aPosition, int aNextPosition, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>None    [0x{1}-0x{2}] {0} {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Ehc != null? Ehc.HandlerOffset : 0);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpSig
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpSig : ILOpCode
    {
        public readonly int Value;

        public OpSig(ILCode aCode, int aPosition, int aNextPosition, int aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Sig     [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpSingle
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpSingle : ILOpCode
    {
        public readonly float Value;

        public OpSingle(ILCode aCode, int aPosition, int aNextPosition, float aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Single  [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpInt64
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpString : ILOpCode
    {
        public readonly string Value;

        public OpString(ILCode aCode, int aPosition, int aNextPosition, string aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>String   [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value.Replace('\n', ' '));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpSwitch
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpSwitch : ILOpCode
    {
        public readonly int[] Value;

        public OpSwitch(ILCode aCode, int aPosition, int aNextPosition, int[] aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Switch  [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Optimization
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;

using Atomix.Assembler;

namespace Atomix.ILOptimizer
{

    /// <summary>
    /// Optimization base class.
    /// </summary>
    public abstract class OptimizationBase
    {

        /// <summary>
        /// Apply the optimization.
        /// </summary>
        /// <param name="instructions">Instructions.</param>
        public abstract void Apply(List<Instruction> instructions);
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpToken
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpToken : ILOpCode
    {
        public readonly int Value;
        public readonly FieldInfo ValueField;
        public readonly Type ValueType;

        public bool ValueIsType
        {
            get
            {
                if ((Value & 0x02000000) != 0)
                {
                    return true;
                }
                if ((Value & 0x01000000) != 0)
                {
                    return true;
                }
                if ((Value & 0x1B000000) != 0)
                {
                    return true;
                }
                return false;
            }
        }
        public bool ValueIsField
        {
            get
            {
                if ((Value & 0x04000000) != 0)
                {
                    return true;
                }
                return false;
            }
        }

        public OpToken(ILCode aCode, int aPosition, int aNextPosition, int aValue, Module aModule, Type[] aTypeGenericArgs, Type[] aMethodGenericArgs, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
            if (ValueIsField)
            {
                ValueField = aModule.ResolveField(Value, aTypeGenericArgs, aMethodGenericArgs);
            }
            if (ValueIsType)
            {
                ValueType = aModule.ResolveType(Value, aTypeGenericArgs, aMethodGenericArgs);
            }
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Token    [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpType
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpType : ILOpCode
    {
        public readonly Type Value;

        public OpType(ILCode aCode, int aPosition, int aNextPosition, Type aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Type    [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MSIL OpVar
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.Reflection;

namespace Atomix.ILOpCodes
{
    public class OpVar : ILOpCode
    {
        public readonly ushort Value;

        public OpVar(ILCode aCode, int aPosition, int aNextPosition, ushort aValue, ExceptionHandlingClause aEhc)
            : base(aCode, aPosition, aNextPosition, aEhc)
        {
            Value = aValue;
        }

        public override string ToString()
        {
            return string.Format("ILOpCode=>Var     [0x{1}-0x{2}] {0}:     {3}", Code, Position.ToString("X").PadLeft(3, '0'), NextPosition.ToString("X").PadLeft(3, '0'), Value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Or x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Or : DestinationSourceSize
    {
        public Or()
            : base("or") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Out x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Out : DestinationSource
    {
        public Out()
            : base("out") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Plug Attribute
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomix.CompilerExt.Attributes
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    public class PlugAttribute : Attribute
    {
        protected CPUArch CPUArch;
        protected string TargetString;

        public PlugAttribute(string aTargetSymbol, CPUArch aCpuArch = CPUArch.x86)
        {
            TargetString = aTargetSymbol;
            CPUArch = aCpuArch;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Popad x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Popad : Instruction
    {
        public Popad()
            : base("popad") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Pop x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Pop : OnlyDestination
    {
        public Pop()
            : base("pop") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Pushad x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Pushad : Instruction
    {
        public Pushad()
            : base("pushad") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Push x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Push : OnlyDestination
    {
        public Push()
            : base("push") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Registers enum
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler
{
    public enum Registers
    {
        EAX, AX, AH, AL,
        EBX, BX, BH, BL,
        ECX, CX, CH, CL,
        EDX, DX, DH, DL,
        CS, DS, ES, FS,
        GS, SS, ESP, SP,
        EBP, BP, ESI, SI,
        EDI, DI, CR0, CR1,
        CR2, CR3, CR4, XMM0,
        XMM1, XMM2, XMM3, XMM4,
        XMM5, XMM6, XMM7, ST0,
        ST1, ST2, ST3, ST4,
        ST5, ST6, ST7, r0,
        r1, r2, r3, r4,
        r5, r6, r7, r8,
        r9, r10, r11, r12,
        r13, r14, r15
    };
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ret x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Ret : OnlySize
    {
        public Ret()
            : base("ret") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shl x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class ShiftLeft : DestinationSourceSize
    {
        public ShiftLeft()
            : base("shl") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shr x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class ShiftRight : DestinationSourceSize
    {
        public ShiftRight()
            : base("shr") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sti x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Sti : Instruction
    {
        public Sti()
            : base("sti") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sub x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Sub : DestinationSourceSize
    {
        public Sub()
            : base("sub") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Subss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Subss : DestinationSource
    {
        public Subss()
            : base("subss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sbb x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class SubWithCarry : DestinationSourceSize
    {
        public SubWithCarry()
            : base("sbb") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          test x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Test : DestinationSourceSize
    {
        public Test()
            : base("test") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Virtual Stack
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;

namespace Atomix.Assembler
{
    public class VirtualStack
    {
        protected Stack<Items> mStack;

        public VirtualStack()
        {
            mStack = new Stack<Items>();
        }

        public int Count
        { get { return mStack.Count; } }

        public void Clear()
        {
            mStack.Clear();
        }

        public Items Pop()
        {
            return mStack.Pop();
        }

        public Items Peek()
        {
            return mStack.Peek();
        }

        public void Push(int aSize, Type aType)
        {
            mStack.Push(new Items(aSize, aType));
        }
    }

    public class Items
    {
        public readonly int Size;
        public readonly Type Type;
        public readonly bool IsFloat;
        public readonly bool IsSigned;

        public readonly bool IsInteger;

        public Items(int aSize, Type aType)
        {
            Size = aSize;
            Type = aType;

            // C# Data Types sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool
            // http://www.blackwasp.co.uk/CSharpNumericDataTypes.aspx

            IsInteger = (aType == typeof(bool)
                || aType == typeof(byte)
                || aType == typeof(sbyte)
                || aType == typeof(short)
                || aType == typeof(ushort)
                || aType == typeof(int)
                || aType == typeof(uint)
                || aType == typeof(long)
                || aType == typeof(ulong));
            IsFloat = (aType == typeof(float)
                || aType == typeof(double)
                || aType == typeof(decimal));
            IsSigned = (aType == typeof(sbyte)
                || aType == typeof(short)
                || aType == typeof(int)
                || aType == typeof(long)
                || aType == typeof(float)
                || aType == typeof(double)
                || aType == typeof(decimal));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Virtual Table Implementation
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomix
{
    public static class VTable
    {
        public static unsafe uint GetEntry(uint* aTable, uint aTypeID, uint aMethodID)
        {
            uint TypeID, MethodID, Size;
            while ((Size = *aTable) != 0)
            {
                TypeID = aTable[1];
                if (TypeID == aTypeID)
                {
                    aTable += 2;
                    while ((MethodID = *aTable) != 0)
                    {
                        if (MethodID == aMethodID)
                            return aTable[1];
                        aTable += 2;
                    }
                    throw new Exception("[VTable] Method Not Found!");
                }
                aTable += Size;
            }
            throw new Exception("[VTable] Type Not Found!");
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Optimization worker
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;

using Atomix.Assembler;

using Atomix.ILOptimizer.Optimizations;

namespace Atomix.ILOptimizer
{

    /// <summary>
    /// Worker.
    /// </summary>
    public class Worker
    {

        /// <summary>
        /// The input instructions.
        /// </summary>
        private readonly List<Instruction> Assembly;

        /// <summary>
        /// The (optimized) output instructions.
        /// </summary>
        private readonly List<Instruction> OptimizedAssembly;

        /// <summary>
        /// The optimization start flag.
        /// </summary>
        public const string OPTIMIZATION_START_FLAG = "__do_optimization__";

        /// <summary>
        /// The optimiaztion end flag.
        /// </summary>
        public const string OPTIMIAZTION_END_FLAG = "__do_end_optimization__";

        /// <summary>
        /// The optimization algorithms.
        /// </summary>
        public List<OptimizationBase> Algorithms;

        /// <summary>
        /// Initializes a new instance of the <see cref="T:Atomix.ILOptimizer.Worker"/> class.
        /// </summary>
        /// <param name="aAssembly">The instructions that make the assembly.</param>
        public Worker(List<Instruction> aAssembly)
        {
            Assembly = aAssembly;
            OptimizedAssembly = new List<Instruction>();
            Algorithms = new List<OptimizationBase>();

            // Load the algorithms
            LoadAlgorithms();
        }

        /// <summary>
        /// Loads the algorithms.
        /// </summary>
        /// <returns>The algorithms.</returns>
        private void LoadAlgorithms()
        {
            Algorithms.Add(new pushpop());
            Algorithms.Add(new espadd());
            Algorithms.Add(new ebppush());
            Algorithms.Add(new movzero());
            //Algorithms.Add(new movmov());
        }

        /// <summary>
        /// Optimizes code based on the loaded algorithms.
        /// </summary>
        public List<Instruction> Start()
        {
            bool start_position = false;
            var Temporary = new List<Instruction>();

            // Iterate over the opcodes
            for (int opcode = 0; opcode < Assembly.Count; opcode++)
            {

                // Fetch the instruction
                var instruction = Assembly[opcode];

                // Test if the instruction is a comment
                if (instruction is Comment)
                {

                    // Get the comment
                    var comment = ((Comment)instruction).Comments;

                    // Test if the comment is the optimization start flag
                    if (comment == OPTIMIZATION_START_FLAG)
                    {

                        // Clear temporaries
                        Temporary.Clear();
                        start_position = true;
                        continue;
                    }

                    // Test if the comment is the optimization end flag
                    if (comment == OPTIMIAZTION_END_FLAG)
                    {

                        // Iterate over the algorithms
                        foreach (var algo in Algorithms)
                        {

                            // Apply all optimizations on the temporaries
                            algo.Apply(Temporary);

                            // Clean up!
                            for (int index = 0; index < Temporary.Count; )
                            {
                                if (Temporary[index] == null)
                                {
                                    Temporary.RemoveAt(index);
                                    continue;
                                }
                                index++;
                            }
                        }

                        // Add the optimizations to the optimized assembly
                        OptimizedAssembly.Add(new Comment(OPTIMIZATION_START_FLAG));
                        OptimizedAssembly.AddRange(Temporary);
                        OptimizedAssembly.Add(new Comment(OPTIMIAZTION_END_FLAG));
                        start_position = false;
                        continue;
                    }
                }

                if (start_position == false)
                    OptimizedAssembly.Add(instruction);
                else
                    Temporary.Add(instruction);
            }

            // Return the optimized assembly
            return OptimizedAssembly;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Xor x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Xor : DestinationSourceSize
    {
        public Xor()
            : base("xor") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Xorps x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Xorps : DestinationSourceSize
    {
        public Xorps()
            : base("xorps") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          add x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Add : DestinationSourceSize
    {
        public Add()
            : base("add") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          addss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Addss : DestinationSource
    {
        public Addss()
            : base("addss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          adc x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class AddWithCarry : DestinationSourceSize
    {
        public AddWithCarry()
            : base("adc") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          and x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class And : DestinationSourceSize
    {
        public And()
            : base("and") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Literal Assembly Handling class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.IO;
using System.Linq;

namespace Atomix.Assembler
{
    public class AsmData
    {
        public readonly string Name;
        public readonly string Value;
        public readonly bool IsBssData;

        public AsmData(string aName, string aValue)
        {
            Name = aName;
            Value = aValue;
        }

        public AsmData(string aName, uint aLength)
        {
            Name = aName;
            Value = "resb " + aLength;
            IsBssData = true;
        }

        public AsmData(string aName, byte[] aValue)
        {
            Name = aName;
            if (aValue.LastOrDefault(a => a != 0) == 0)
            {
                IsBssData = true;
                Value = "resb " + aValue.Length;
            }
            else
            {
                Value = string.Format("db {0}", string.Join(", ", aValue.Select(a => a.ToString())));
            }
        }

        public AsmData(string aName, string[] aValue)
        {
            Name = aName;
            Value = string.Format("dd {0}", string.Join(", ", aValue.Select(a => a.ToString())));
            IsBssData = false;
        }

        public void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(string.Format("{0} {1}", Name, Value));
        }
    }
}
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ILCompiler.Assembler")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Hewlett-Packard")]
[assembly: AssemblyProduct("ILCompiler.Assembler")]
[assembly: AssemblyCopyright("Copyright © Hewlett-Packard 2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5624d4e9-3e8b-4185-8d7c-f7543d2b5565")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{C39C02EF-559E-47A6-98D9-E5B79D683948}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Atomix.Assembler</RootNamespace>
    <AssemblyName>Atomix.Assembler</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <SccProjectName>SAK</SccProjectName>
    <SccLocalPath>SAK</SccLocalPath>
    <SccAuxPath>SAK</SccAuxPath>
    <SccProvider>SAK</SccProvider>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\..\Build\Bin\</OutputPath>
    <DefineConstants>
    </DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\..\Build\Bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AsmData.cs" />
    <Compile Include="Comment.cs" />
    <Compile Include="Helper.cs" />
    <Compile Include="Instruction.cs" />
    <Compile Include="Label.cs" />
    <Compile Include="Literal.cs" />
    <Compile Include="Registers.cs" />
    <Compile Include="VirtualStack.cs" />
    <Compile Include="x86\Cvttss2si.cs" />
    <Compile Include="x86\Fidiv.cs" />
    <Compile Include="x86\Iretd.cs" />
    <Compile Include="x86\Lea.cs" />
    <Compile Include="x86\Const.cs" />
    <Compile Include="x86\Popad.cs" />
    <Compile Include="x86\Not.cs" />
    <Compile Include="x86\Pushad.cs" />
    <Compile Include="x86\Iret.cs" />
    <Compile Include="x86\ShiftRight.cs" />
    <Compile Include="x86\Or.cs" />
    <Compile Include="x86\Out.cs" />
    <Compile Include="x86\In.cs" />
    <Compile Include="x86\Sti.cs" />
    <Compile Include="x86\Cli.cs" />
    <Compile Include="x86\ShiftLeft.cs" />
    <Compile Include="x86\Fsub.cs" />
    <Compile Include="x86\Subss.cs" />
    <Compile Include="x86\Fdiv.cs" />
    <Compile Include="x86\Fmul.cs" />
    <Compile Include="x86\Mulss.cs" />
    <Compile Include="x86\Multiply.cs" />
    <Compile Include="x86\Divss.cs" />
    <Compile Include="x86\IDiv.cs" />
    <Compile Include="x86\Div.cs" />
    <Compile Include="x86\Add.cs" />
    <Compile Include="x86\Addss.cs" />
    <Compile Include="x86\AddWithCarry.cs" />
    <Compile Include="x86\And.cs" />
    <Compile Include="x86\Call.cs" />
    <Compile Include="x86\Cmp.cs" />
    <Compile Include="x86\Cmpss.cs" />
    <Compile Include="x86\Conversion.cs" />
    <Compile Include="x86\DestinationSource.cs" />
    <Compile Include="x86\DestinationSourceSize.cs" />
    <Compile Include="x86\Fadd.cs" />
    <Compile Include="x86\Fisttp.cs" />
    <Compile Include="x86\Fld.cs" />
    <Compile Include="x86\Fstp.cs" />
    <Compile Include="x86\Jmp.cs" />
    <Compile Include="x86\Leave.cs" />
    <Compile Include="x86\Mov.cs" />
    <Compile Include="x86\MovD.cs" />
    <Compile Include="x86\Movss.cs" />
    <Compile Include="x86\Movsx.cs" />
    <Compile Include="x86\Movzx.cs" />
    <Compile Include="x86\OnlyDestination.cs" />
    <Compile Include="x86\OnlySize.cs" />
    <Compile Include="x86\Pop.cs" />
    <Compile Include="x86\Push.cs" />
    <Compile Include="x86\Ret.cs" />
    <Compile Include="x86\Sub.cs" />
    <Compile Include="x86\SubWithCarry.cs" />
    <Compile Include="x86\test.cs" />
    <Compile Include="x86\Xor.cs" />
    <Compile Include="x86\Xorps.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\CompilerExt\Atomix.CompilerExt.csproj">
      <Project>{8974125b-52ca-48bd-92f5-c8b28f1c1dee}</Project>
      <Name>Atomix.CompilerExt</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          call x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public class Call : Instruction
    {
        public readonly string Address;
        public readonly bool FunctionLabel;

        public Call(string aAddress, bool aFunctionLabel = false)
            :base ("call")
        {
            Address = aAddress;
            // If FunctionLabel is set then it will look into Label Dictionary for real symbol name
            // check Compiler.FlushAsmFile();
            FunctionLabel = aFunctionLabel;
        }

        public override void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine("call " + Address);
        }

        public static void FlushText(StreamWriter aSW, string aAddress)
        {
            aSW.WriteLine("call " + aAddress);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          cli x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Cli : Instruction
    {
        public Cli()
            : base("cli") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          cmp x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Cmp : DestinationSourceSize
    {
        public Cmp()
            : base("cmp") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          cmpss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public class Cmpss : DestinationSource
    {
        public ComparePseudoOpcodes PseudoCode { get; set; }

        public Cmpss()
            : base("cmpss") { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            aSW.WriteLine(string.Format("{0} {1}, {2}, 0x{3}", Code, des, src, ((byte)PseudoCode).ToString("X")));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          assembly comment
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler
{
    public class Comment : Instruction
    {
        public readonly string Comments;

        public Comment(string aComment)
            :base ("Comment")
        {
            Comments = aComment;
        }

        public override void FlushText(StreamWriter sw)
        {
            sw.WriteLine("; " + Comments);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          misc function file
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public enum ComparePseudoOpcodes : byte
    {
        Equal = 0,
        LessThan = 1,
        LessThanOrEqualTo = 2,
        Unordered = 3,
        NotEqual = 4,
        NotLessThan = 5,
        NotLessThanOrEqualTo = 6,
        Ordered = 7
    };

    public enum ConditionalJumpEnum
    {
        JMP, JO, JNO, JS, JNS, JE, JZ, JNE, JNZ, JB, JNAE, JC,
        JNB, JAE, JNC, JBE, JNA, JA, JNBE, JL, JNGE, JGE, JNL,
        JLE, JNG, JG, JNLE, JP, JPE, JNP, JPO, JCXZ, JECXZ,
    };

    public enum ConversionCode
    {
        /// <summary>
        /// AL -> AX
        /// </summary>
        Byte_2_Word,
        /// <summary>
        /// AX -> EAX
        /// </summary>
        Word_2_Long,
        /// <summary>
        /// AX -> DX:AX
        /// </summary>
        SignedWord_2_SignedDoubleWord,
        /// <summary>
        /// EAX -> EAX:EDX
        /// </summary>
        SignedLong_2_SignedDoubleLong,
        /// <summary>
        /// EAX -> EAX:EDX
        /// </summary>
        SignedDWord_2_SignedQWord
    };

    public class Const
    {
        public static string SizeToString(byte aSize)
        {
            switch (aSize)
            {
                case 8:
                    return "byte";
                case 16:
                    return "word";
                case 32:
                    return "dword";
                case 64:
                    return "qword";
                default:
                    return "dword";
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Conversion type x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.IO;

namespace Atomix.Assembler.x86
{
    public class Conversion : Instruction
    {
        // Based on: http://docs.oracle.com/cd/E19455-01/806-3773/6jct9o0an/index.html

        public ConversionCode Type { get; set; }

        public Conversion()
            : base("conversion") { }

        public override void FlushText(StreamWriter sw)
        {
            switch (Type)
            {
                case ConversionCode.Byte_2_Word:
                    sw.WriteLine("cbtw");
                    break;
                case ConversionCode.Word_2_Long:
                    sw.WriteLine("cwtl");
                    break;
                case ConversionCode.SignedWord_2_SignedDoubleWord:
                    sw.WriteLine("cwtd");
                    break;
                case ConversionCode.SignedLong_2_SignedDoubleLong:
                    sw.WriteLine("cltd");
                    break;
                case ConversionCode.SignedDWord_2_SignedQWord:
                    sw.WriteLine("cdq");
                    break;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          cvttss2si x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Cvttss2si : DestinationSourceSize
    {
        public Cvttss2si()
            : base("cvttss2si") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          DestinationSource type Instructions abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public abstract class DestinationSource : Instruction
    {
        public Registers? DestinationReg;
        public string DestinationRef;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;

        public Registers? SourceReg;
        public string SourceRef;
        public bool SourceIndirect;
        public int? SourceDisplacement;

        public DestinationSource(string aMnemonic)
            : base(aMnemonic)  { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            aSW.WriteLine(string.Format("{0} {1}, {2}", Code, des, src));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          DestinationSourceSize type Instructions abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public abstract class DestinationSourceSize : Instruction
    {
        public Registers? DestinationReg;
        public string DestinationRef;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;

        public Registers? SourceReg;
        public string SourceRef;
        public bool SourceIndirect;
        public int? SourceDisplacement;

        public byte Size;

        public DestinationSourceSize(string aMnemonic)
            : base(aMnemonic)  { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            aSW.WriteLine(string.Format("{0} {3} {1}, {2}", Code, des, src, Const.SizeToString(Size)));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          div x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Div : OnlyDestination
    {
        public Div()
            : base("div") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          divss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Divss : DestinationSourceSize
    {
        public Divss()
            : base("divss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fadd x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fadd : OnlyDestination
    {
        public Fadd()
            : base("fadd") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fdiv x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fdiv : OnlyDestination
    {
        public Fdiv()
            : base("fdiv") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fidiv x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fidiv : OnlyDestination
    {
        public Fidiv()
            : base("fidiv") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fisttp x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fisttp : OnlyDestination
    {
        public Fisttp()
            : base("fisttp") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fld x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fld : OnlyDestination
    {
        public Fld()
            : base("fld") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fmul x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fmul : OnlyDestination
    {
        public Fmul()
            : base("fmul") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fstp x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fstp : OnlyDestination
    {
        public Fstp()
            : base("fstp") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          fsub x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Fsub : OnlyDestination
    {
        public Fsub()
            : base("fsub") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          helper class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;

using System.Runtime.InteropServices;

namespace Atomix.Assembler
{
    public static class AssemblyHelper
    {
        public static VirtualStack vStack;
        public static List<string> NasmHeaders;
        public static List<AsmData> DataMember;
        public static List<Instruction> AssemblerCode;
        public static Dictionary<string, _MemberInfo> StaticLabels;

        public static int DataMemberBssSegmentIndex
        {
            get;
            private set;
        }

        public static void InsertData(AsmData aAsmData)
        {
            if (DataMember == null)
                throw new Exception("DataMember not initalized");

            bool IsBssData = aAsmData.IsBssData;
            if (IsBssData)
                DataMember.Insert(DataMemberBssSegmentIndex++, aAsmData);
            else
                DataMember.Add(aAsmData);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          idiv x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class IDiv : OnlyDestination
    {
        public IDiv()
            : base("idiv") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          in x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class In : DestinationSource
    {
        public In()
            : base("in") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Instruction class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;
using Atomix.CompilerExt;

namespace Atomix.Assembler
{
    public abstract class Instruction
    {
        public readonly string Code;
        public readonly CPUArch CPUArch;

        public Instruction(string aMnemonic, CPUArch aCPUArch = CPUArch.x86)
        {
            Code = aMnemonic;
            CPUArch = aCPUArch;
        }

        public virtual void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(Code);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          iret x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Iret : Instruction
    {
        public Iret()
            : base("iret") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          iretd x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Iretd : Instruction
    {
        public Iretd()
            : base("iretd") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Jmp x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public class Jmp : Instruction
    {
        public ConditionalJumpEnum? Condition;
        public string DestinationRef;

        public Jmp()
            : base("jmp")
        { }

        public override void FlushText(StreamWriter aSW)
        {
            if (!Condition.HasValue)
                Condition = ConditionalJumpEnum.JMP;

            if (DestinationRef.StartsWith("."))
                DestinationRef = Label.PrimaryLabel + DestinationRef;

            var jmpStr = Condition.ToString().ToLower();
            if (Condition == ConditionalJumpEnum.JMP)
                aSW.WriteLine(string.Format("{0} {1}", jmpStr, DestinationRef));
            else
                aSW.WriteLine(string.Format("{0} near {1}", jmpStr, DestinationRef));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Label class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler
{
    public class Label : Instruction
    {
        public static string PrimaryLabel;
        public readonly string Name;
        public readonly string FinalisedName;

        public Label(string aName)
            :base ("Label")
        {
            Name = aName;
            if (aName.StartsWith("."))
            {
                FinalisedName = PrimaryLabel + Name;
            }
            else
            {
                FinalisedName = aName;
                PrimaryLabel = FinalisedName;
            }
        }

        public override void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(FinalisedName + ":");
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          lea x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Lea : DestinationSource
    {
        public Lea()
            : base("lea")
        { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          leave x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Leave : Instruction
    {
        public Leave()
            : base("leave") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Literal class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler
{
    public class Literal : Instruction
    {
        public readonly string Assembly;

        public Literal(string aAsm)
            :base ("Literal")
        {
            Assembly = aAsm;
        }

        public Literal(string aFormat, object aObj)
            : base("Literal")
        {
            Assembly = string.Format(aFormat, aObj);
        }

        public Literal(string aFormat, params object[] aObjs)
            : base("Literal")
        {
            Assembly = string.Format(aFormat, aObjs);
        }

        public override void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(Assembly);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Mov x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Mov : DestinationSourceSize
    {
        public Mov()
            : base("mov") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          MovD x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class MovD : DestinationSourceSize
    {
        public MovD()
            : base("movd") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Movss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Movss : DestinationSource
    {
        public Movss()
            : base("movss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Movsx x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public class Movsx : DestinationSourceSize
    {
        public Movsx()
            : base("movsx") { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            aSW.WriteLine(string.Format("{0} {1}, {3} {2}", Code, des, src, Const.SizeToString(Size)));
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using Atomix.CompilerExt;
using Atomix.Assembler;

namespace Atomix.Assembler.x86
{
    public class Movzx : DestinationSourceSize
    {
        public Movzx()
            : base("movzx") { }

        public override void FlushText(StreamWriter sw)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;
            string src = SourceReg.HasValue ? SourceReg.ToString() : SourceRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (SourceDisplacement > 0)
                src = src + " + 0x" + ((uint)SourceDisplacement).ToString("X");
            else if (SourceDisplacement < 0)
                src = src + " - 0x" + ((int)(-1 * SourceDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            if (SourceIndirect)
                src = "[" + src + "]";

            sw.WriteLine(string.Format("{0} {1}, {3} {2}", Code, des, src, Const.SizeToString(Size)));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Mulss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Mulss : DestinationSource
    {
        public Mulss()
            : base("mulss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Mul x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Multiply : OnlyDestination
    {
        public Multiply()
            : base("mul") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Not x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Not : OnlyDestination
    {
        public Not()
            : base("not") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          OnlyDestination type Instructions abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public abstract class OnlyDestination : Instruction
    {
        public Registers? DestinationReg;
        public string DestinationRef;
        public bool DestinationIndirect;
        public int? DestinationDisplacement;
        public byte Size;

        public OnlyDestination(string aMnemonic)
            : base(aMnemonic)  { }

        public override void FlushText(StreamWriter aSW)
        {
            string des = DestinationReg.HasValue ? DestinationReg.ToString() : DestinationRef;

            if (DestinationDisplacement > 0)
                des = des + " + 0x" + ((uint)DestinationDisplacement).ToString("X");
            else if (DestinationDisplacement < 0)
                des = des + " - 0x" + ((int)(-1 * DestinationDisplacement)).ToString("X");

            if (DestinationIndirect)
                des = "[" + des + "]";

            aSW.WriteLine(string.Format("{0} {2} {1}", Code, des, Const.SizeToString(Size)));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          OnlySize type Instructions abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System.IO;

namespace Atomix.Assembler.x86
{
    public abstract class OnlySize : Instruction
    {
        public byte Address;

        public OnlySize(string aMnemonic)
            : base(aMnemonic)  { }

        public override void FlushText(StreamWriter aSW)
        {
            aSW.WriteLine(string.Format("{0} 0x{1}", Code, Address.ToString("X")));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Or x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Or : DestinationSourceSize
    {
        public Or()
            : base("or") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Out x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Out : DestinationSource
    {
        public Out()
            : base("out") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Popad x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Popad : Instruction
    {
        public Popad()
            : base("popad") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Pop x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Pop : OnlyDestination
    {
        public Pop()
            : base("pop") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Pushad x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Pushad : Instruction
    {
        public Pushad()
            : base("pushad") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Push x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Push : OnlyDestination
    {
        public Push()
            : base("push") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Registers enum
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler
{
    public enum Registers
    {
        EAX, AX, AH, AL,
        EBX, BX, BH, BL,
        ECX, CX, CH, CL,
        EDX, DX, DH, DL,
        CS, DS, ES, FS,
        GS, SS, ESP, SP,
        EBP, BP, ESI, SI,
        EDI, DI, CR0, CR1,
        CR2, CR3, CR4, XMM0,
        XMM1, XMM2, XMM3, XMM4,
        XMM5, XMM6, XMM7, ST0,
        ST1, ST2, ST3, ST4,
        ST5, ST6, ST7, r0,
        r1, r2, r3, r4,
        r5, r6, r7, r8,
        r9, r10, r11, r12,
        r13, r14, r15
    };
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ret x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Ret : OnlySize
    {
        public Ret()
            : base("ret") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shl x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class ShiftLeft : DestinationSourceSize
    {
        public ShiftLeft()
            : base("shl") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Shr x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class ShiftRight : DestinationSourceSize
    {
        public ShiftRight()
            : base("shr") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sti x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Sti : Instruction
    {
        public Sti()
            : base("sti") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sub x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Sub : DestinationSourceSize
    {
        public Sub()
            : base("sub") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Subss x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Subss : DestinationSource
    {
        public Subss()
            : base("subss") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Sbb x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class SubWithCarry : DestinationSourceSize
    {
        public SubWithCarry()
            : base("sbb") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          test x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Test : DestinationSourceSize
    {
        public Test()
            : base("test") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Virtual Stack
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Collections.Generic;

namespace Atomix.Assembler
{
    public class VirtualStack
    {
        protected Stack<Items> mStack;

        public VirtualStack()
        {
            mStack = new Stack<Items>();
        }

        public int Count
        { get { return mStack.Count; } }

        public void Clear()
        {
            mStack.Clear();
        }

        public Items Pop()
        {
            return mStack.Pop();
        }

        public Items Peek()
        {
            return mStack.Peek();
        }

        public void Push(int aSize, Type aType)
        {
            mStack.Push(new Items(aSize, aType));
        }
    }

    public class Items
    {
        public readonly int Size;
        public readonly Type Type;
        public readonly bool IsFloat;
        public readonly bool IsSigned;

        public readonly bool IsInteger;

        public Items(int aSize, Type aType)
        {
            Size = aSize;
            Type = aType;

            // C# Data Types sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool
            // http://www.blackwasp.co.uk/CSharpNumericDataTypes.aspx

            IsInteger = (aType == typeof(bool)
                || aType == typeof(byte)
                || aType == typeof(sbyte)
                || aType == typeof(short)
                || aType == typeof(ushort)
                || aType == typeof(int)
                || aType == typeof(uint)
                || aType == typeof(long)
                || aType == typeof(ulong));
            IsFloat = (aType == typeof(float)
                || aType == typeof(double)
                || aType == typeof(decimal));
            IsSigned = (aType == typeof(sbyte)
                || aType == typeof(short)
                || aType == typeof(int)
                || aType == typeof(long)
                || aType == typeof(float)
                || aType == typeof(double)
                || aType == typeof(decimal));
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Xor x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Xor : DestinationSourceSize
    {
        public Xor()
            : base("xor") { }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Xorps x86 instruction
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Assembler.x86
{
    public class Xorps : DestinationSourceSize
    {
        public Xorps()
            : base("xorps") { }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Kernel_alpha.Drivers
{
    public abstract class BlockDevice
    {
        public abstract void Read(UInt32 SectorNo, uint SectorCount, byte[] xData);
        public abstract void Write(UInt32 SectorNo, uint SectorCount, byte[] xData);
    }
}
﻿using System;
using Kernel_alpha.x86.Intrinsic;
using Kernel_alpha.Lib;

namespace Kernel_alpha.Drivers.Video.VBE
{
    public class Bochslfb
    {
        const ushort VBE_DISPI_IOPORT_INDEX         = 0x01CE;
        const ushort VBE_DISPI_IOPORT_DATA          = 0x01CF;
        const ushort VBE_DISPI_INDEX_ID             = 0x0;
        const ushort VBE_DISPI_INDEX_XRES           = 0x1;
        const ushort VBE_DISPI_INDEX_YRES           = 0x2;
        const ushort VBE_DISPI_INDEX_BPP            = 0x3;
        const ushort VBE_DISPI_INDEX_ENABLE         = 0x4;
        const ushort VBE_DISPI_INDEX_BANK           = 0x5;
        const ushort VBE_DISPI_INDEX_VIRT_WIDTH     = 0x6;
        const ushort VBE_DISPI_INDEX_VIRT_HEIGHT    = 0x7;
        const ushort VBE_DISPI_INDEX_X_OFFSET       = 0x8;
        const ushort VBE_DISPI_INDEX_Y_OFFSET       = 0x9;

        const ushort VBE_DISPI_DISABLED             = 0x00;
        const ushort VBE_DISPI_ENABLED              = 0x01;
        const ushort VBE_DISPI_GETCAPS              = 0x02;
        const ushort VBE_DISPI_8BIT_DAC             = 0x20;
        const ushort VBE_DISPI_LFB_ENABLED          = 0x40;
        const ushort VBE_DISPI_NOCLEARMEM           = 0x80;

        IOPort Index, Data;
        MemoryBlock08 Fb;
        uint xRes, yRes, Bpp;
        bool IsValid;

        public Bochslfb()
        {
            //have to detect if bochs
            Index = new IOPort(VBE_DISPI_IOPORT_INDEX);
            Data = new IOPort(VBE_DISPI_IOPORT_DATA);
            Fb = new MemoryBlock08(0xE0000000);//It is static :(
            IsValid = true;
        }

        public void SetMode(ushort x_res, ushort y_res, ushort bpp)
        {
            if (!IsValid)
                return;

            this.xRes = x_res;
            this.yRes = y_res;
            this.Bpp = (uint)(bpp / 8);
            vbe_write(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_DISABLED);
            vbe_write(VBE_DISPI_INDEX_XRES, x_res);
            vbe_write(VBE_DISPI_INDEX_YRES, y_res);
            vbe_write(VBE_DISPI_INDEX_BPP, bpp);
            vbe_write(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);
        }

        public void SetPixel(uint x, uint y, uint color)
        {
            if (!IsValid)
                return;

            if (x >= xRes || y >= yRes)
                return;

            uint p = (x + (uint)(y * xRes)) * Bpp;
            Fb[p++] = (byte)(color & 0xFF);
            Fb[p++] = (byte)((color >> 8) & 0xFF);
            Fb[p++] = (byte)((color >> 16) & 0xFF);
        }

        public uint GetPixel(uint x, uint y)
        {
            if (!IsValid)
                return 0;

            if (x >= xRes || y >= yRes)
                return 0;

            uint p = (x + (uint)(y * xRes)) * Bpp;

            return (uint)(Fb[p + 2] >> 16 | Fb[p + 1] >> 8 | Fb[p]);
        }

        private void vbe_write(ushort index, ushort value)
        {
            Index.Outw(index);
            Data.Outw(value);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Boot Extension Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;
using Atomix.Kernel_H.Lib.Cairo;
using Atomix.Kernel_H.IO;
using Atomix.Kernel_H.Gui;
using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Devices;
using Atomix.Kernel_H.Arch.x86;
using Atomix.Kernel_H.Drivers.Video;
using Atomix.Kernel_H.IO.FileSystem;

using Atomix.Kernel_H.Lib;
using Atomix.Kernel_H.Drivers.Input;
using Atomix.Kernel_H.Drivers.buses.ATA;

namespace Atomix.Kernel_H
{
    internal class Boot
    {
        internal static int ClientID;
        internal static Pipe SystemClient;

        internal unsafe static void Init()
        {
            Debug.Write("Boot Init()\n");

            #region InitRamDisk
            if (Multiboot.RamDisk != 0)
            {
                var xFileSystem = new RamFileSystem(Multiboot.RamDisk, Multiboot.RamDiskSize);
                if (xFileSystem.IsValid)
                    VirtualFileSystem.MountDevice(null, xFileSystem);
                else
                    throw new Exception("RamDisk Corrupted!");
            }
            else
                throw new Exception("RamDisk not found!");
            #endregion
            #region PS2 Devices
            Keyboard.Setup();
            Mouse.Setup();
            #endregion
            #region Compositor

            SystemClient = new Pipe(Compositor.PACKET_SIZE, 100);
            Compositor.Setup(Scheduler.SystemProcess);
            ClientID = Compositor.CreateConnection(SystemClient);

            #endregion
            #region IDE Devices
            LoadIDE(true, true);
            LoadIDE(false, true);
            #endregion

            //FILE READING TEST
            /*var stream = VirtualFileSystem.GetFile("disk0/gohu-11.bdf");
            if (stream != null)
                Debug.Write(stream.ReadToEnd());
            else
                Debug.Write("File not found!\n");*/
            Gui.Programs.Explorer.Init(SystemClient);
            Core.GC.Collect();
            BootAnimation();
            while (true) ;
        }

        internal static unsafe void BootAnimation()
        {
            var xData = new byte[Compositor.PACKET_SIZE];
            var Request = (GuiRequest*)xData.GetDataOffset();
            Request->ClientID = ClientID;

            DrawWindow(Request, xData);
        }

        private static unsafe void DrawWindow(GuiRequest* request, byte[] xData)
        {
            request->Type = RequestType.NewWindow;
            request->Error = ErrorType.None;
            var window = (NewWindow*)request;
            window->X = 340;
            window->Y = 159;
            window->Width = 600;
            window->Height = 450;

            Compositor.Server.Write(xData);

            SystemClient.Read(xData);
            if (request->Error != ErrorType.None)
            {
                Debug.Write("Error5: %d\n", (int)request->Error);
                return;
            }

            string HashCode = new string(window->Buffer);
            var aBuffer = SHM.Obtain(HashCode, 0, false);
            int winID = window->WindowID;
            Debug.Write("winID: %d\n", winID);

            uint surface = Cairo.ImageSurfaceCreateForData(600 * 4, 450, 600, ColorFormat.ARGB32, aBuffer);
            uint cr = Cairo.Create(surface);

            Cairo.SetOperator(Operator.Over, cr);

            Cairo.Rectangle(450, 600, 0, 0, cr);
            Cairo.SetSourceRGBA(1, 0.41, 0.41, 0.41, cr);
            Cairo.Fill(cr);
            Cairo.Rectangle(446, 596, 2, 2, cr);
            Cairo.SetSourceRGBA(1, 0.87, 0.87, 0.87, cr);
            Cairo.Fill(cr);
            Cairo.Rectangle(410, 580, 30, 10, cr);
            Cairo.SetSourceRGBA(1, 1, 1, 1, cr);
            Cairo.Fill(cr);

            Cairo.SetSourceRGBA(1, 0.41, 0.41, 0.41, cr);
            Cairo.SelectFontFace(FontWeight.Normal, FontSlant.Normal, Marshal.C_String(""), cr);
            Cairo.SetFontSize(15, cr);
            Cairo.MoveTo(18, 215, cr);
            Cairo.ShowText(Marshal.C_String("Atom OS : Installation Guide"), cr);

            Cairo.SelectFontFace(FontWeight.Bold, FontSlant.Normal, Marshal.C_String(""), cr);
            Cairo.MoveTo(18, 580, cr);
            Cairo.ShowText(Marshal.C_String("X"), cr);

            Cairo.SurfaceFlush(surface);
            Cairo.Destroy(cr);
            Cairo.SurfaceDestroy(surface);

            request->Type = RequestType.Redraw;
            var req = (Redraw*)request;
            req->WindowID = winID;
            req->X = 0;
            req->Y = 0;
            req->Width = 600;
            req->Height = 450;
            Compositor.Server.Write(xData);

            Debug.Write("Time: %d\n", Timer.TicksFromStart);
            while(true)
            {
                SystemClient.Read(xData);
                if (request->Error != ErrorType.None) continue;
                if (request->Type != RequestType.MouseEvent) continue;
                var mreq = (MouseEvent*)request;
                if (mreq->WindowID != winID) continue;
                if ((mreq->Function & MouseFunction.Click) != 0)
                {
                    int x = mreq->Xpos;
                    int y = mreq->Ypos;
                    if (y < 40)
                    {
                        request->Type = RequestType.DragRequest;
                        var mv = (DragRequest*)request;
                        mv->WindowID = winID;
                        Compositor.Server.Write(xData);
                    }
                }
            }
        }

        private static unsafe void DrawTaskbar(GuiRequest* request, byte[] xData)
        {
            request->Type = RequestType.NewWindow;
            request->Error = ErrorType.None;
            var taskbar = (NewWindow*)request;
            int height = 30;
            taskbar->X = 0;
            taskbar->Y = 0;
            taskbar->Width = VBE.Xres;
            taskbar->Height = height;

            Compositor.Server.Write(xData);

            SystemClient.Read(xData);
            if (request->Error != ErrorType.None)
            {
                Debug.Write("Error4: %d\n", (int)request->Error);
                return;
            }

            string HashCode = new string(taskbar->Buffer);
            var aBuffer = SHM.Obtain(HashCode, 0, false);
            int winID = taskbar->WindowID;
            Debug.Write("winID: %d\n", winID);

            uint surface = Cairo.ImageSurfaceCreateForData(VBE.Xres * 4, height, VBE.Xres, ColorFormat.ARGB32, aBuffer);
            uint cr = Cairo.Create(surface);

            uint pattern = Cairo.PatternCreateLinear(height, 0, 0, 0);
            Cairo.PatternAddColorStopRgba(0.7, 0.42, 0.42, 0.42, 0, pattern);
            Cairo.PatternAddColorStopRgba(0.6, 0.36, 0.36, 0.36, 0.5, pattern);
            Cairo.PatternAddColorStopRgba(0.7, 0.42, 0.42, 0.42, 1, pattern);

            Cairo.SetOperator(Operator.Over, cr);
            Cairo.Rectangle(height, VBE.Xres, 0, 0, cr);
            Cairo.SetSource(pattern, cr);
            Cairo.Fill(cr);

            Cairo.Rectangle(2, VBE.Xres, height - 2, 0, cr);
            Cairo.SetSourceRGBA(0.7, 0.41, 0.41, 0.41, cr);
            Cairo.Fill(cr);

            Cairo.SetSourceRGBA(1, 1, 1, 1, cr);
            Cairo.SelectFontFace(FontWeight.Bold, FontSlant.Normal, Marshal.C_String(""), cr);
            Cairo.SetFontSize(20, cr);
            Cairo.MoveTo(20, 1215, cr);
            Cairo.ShowText(Marshal.C_String("20:10"), cr);

            Cairo.PatternDestroy(pattern);
            Cairo.Destroy(cr);
            Cairo.SurfaceDestroy(surface);

            request->Type = RequestType.Redraw;
            var req = (Redraw*)request;
            req->WindowID = winID;
            req->X = 0;
            req->Y = 0;
            req->Width = VBE.Xres;
            req->Height = height;
            Compositor.Server.Write(xData);
        }

        internal static void LoadIDE(bool IsPrimary, bool IsMaster)
        {
            var xIDE = new IDE(IsPrimary, IsMaster);

            bool Clean = true;
            if (xIDE.IsValid)
            {
                switch(xIDE.Device)
                {
                    case Device.IDE_ATA:
                        {
                            /*
                             * First we check If it has partitions,
                             *      If parition.count > 0
                             *          Add Individual Partitions
                             */
                            var xMBR = new MBR(xIDE);
                            if (xMBR.PartInfo.Count > 0)
                            {
                                for (int i = 0; i < xMBR.PartInfo.Count; i++)
                                {
                                    /*
                                     * Iterate over all FileSystem Drivers and check which is valid
                                     */
                                    var xFileSystem = new FatFileSystem(xMBR.PartInfo[i]);
                                    if (xFileSystem.IsValid)
                                    {
                                        VirtualFileSystem.MountDevice(null, xFileSystem);
                                        Clean = false;
                                    }
                                }
                            }
                        }
                        break;
                }
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          FAT Helper
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.IO.FileSystem.FAT.Find
{
    internal class ByCluster : Comparison
    {
        internal readonly uint Cluster;
        internal ByCluster(uint aCluster)
        {
            Cluster = aCluster;
        }

        internal override bool Compare(byte[] data, int offset, FatType type)
        {
            switch ((FileNameAttribute)data[offset + (uint)Entry.DOSName])
            {
                case FileNameAttribute.LastEntry:
                case FileNameAttribute.Deleted:
                case FileNameAttribute.Escape:
                case FileNameAttribute.Dot:
                    return false;
                default:
                    break;
            }

            uint startcluster = FatFileSystem.GetClusterEntry(data, (uint)offset, type);
            if (startcluster == Cluster)
                return true;

            return false;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class Byte
    {
        [Plug("System_String_System_Byte_ToString__")]
        public static string ToString(ref byte aThis)
        {
            return Number.ToString8Bit(aThis, false);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Cairo Native Methods
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Runtime.InteropServices;

using Atomixilc.Attributes;

namespace Atomix.Kernel_H.Lib.Cairo
{
    internal static class Cairo
    {
        const string LIBRARY = "libcairo.a";

        /* Note: Because Arguments are pushed from left to right by the current compiler
         * we have to make it reverse for successful function calling
         */

        /// <summary>
        /// cairo_public cairo_t *
        /// cairo_create(cairo_surface_t* target);
        /// </summary>
        [NoException]
        [Plug("cairo_create")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern uint Create(uint target);

        /// <summary>
        /// cairo_public cairo_surface_t *
        /// cairo_image_surface_create(cairo_format_t format,
        ///                             int width,
        ///                             int height);
        /// </summary>
        [NoException]
        [Plug("cairo_image_surface_create")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern uint ImageSurfaceCreate(int height, int width, ColorFormat format);

        /// <summary>
        /// cairo_public cairo_surface_t *
        /// cairo_image_surface_create_for_data(unsigned char* data,
        ///                                     cairo_format_t format,
        ///                                     int width,
        ///                                     int height,
        ///                                     int stride);
        /// </summary>
        [NoException]
        [Plug("cairo_image_surface_create_for_data")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern uint ImageSurfaceCreateForData(int stride, int height, int width, ColorFormat format, uint data);
        
        /// <summary>
        /// cairo_public void
        /// cairo_set_source_rgb(cairo_t* cr, double red, double green, double blue);
        /// </summary>
        [NoException]
        [Plug("cairo_set_source_rgb")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SetSourceRGB(double blue, double green, double red, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_set_source_rgba(cairo_t* cr, double red, double green, double blue,
        ///                        double alpha);
        /// </summary>
        [NoException]
        [Plug("cairo_set_source_rgba")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SetSourceRGBA(double alpha, double blue, double green, double red, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_save (cairo_t *cr);
        /// </summary>
        [NoException]
        [Plug("cairo_save")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Save(uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_restore (cairo_t *cr);
        /// </summary>
        [NoException]
        [Plug("cairo_restore")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Restore(uint cr);

        /// <summary>
        /// cairo_public unsigned char *
        /// cairo_image_surface_get_data(cairo_surface_t* surface);
        /// </summary>
        [NoException]
        [Plug("cairo_image_surface_get_data")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern uint ImageSurfaceGetData(uint surface);

        /// <summary>
        /// cairo_public void
        /// cairo_show_text(cairo_t* cr, const char* utf8);
        /// </summary>
        [NoException]
        [Plug("cairo_show_text")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void ShowText(sbyte* utf8, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_rectangle(cairo_t* cr,
        ///                 double x, double y,
        ///                 double width, double height);
        /// </summary>
        [NoException]
        [Plug("cairo_rectangle")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Rectangle(double height, double width, double y, double x, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_fill(cairo_t* cr);
        /// </summary>
        [NoException]
        [Plug("cairo_fill")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Fill(uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_stroke(cairo_t* cr);
        /// </summary>
        [NoException]
        [Plug("cairo_stroke")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Stroke(uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_destroy(cairo_t* cr);
        /// </summary>
        [NoException]
        [Plug("cairo_destroy")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Destroy(uint cr);

        /// <summary>
        /// cairo_public int
        /// cairo_version(void);
        /// </summary>
        [NoException]
        [Plug("cairo_version")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int Version();

        /// <summary>
        /// cairo_public void
        /// cairo_surface_destroy(cairo_surface_t* surface);
        /// </summary>
        [NoException]
        [Plug("cairo_surface_destroy")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SurfaceDestroy(uint surface);

        /// <summary>
        /// cairo_public int
        /// cairo_format_stride_for_width(cairo_format_t format,
        ///                                int width);
        /// </summary>
        [NoException]
        [Plug("cairo_format_stride_for_width")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern int FormatStrideForWidth(int width, ColorFormat format);


        /// <summary>
        /// cairo_public void
        /// cairo_surface_flush(cairo_surface_t* surface);
        /// </summary>
        [NoException]
        [Plug("cairo_surface_flush")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SurfaceFlush(uint surface);

        /// <summary>
        /// cairo_public void
        /// cairo_set_line_width(cairo_t* cr, double width);
        /// </summary>
        [NoException]
        [Plug("cairo_set_line_width")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SetLineWidth(double width, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_set_source (cairo_t *cr, cairo_pattern_t *source);
        /// </summary>
        [NoException]
        [Plug("cairo_set_source")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SetSource(uint source, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_paint(cairo_t* cr);
        /// </summary>
        [NoException]
        [Plug("cairo_paint")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Paint(uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_fill_preserve(cairo_t* cr);
        /// </summary>
        [NoException]
        [Plug("cairo_fill_preserve")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void FillPreserve(uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_set_dash(cairo_t* cr,
        ///                 const double* dashes,
        ///                 int num_dashes,
        ///                 double offset);
        /// </summary>
        [NoException]
        [Plug("cairo_set_dash")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SetDash(double offset, int num_dashes, uint dashes, uint cr);

        /// <summary>
        /// cairo_public cairo_status_t
        /// cairo_status(cairo_t* cr);
        /// </summary>
        [NoException]
        [Plug("cairo_status")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Status Status(uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_clip(cairo_t* cr);
        /// </summary>
        [NoException]
        [Plug("cairo_clip")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Clip(uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_clip(cairo_t* cr);
        /// </summary>
        [NoException]
        [Plug("cairo_reset_clip")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void ResetClip(uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_pattern_destroy (cairo_pattern_t *pattern);
        /// </summary>
        [NoException]
        [Plug("cairo_pattern_destroy")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void PatternDestroy(uint pattern);

        /// <summary>
        /// cairo_public cairo_status_t
        /// cairo_surface_write_to_png(cairo_surface_t* surface,
        ///                             const char* filename);
        /// </summary>
        [NoException]
        [Plug("cairo_surface_write_to_png")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern Status SurfaceWriteToPng(uint filename, uint surface);

        /// <summary>
        /// cairo_public void
        /// cairo_select_font_face(cairo_t* cr,
        ///                         const char* family,
        ///                         cairo_font_slant_t   slant,
		///                         cairo_font_weight_t weight);
        /// </summary>
        [NoException]
        [Plug("cairo_select_font_face")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe void SelectFontFace(FontWeight weight, FontSlant slant, sbyte* family, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_set_operator (cairo_t *cr, cairo_operator_t op);
        /// </summary>
        [NoException]
        [Plug("cairo_set_operator")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SetOperator(Operator op, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_set_font_size(cairo_t* cr, double size);
        /// </summary>
        [NoException]
        [Plug("cairo_set_font_size")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SetFontSize(double size, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_translate (cairo_t *cr, double tx, double ty);
        /// </summary>
        [NoException]
        [Plug("cairo_translate")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void Translate(double y, double x, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_move_to(cairo_t* cr, double x, double y);
        /// </summary>
        [NoException]
        [Plug("cairo_move_to")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void MoveTo(double y, double x, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_line_to(cairo_t* cr, double x, double y);
        /// </summary>
        [NoException]
        [Plug("cairo_line_to")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void LineTo(double y, double x, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_rel_line_to(cairo_t* cr, double dx, double dy);
        /// </summary>
        [NoException]
        [Plug("cairo_rel_line_to")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void RelativeLineTo(double y, double x, uint cr);

        /// <summary>
        /// cairo_public void
        /// cairo_curve_to(cairo_t* cr,
        ///                 double x1, double y1,
        ///                 double x2, double y2,
        ///                 double x3, double y3);
        /// </summary>
        [NoException]
        [Plug("cairo_curve_to")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void CurveTo(double y3, double x3, double y2, double x2, double y1, double x1, uint cr);

        /// <summary>
        /// cairo_public cairo_surface_t *
        /// cairo_image_surface_create_from_png (const char	*filename);
        /// </summary>
        [NoException]
        [Plug("cairo_image_surface_create_from_png")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern unsafe uint ImageSurfaceFromPng(sbyte* filename);

        /// <summary>
        /// cairo_public void
        /// cairo_set_source_surface(cairo_t* cr,
        ///                           cairo_surface_t* surface,
        ///                           double x, double y);
        /// </summary>
        [NoException]
        [Plug("cairo_set_source_surface")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void SetSourceSurface(double y, double x, uint surface, uint cr);

        /// <summary>
        /// cairo_public cairo_pattern_t *
        /// cairo_pattern_create_linear (double x0, double y0,
        ///                                double x1, double y1);
        /// </summary>
        [NoException]
        [Plug("cairo_pattern_create_linear")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern uint PatternCreateLinear(double y1, double x1, double y0, double x0);

        /// <summary>
        /// cairo_public void
        /// cairo_pattern_add_color_stop_rgba (cairo_pattern_t *pattern,
        ///                                     double offset,
        ///                                     double red, double green, double blue,
        ///                                     double alpha);
        /// </summary>
        [NoException]
        [Plug("cairo_pattern_add_color_stop_rgba")]
        [DllImport(LIBRARY, CallingConvention = CallingConvention.Cdecl)]
        internal static extern void PatternAddColorStopRgba(double alpha, double blue, double green, double red, double offset, uint pattern);
    }
}﻿using System;
using System.Collections.Generic;
using Kernel_alpha.Drivers;
using Kernel_alpha.Drivers.Input;
using Atomix.CompilerExt.Attributes;

using Atomix.Assembler;
using Atomix.Assembler.x86;
using Atomix.CompilerExt;
using Core = Atomix.Assembler.AssemblyHelper;
using Kernel_alpha.x86.Intrinsic;

using Kernel_alpha.FileSystem.FAT.Lists;
using Kernel_alpha.FileSystem.FAT;

using Kernel_alpha.Lib.Encoding;
using Screen = Kernel_alpha.Drivers.Video.VBE.VBE2_0;

namespace Kernel_alpha
{
    public static class Caller
    {
        public static unsafe void Start()
        {
            Console.Clear();
            Console.WriteLine ("                                         ");

            // Load System Elements
            Global.Init();
            Console.WriteLine ("Welcome to AtomixOS!");
            Console.WriteLine ();

            Console.WriteLine ("Shutdown: Ctrl+S");
            Console.WriteLine ("Reboot: Ctrl+R");

            // Just for mouse testing
            Multitasking.CreateTask(pTask1, true);
            Multitasking.CreateTask(pTask2, true);
            Console.WriteLine("Block Device Count::" + Global.Devices.Count.ToString());
            uint c = 0;
            for (int i = 0; i < Global.Devices.Count; i++)
            {
                if (Global.Devices[i] is Drivers.Partition)
                    c++;
            }

            Console.WriteLine("Partition Count::" + c.ToString());
            Console.WriteLine();
            Multitasking.CreateTask(pFAT32test, true);
            Multitasking.CreateTask(pSerialTest, true);
            Multitasking.CreateTask(pIdleTask, true);
            //Screen.Setup();
            //Screen.Clear(0xFFBB977E);
        }

        private static uint pIdleTask;
        private static void IdleTask()
        {
            while (true)
            {
                x86.Intrinsic.Native.Halt();
            }
        }
        private static uint TestV = 0;
        private static uint pSerialTest;
        private static void SerialTest()
        {
            while (true)
            {
                var xRAM = TestV;//x86.Heap.AllocateMem(0);
                x86.Serials.Write(0xFA);
                x86.Serials.Write((byte)(xRAM >> 0));
                x86.Serials.Write((byte)(xRAM >> 8));
                x86.Serials.Write((byte)(xRAM >> 16));
                x86.Serials.Write((byte)(xRAM >> 24));
            }
        }

        public static void PrintEntries(List<Base> xEntries)
        {
            int filecount = 0;
            int dircount = 0;
            for (int i = 0; i < xEntries.Count; i++)
            {
                var Entry = xEntries[i];
                if (Entry is Directory)
                {
                    dircount++;
                    Console.WriteLine("<DIR>    " + Entry.EntryName);
                }
                else if (Entry is File)
                {
                    filecount++;
                    Console.WriteLine("<File>    " + Entry.EntryName + "    " + ((File)Entry).EntryDetails.FileSize.ToString());
                }
            }
            Console.WriteLine();
            Console.WriteLine("#   " + xEntries.Count.ToString() + " " + "Entry(s)");
            Console.WriteLine("#   " + filecount.ToString() + " " + "File(s)");
            Console.WriteLine("#   " + dircount.ToString() + " " + "Dir(s)");
            Console.WriteLine();
        }

        public static unsafe void Update()
        {
            if (Global.KBD.Ctrl)
            {
                var s = Global.KBD.ReadKey();
                if (s.Code == KeyCode.S)
                {
                    Console.WriteLine ("Shutdown");
                    Global.ACPI.Shutdown();
                }
                else if (s.Code == KeyCode.R)
                {
                    Console.WriteLine ("Reboot");
                    Global.ACPI.Reboot();
                }
                else if (s.Code == KeyCode.C)
                {
                    Console.Clear();
                }
                else if (s.Code == KeyCode.V)
                {
                    var svga = new Drivers.Video.VMWareSVGAII();
                    svga.SetMode(1024, 768, 32);
                    svga.Clear(0xFFFFFF);
                    svga.Update(0, 0, 1024, 768);
                }
                else if (s.Code == KeyCode.G)
                {
                    var vga = new Drivers.Video.VGAScreen();
                    vga.SetMode0();
                    byte c = 0;
                    /*for (uint i = 0; i < vga.Width; i ++)
                    {
                        for (uint j = 0; j < vga.Height; j++)
                        {
                            vga.SetPixel_640_480(i, j, 0);
                        }
                    }*/

                    for (uint i = 0; i < 10; i++)
                    {
                        for (uint j = 0; j < 400; j++)
                        {
                            vga.SetPixel_640_480(i, j, 0x0);
                            vga.SetPixel_640_480(i + 10, j, 0x1);
                            vga.SetPixel_640_480(i + 20, j, 0x2);
                            vga.SetPixel_640_480(i + 30, j, 0x3);
                            vga.SetPixel_640_480(i + 40, j, 0x4);
                            vga.SetPixel_640_480(i + 50, j, 0x5);
                            vga.SetPixel_640_480(i + 60, j, 0x6);
                            vga.SetPixel_640_480(i + 70, j, 0x7);
                            vga.SetPixel_640_480(i + 80, j, 0x8);
                            vga.SetPixel_640_480(i + 90, j, 0x9);
                            vga.SetPixel_640_480(i + 100, j, 0xA);
                            vga.SetPixel_640_480(i + 110, j, 0xB);
                            vga.SetPixel_640_480(i + 120, j, 0xC);
                            vga.SetPixel_640_480(i + 130, j, 0xD);
                            vga.SetPixel_640_480(i + 140, j, 0xE);
                            vga.SetPixel_640_480(i + 150, j, 0xF);
                        }
                    }
                }
                else if (s.Code == KeyCode.B)
                {
                    var bochs = new Drivers.Video.VBE.Bochslfb();
                    bochs.SetMode(1024, 768, 24);
                    for (uint i = 0; i < 1024; i++)
                    {
                        for (uint j = 0; j < 768; j++)
                        {
                            bochs.SetPixel(i, j, 0xFFFFFF);
                        }
                    }
                }
                else if (s.Code == KeyCode.P)
                {
                    uint* p = (uint*)0xA0000000;
                    uint t = *p;
                }
            }
        }

        private static uint pTask1;
        public static unsafe void Task1()
        {
            do
            {
                WriteScreen("X:", 6);
                //var s = ((uint)Global.Mouse.X).ToString();
                //var J = ((uint)Global.Mouse.Y).ToString();
                WriteScreen("Y:", 24);

                switch (Global.Mouse.Button)
                {
                    case MouseButtons.Left:
                        WriteScreen("L", 40);
                        break;
                    case MouseButtons.Right:
                        WriteScreen("R", 40);
                        break;
                    case MouseButtons.Middle:
                        WriteScreen("M", 40);
                        break;
                    case MouseButtons.None:
                        WriteScreen("N", 40);
                        break;
                    default:
                        WriteScreen("E", 40);
                        break;
                }
                Thread.Sleep(15);
            }
            while (true);
        }

        public static unsafe void WriteScreen(string s, int p)
        {
            byte* xA = (byte*)0xB8000;
            for (int i = 0; i < s.Length; i++)
            {
                xA[p++] = (byte)s[i];
                xA[p++] = 0x0B;
            }
        }

        private static uint pTask2;
        public static unsafe void Task2()
        {
            try
            {
                byte* xA = (byte*)0xB8000;
                byte c = 0;
                uint a = 0;
                do
                {
                    xA[0] = c;
                    xA[1] = 0xd;
                    c++;
                    if (c >= 255)
                        c = 0;
                    a++;
                    Thread.Sleep(10);
                }
                while (true);
            }
            catch (Exception e)
            {
                Console.Write("Died::");
                Console.WriteLine(e.Message);
                Thread.Die();
            }
        }

        private static uint pFAT32test;
        public static void FAT32test()
        {
            if (Global.Devices.Count >= 1)
            {
                var xFAT = new FileSystem.FatFileSystem(Global.Devices[2]);
                if (xFAT.IsValid)
                {
                    for (; ; )
                    {
                        string xTemp = Console.ReadLine();
                        string[] xStrName = xTemp.Split(' ');
                        string xCommand = xStrName[0].Trim('\0');

                        string xDirName = null;
                        if (xStrName.Length > 1)
                            xDirName = xStrName[1].Trim('\0');

                        switch (xCommand.ToLower())
                        {
                            case "cd":
                                {
                                    try
                                    {
                                        xFAT.ChangeDirectory(xDirName);
                                    }
                                    catch (Exception e)
                                    {
                                        Console.WriteLine(e.Message);
                                    }
                                    break;
                                }
                            case "dir":
                                {
                                    try
                                    {
                                        PrintEntries(xFAT.ReadFATDirectory(xDirName));
                                    }
                                    catch (Exception e)
                                    {
                                        Console.WriteLine(e.Message);
                                    }
                                    break;
                                }
                            case "open":
                                {
                                    var xData = xFAT.ReadFile(xDirName);
                                    Console.WriteLine(ASCII.GetString(xData, 0, xData.Length));
                                    Console.WriteLine();
                                    break;
                                }
                            case "mkdir":
                                {
                                    try
                                    {
                                        xFAT.MakeDirectory(xDirName);
                                    }
                                    catch (Exception e)
                                    {
                                        Console.WriteLine(e.Message);
                                    }
                                    break;
                                }
                            case "run":
                                {
                                    try
                                    {
                                        var xData = xFAT.ReadFile(xDirName);
                                        unsafe
                                        {
                                            //Okay this code is working fine
                                            /* ; Example code
                                            * use32
                                            * main:
                                            *  push dword EBP
                                            *  mov dword EBP, ESP
                                            *  mov dword EAX, 0xB8000
                                            *  mov dword [EAX + 0x2], 0x0A41
                                            *  leave
                                            *  ret 0x0
                                            *
                                            * ; Command Line
                                            * nasm -fbin test.asm -o test.atm
                                            */
                                            var len = xData.Length;
                                            var xAdd = x86.Heap.AllocateMem((uint)len);
                                            var Mem = (byte*)xAdd;
                                            for (int i = 0; i < len; i++)
                                            {
                                                Mem[i] = xData[i];
                                            }
                                            CallExecutableFile(xAdd);
                                        }
                                    }
                                    catch (Exception e)
                                    {
                                        Console.WriteLine(e.Message);
                                    }
                                }
                                break;
                            default:
                                Console.WriteLine("No such command exist");
                                break;
                        }
                    }
                }
            }
            Console.WriteLine("FAT32 Thread died :(");
            while(true)
            {
                Console.ReadLine();
            }
            Thread.Die();
        }

        [Assembly(true)]
        private static void CallExecutableFile(uint pos)
        {
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EBP, SourceDisplacement = 0x8, SourceIndirect = true });
            Core.AssemblerCode.Add(new Call("EAX"));
        }
    }
}
﻿using System;
using Kernel_alpha.x86.Intrinsic;

namespace Kernel_alpha.Drivers
{
    public static class CMOS
    {
        #region enum
        enum cmos : byte
        {
            Address = 0x70,
            Data = 0x71
        }

        enum Offset : byte
        {
            RTC_Second = 0,
            RTC_Minute = 2,
            RTC_Hour = 4,
            RTC_DayOfWeek = 6,
            RTC_Day = 7,
            RTC_Month = 8,
            RTC_Year = 9,
            RTC_CenturyDay = 50,
            RTC_Century = 72
        }
        #endregion

        public static uint Seconds
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_Second));
            }
        }

        public static uint Minutes
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_Minute));
            }
        }

        public static uint Hours
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_Hour));
            }
        }

        public static uint Day
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_Day));
            }
        }

        public static uint DayOfWeek
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_DayOfWeek));
            }
        }

        public static uint Month
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_Month));
            }
        }

        public static uint Year
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_Year));
            }
        }

        public static uint CenturyDay
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_CenturyDay));
            }
        }

        public static uint Century
        {
            get
            {
                WaitForReady();
                return FromBCD(RTC_Register((byte)Offset.RTC_Century));
            }
        }

        private static uint FromBCD(uint value)
        {
            return (uint)(((value >> 4) & 0x0F) * 10 + (value & 0x0F));
        }

        private static byte RTC_Register(byte aNo)
        {
            IOPort.Outb((byte)cmos.Address, aNo);
            return IOPort.Inb((byte)cmos.Data);
        }

        private static void WaitForReady()
        {
            do
            {
                IOPort.Outb((byte)cmos.Address, 10);
            }
            while ((IOPort.Inb((byte)cmos.Data) & 0x80) != 0);
        }
    }
}
﻿using System;

namespace Atomix.Kernel_H.Lib.Cairo
{
    /* typedef enum _cairo_format {
     *      CAIRO_FORMAT_INVALID   = -1,
     *      CAIRO_FORMAT_ARGB32    = 0,
     *      CAIRO_FORMAT_RGB24     = 1,
     *      CAIRO_FORMAT_A8        = 2,
     *      CAIRO_FORMAT_A1        = 3,
     *      CAIRO_FORMAT_RGB16_565 = 4,
     *      CAIRO_FORMAT_RGB30     = 5
     * } cairo_format_t;
     */
    internal enum ColorFormat : int
    {
        Invalid     = -1,
        ARGB32      = 0,
        RGB24       = 1,
        A8          = 2,
        A1          = 3,
        RGB16_565   = 4,
        RGB30       = 5
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Atom GUI Compositor Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;

using Atomix.Kernel_H.IO;
using Atomix.Kernel_H.Lib;
using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Lib.Cairo;
using Atomix.Kernel_H.Drivers.Video;
using Atomix.Kernel_H.Drivers.Input;

namespace Atomix.Kernel_H.Gui
{
    internal static class Compositor
    {
        internal const int PACKET_SIZE = 48;

        static Window ActiveWindow;
        static IList<Pipe> Clients;
        static IQueue<uint> RedrawRects;

        internal static Pipe Server;

        /* Locks */
        static uint WindowsLock;
        static uint StackingLock;
        static uint RedrawRectsLock;

        /* Mouse Surfaces */
        static uint MouseSurface;
        static uint MouseIdleSurface;
        static uint MouseHelpSurface;
        static uint MouseClipSurface;

        /* Other Surfaces */
        static uint MainSurface;
        static uint VideoSurface;

        /* Cairo Contexts */
        static uint MainContext;
        static uint VideoContext;

        /* Windows */
        static Window MouseWindow;
        static IList<Window> Windows;
        static IList<Window> Stacking;

        internal unsafe static void Setup(Process aParent)
        {
            Server = new Pipe(PACKET_SIZE, 1000);

            Clients = new IList<Pipe>();
            Windows = new IList<Window>();
            Stacking = new IList<Window>();
            RedrawRects = new IQueue<uint>();

            /* Mouse Surfaces */
            MouseIdleSurface = Cairo.ImageSurfaceFromPng(Marshal.C_String("disk0/cursor_idle.png"));
            MouseHelpSurface = Cairo.ImageSurfaceFromPng(Marshal.C_String("disk0/cursor_help.png"));
            MouseClipSurface = Cairo.ImageSurfaceFromPng(Marshal.C_String("disk0/cursor_clip.png"));
            MouseSurface = MouseIdleSurface;

            int stride = Cairo.FormatStrideForWidth(VBE.Xres, ColorFormat.ARGB32);
            MainSurface = Cairo.ImageSurfaceCreateForData(stride, VBE.Yres, VBE.Xres, ColorFormat.ARGB32, VBE.SecondaryBuffer);
            VideoSurface = Cairo.ImageSurfaceCreateForData(stride, VBE.Yres, VBE.Xres, ColorFormat.ARGB32, VBE.VirtualFrameBuffer);

            MainContext = Cairo.Create(MainSurface);
            VideoContext = Cairo.Create(VideoSurface);

            new Thread(aParent, HandleRequest).Start();
            new Thread(aParent, HandleMouse).Start();
            new Thread(aParent, Renderer).Start();
        }

        internal static int CreateConnection(Pipe aClient)
        {
            if (aClient.PacketSize != PACKET_SIZE) return -1;

            Clients.Add(aClient);
            return (Clients.Count - 1);
        }

        static bool MouseLeftBtn, MouseRightBtn, MouseMiddleBtn;

        static int Mouse_X, Mouse_Y;
        private static unsafe void Renderer()
        {
            int tmp_mouse_X, tmp_mouse_Y;
            int old_mouse_X = -1, old_mouse_Y = -1;

            bool update;
            while (true)
            {
                tmp_mouse_X = Mouse_X;
                tmp_mouse_Y = Mouse_Y;
                update = false;

                Cairo.Save(MainContext);
                Cairo.Save(VideoContext);

                if (tmp_mouse_X != old_mouse_X || tmp_mouse_Y != old_mouse_Y)
                {
                    update = true;
                    Cairo.Rectangle(32, 32, old_mouse_Y, old_mouse_X, MainContext);
                    Cairo.Rectangle(32, 32, old_mouse_Y, old_mouse_X, VideoContext);
                    Cairo.Rectangle(32, 32, tmp_mouse_Y, tmp_mouse_X, VideoContext);
                }

                old_mouse_X = tmp_mouse_X;
                old_mouse_Y = tmp_mouse_Y;

                var queue = RedrawRects;
                Monitor.AcquireLock(ref RedrawRectsLock);
                while (queue.Count > 0)
                {
                    var rect = (Rect*)queue.Dequeue();

                    Cairo.Rectangle(rect->Height, rect->Width, rect->Y, rect->X, MainContext);
                    Cairo.Rectangle(rect->Height, rect->Width, rect->Y, rect->X, VideoContext);

                    Libc.free((uint)rect);

                    update = true;
                }
                Monitor.ReleaseLock(ref RedrawRectsLock);

                if (update)
                {
                    Cairo.Clip(MainContext);
                    var list = Stacking;
                    Monitor.AcquireLock(ref StackingLock);
                    int count = list.Count;
                    for (int index = 0; index < count; index++)
                    {
                        var win = list[index];
                        Cairo.Save(MainContext);
                        Cairo.Translate(win.Y, win.X, MainContext);
                        Cairo.SetSourceSurface(0, 0, win.Surface, MainContext);
                        Cairo.Paint(MainContext);
                        Cairo.Restore(MainContext);
                    }
                    Monitor.ReleaseLock(ref StackingLock);
                }

                if (update)
                {
                    Cairo.Clip(VideoContext);

                    Cairo.Translate(0, 0, VideoContext);
                    Cairo.SetOperator(Operator.Source, VideoContext);
                    Cairo.SetSourceSurface(0, 0, MainSurface, VideoContext);
                    Cairo.Paint(VideoContext);

                    Cairo.Translate(old_mouse_Y, old_mouse_X, VideoContext);
                    Cairo.SetOperator(Operator.Over, VideoContext);
                    Cairo.SetSourceSurface(0, 0, MouseSurface, VideoContext);
                    Cairo.Paint(VideoContext);
                }

                Cairo.Restore(MainContext);
                Cairo.Restore(VideoContext);

                Task.Switch();
            }
        }

        private static unsafe void HandleMouse()
        {
            var Packet = new byte[4];
            var aData = new byte[PACKET_SIZE];
            var request = (GuiRequest*)aData.GetDataOffset();

            request->Type = RequestType.MouseEvent;

            var mouseRequest = (MouseEvent*)request;
            while (true)
            {
                Mouse.MousePipe.Read(Packet);

                if (Packet[0] != Mouse.MOUSE_MAGIC)
                    continue;

                int btn = Packet[1];
                int x = Packet[2];
                int y = Packet[3];

                if ((btn & 0x10) != 0)
                    x |= ~0xFF;

                if ((btn & 0x20) != 0)
                    y |= ~0xFF;

                mouseRequest->Button = btn;

                mouseRequest->Xpos = x;
                mouseRequest->Ypos = y;

                Server.Write(aData);
            }
        }

        private static unsafe void HandleRequest()
        {
            var xData = new byte[PACKET_SIZE];

            while(true)
            {
                Server.Read(xData);

                var Request = (GuiRequest*)xData.GetDataOffset();

                if (Request->ClientID >= Clients.Count)
                    Request->Error = ErrorType.BadRequest;

                if (Request->Error != ErrorType.None)
                {
                    ReplyClient(Request);
                    continue;
                }

                switch (Request->Type)
                {
                    case RequestType.MouseEvent:
                        HandleMouseEvent(Request);
                        break;
                    case RequestType.NewWindow:
                        HandleNewWindow(Request);
                        break;
                    case RequestType.Redraw:
                        HandleRedraw(Request);
                        break;
                    case RequestType.WindowMove:
                        HandleWindowMove(Request);
                        break;
                    case RequestType.DragRequest:
                        HandleDragRequest(Request);
                        break;
                    case RequestType.InfoRequest:
                        HandleInfoRequest(Request);
                        break;
                    default:
                        Debug.Write("Function: %d\n", (int)Request->Type);
                        Request->Error = ErrorType.BadFunction;
                        break;
                }
            }
        }

        private static unsafe void HandleInfoRequest(GuiRequest* aRequest)
        {
            var InfoRequest = (InfoRequest*)aRequest;
            int id = InfoRequest->WindowID;

            if (id < 0 || id >= Windows.Count)
                aRequest->Error = ErrorType.BadParameters;

            if (aRequest->Error != ErrorType.None)
            {
                ReplyClient(aRequest);
                return;
            }

            var win = Windows[id];
            InfoRequest->X = win.X;
            InfoRequest->Y = win.Y;
            InfoRequest->Width = win.Width;
            InfoRequest->Height = win.Height;
            ReplyClient(aRequest);
        }

        private static unsafe void HandleDragRequest(GuiRequest* aRequest)
        {
            var DragRequest = (DragRequest*)aRequest;
            int id = DragRequest->WindowID;

            if (id < 0 || id >= Windows.Count)
                aRequest->Error = ErrorType.BadParameters;

            if (ActiveWindow == null || ActiveWindow.ID != id)
                aRequest->Error = ErrorType.BadRequest;

            if (aRequest->Error != ErrorType.None)
            {
                ReplyClient(aRequest);
                return;
            }

            var win = Windows[id];
            MouseWindow = win;
        }

        private static unsafe void HandleMouseEvent(GuiRequest* aRequest)
        {
            var MouseRequest = (MouseEvent*)aRequest;
            MouseRequest->Function = MouseFunction.None;

            MouseFunction function = 0;
            if (MouseRequest->Xpos != 0 || MouseRequest->Ypos != 0)
                function = MouseFunction.Move;

            /* calculate new mouse position */
            int x = Mouse_X + (MouseRequest->Xpos << 1);
            int y = Mouse_Y - (MouseRequest->Ypos << 1);

            /* bound mouse position */
            if (x < 0) x = 0;
            if (x > VBE.Xres) x = VBE.Xres;

            if (y < 0) y = 0;
            if (y > VBE.Yres) y = VBE.Yres;

            /* Button Status */
            int Button = MouseRequest->Button;
            bool LeftBtn = (Button & 0x1) != 0;
            bool RightBtn = (Button & 0x2) != 0;

            /* stop window movement */
            if (LeftBtn)
            {
                if (MouseWindow != null)
                {
                    var win = MouseWindow;
                    MarkRectange(win.X, win.Y, win.Width, win.Height);
                    MouseWindow.X += x - Mouse_X;
                    MouseWindow.Y += y - Mouse_Y;
                    MarkRectange(win.X, win.Y, win.Width, win.Height);
                }
            }
            else
            {
                MouseWindow = null;
            }

            /* Update Coordinates */
            Mouse_X = x;
            Mouse_Y = y;

            /* Mouse Events to Client */
            if ((LeftBtn && !MouseLeftBtn) || (RightBtn && !MouseRightBtn))
                function |= MouseFunction.KeyDown;

            if ((!LeftBtn && MouseLeftBtn) || (!RightBtn && MouseRightBtn))
                function |= MouseFunction.KeyUp;

            /* button details */
            MouseLeftBtn = LeftBtn;
            MouseRightBtn = RightBtn;
            MouseMiddleBtn = (Button & 0x4) != 0;

            if ((function & MouseFunction.KeyDown) != 0)
            {
                Monitor.AcquireLock(ref StackingLock);

                var list = Stacking;
                int count = list.Count;
                for (int i = count - 1; i >= 0; i--)
                {
                    var win = list[i];
                    if (x < win.X ||
                        y < win.Y ||
                        x > win.X + win.Width ||
                        y > win.Y + win.Height) continue;

                    if (ActiveWindow == win)
                    {
                        function |= MouseFunction.Click;
                        break;
                    }

                    ActiveWindow = win;
                    function |= MouseFunction.Enter;

                    if (i != 0)
                    {
                        for (int j = i + 1; j < count; j++)
                            list[j - 1] = list[j];
                        list[count - 1] = win;

                        MarkRectange(win.X, win.Y, win.Width, win.Height);
                    }
                    break;
                }

                Monitor.ReleaseLock(ref StackingLock);
            }

            if (ActiveWindow == null) return;

            var Window = ActiveWindow;

            if (x < Window.X ||
                y < Window.Y ||
                x > Window.X + Window.Width ||
                y > Window.Y + Window.Height)
                return;

            MouseRequest->WindowID = Window.ID;
            MouseRequest->Xpos = x - Window.X;
            MouseRequest->Ypos = y - Window.Y;
            MouseRequest->Function = function;
            aRequest->ClientID = Window.ClientID;
            ReplyClient(aRequest);
        }

        private static unsafe void HandleWindowMove(GuiRequest* aRequest)
        {
            var WindowRequest = (WindowMove*)aRequest;
            int id = WindowRequest->WindowID;
            if (id < 0 || id >= Windows.Count)
                aRequest->Error = ErrorType.BadParameters;

            if (aRequest->Error != ErrorType.None)
            {
                ReplyClient(aRequest);
                return;
            }

            var win = Windows[id];
            MarkRectange(win.X, win.Y, win.Width, win.Height);
            win.X += WindowRequest->RelX;
            win.Y += WindowRequest->RelY;
            MarkRectange(win.X, win.Y, win.Width, win.Height);
        }

        private static unsafe void HandleNewWindow(GuiRequest* aRequest)
        {
            var WindowRequest = (NewWindow*)aRequest;

            int x = WindowRequest->X;
            int y = WindowRequest->Y;
            int width = WindowRequest->Width;
            int height = WindowRequest->Height;

            if (width <= 0 || height <= 0)
                aRequest->Error = ErrorType.BadParameters;

            if (aRequest->Error != ErrorType.None)
            {
                ReplyClient(aRequest);
                return;
            }

            var window = new Window(aRequest->ClientID, x, y, width, height);
            Marshal.Copy(window.HashID, WindowRequest->Buffer, window.HashID.Length);

            Monitor.AcquireLock(ref WindowsLock);

            int id = Windows.Count;
            window.ID = id;
            WindowRequest->WindowID = id;
            Windows.Add(window);

            Monitor.ReleaseLock(ref WindowsLock);
            ActiveWindow = window;

            Monitor.AcquireLock(ref StackingLock);
            Stacking.Add(window);
            Monitor.ReleaseLock(ref StackingLock);

            ReplyClient(aRequest);
        }

        private static unsafe void HandleRedraw(GuiRequest* aRequest)
        {
            var RedrawRequest = (Redraw*)aRequest;

            int id = RedrawRequest->WindowID;
            int width = RedrawRequest->Width;
            int height = RedrawRequest->Height;

            if (id < 0 || id >= Windows.Count || width <= 0 || height <= 0)
                aRequest->Error = ErrorType.BadParameters;

            if (aRequest->Error != ErrorType.None)
            {
                ReplyClient(aRequest);
                return;
            }

            var Window = Windows[id];
            MarkRectange(RedrawRequest->X + Window.X, RedrawRequest->Y + Window.Y, width, height);
        }

        private static unsafe void MarkRectange(int x, int y, int width, int height)
        {
            var DamageRect = (Rect*)Libc.malloc(sizeof(Rect));
            DamageRect->X = x;
            DamageRect->Y = y;
            DamageRect->Width = width;
            DamageRect->Height = height;

            Monitor.AcquireLock(ref RedrawRectsLock);
            RedrawRects.Enqueue((uint)DamageRect);
            Monitor.ReleaseLock(ref RedrawRectsLock);
        }

        private static unsafe void ReplyClient(GuiRequest* aRequest)
        {
            aRequest->HashID = 0;
            Clients[aRequest->ClientID].Write((byte*)aRequest, false);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          System.Covert Plugs
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomix.Kernel_H.plugs
{
    internal class Convert
    {
        [Plug("System_String_System_Convert_ToString_System_UInt32_")]
        internal static string ToString(uint aThis)
        {
            return Numerics.ToString(ref aThis);
        }

        [Plug("System_String_System_Convert_ToString_System_Int32_")]
        internal static string ToString(int aThis)
        {
            return Numerics.ToString(ref aThis);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib.Globalization
{
    public static unsafe class CultureInfo
    {
        [Plug("System_Void__System_Globalization_CultureInfo__cctor__")]
        public static void Cctor(byte* aAddress)
        {
            return;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          It will flush debug text to Com serial port
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomix.Kernel_H.Arch.x86;

namespace Atomix.Kernel_H.Core
{
    internal static class Debug
    {
        internal enum Port : uint
        {
            Com1 = 0x3F8,
            Com2 = 0x2F8,
            Com3 = 0x3E8,
            Com4 = 0x2F8
        };

        internal enum Cmd : uint
        {
            COM_Data = 0x00,
            COM_Interrupt = 0x01,
            COM_LineControl = 0x02,
            COM_ModemControl = 0x03,
            COM_LineStatus = 0x04,
            COM_ModemStatus = 0x05,
            COM_Scratch = 0x06
        };

        static uint Lock;

        internal static void Init()
        {
            var PORT = Port.Com1;
            PortIO.Out8((ushort)(PORT + (ushort)Cmd.COM_Interrupt), 0x00);        // Disable all interrupts
            PortIO.Out8((ushort)(PORT + (ushort)Cmd.COM_ModemControl), 0x80);     // Enable DLAB (set baud rate divisor)
            PortIO.Out8((ushort)(PORT + (ushort)Cmd.COM_Data), 0x03);             // Set divisor to 3 (lo byte) 38400 baud
            PortIO.Out8((ushort)(PORT + (ushort)Cmd.COM_Interrupt), 0x00);        //                  (hi byte)
            PortIO.Out8((ushort)(PORT + (ushort)Cmd.COM_ModemControl), 0x03);     // 8 bits, no parity, one stop bit
            PortIO.Out8((ushort)(PORT + (ushort)Cmd.COM_LineControl), 0xC7);      // Enable FIFO, clear them, with 14-byte threshold
            PortIO.Out8((ushort)(PORT + (ushort)Cmd.COM_LineStatus), 0x0B);       // IRQs enabled, RTS/DSR set
            PortIO.Out8((ushort)(PORT + (ushort)Cmd.COM_Interrupt), 0x0F);

            Write("Debugger Initalized\n");
        }

        private static void WaitForWriteReady()
        {
            while ((PortIO.In8((ushort)(Port.Com1 + (ushort)Cmd.COM_ModemStatus)) & 0x20) == 0x0) ;
        }

        internal static void Write(string str, int nums)
        {
            Write(str, (uint)nums);
        }

        internal static void Write(string str, uint nums)
        {
            Monitor.AcquireLock(ref Lock);

            char a;
            for (int i = 0; i < str.Length; i++)
            {
                a = str[i];
                if (a == '%' && str[i + 1] == 'd')
                {
                    Write(nums);
                    i++;
                }
                else
                {
                    Write(a);
                }
            }

            Monitor.ReleaseLock(ref Lock);
        }

        internal static void Write(string str, string arg0)
        {
            Monitor.AcquireLock(ref Lock);

            char a;
            for (int i = 0; i < str.Length; i++)
            {
                a = str[i];
                if (a == '%' && str[i + 1] == 's')
                {
                    WriteAsync(arg0);
                    i++;
                }
                else
                {
                    Write(a);
                }
            }
            Monitor.ReleaseLock(ref Lock);
        }

        internal static void Write(string str)
        {
            Monitor.AcquireLock(ref Lock);
            WriteAsync(str);
            Monitor.ReleaseLock(ref Lock);
        }

        private static void WriteAsync(string str)
        {
            for (int i = 0; i < str.Length; i++)
                Write(str[i]);
        }

        private static void Write(char a)
        {
            Write((byte)a);
        }

        public static void Write(byte a)
        {
            WaitForWriteReady();
            PortIO.Out8((ushort)Port.Com1, a);
        }

        private static void Write(uint a)
        {
            uint tmp = a, c = 1;

            while (tmp > 9)
            {
                c *= 10;
                tmp /= 10;
            }

            tmp = a;
            while (c > 0)
            {
                Write((byte)('0' + (char)(tmp / c)));
                tmp %= c;
                c /= 10;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          ELF Parsing Library
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Runtime.InteropServices;

using Atomixilc.Lib;

using Atomix.Kernel_H.IO;
using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.IO.FileSystem;

namespace Atomix.Kernel_H.Exec
{
    internal unsafe static class ELF
    {
        [StructLayout(LayoutKind.Explicit, Size = 52)]
        struct Elf_Header
        {
            [FieldOffset(0)]
            public fixed byte e_ident[16];
            [FieldOffset(16)]
            public ushort e_type;
            [FieldOffset(18)]
            public ushort e_machine;
            [FieldOffset(20)]
            public uint e_version;
            [FieldOffset(24)]
            public uint e_entry;
            [FieldOffset(28)]
            public uint e_phoff;
            [FieldOffset(32)]
            public uint e_shoff;
            [FieldOffset(36)]
            public uint e_flags;
            [FieldOffset(40)]
            public ushort e_ehsize;
            [FieldOffset(42)]
            public ushort e_phentsize;
            [FieldOffset(44)]
            public ushort e_phnum;
            [FieldOffset(46)]
            public ushort e_shentsize;
            [FieldOffset(48)]
            public ushort e_shnum;
            [FieldOffset(50)]
            public ushort e_shstrndx;
        };

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        struct Elf_Shdr
        {
            [FieldOffset(0)]
            public uint sh_name;
            [FieldOffset(4)]
            public uint sh_type;
            [FieldOffset(8)]
            public uint sh_flags;
            [FieldOffset(12)]
            public uint sh_addr;
            [FieldOffset(16)]
            public uint sh_offset;
            [FieldOffset(20)]
            public uint sh_size;
            [FieldOffset(24)]
            public int sh_link;
            [FieldOffset(28)]
            public int sh_info;
            [FieldOffset(32)]
            public uint sh_addralign;
            [FieldOffset(36)]
            public uint sh_entsize;
        };

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        struct Elf32_Rel
        {
            [FieldOffset(0)]
            public uint r_offset;
            [FieldOffset(4)]
            public uint r_info;
        };

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        struct Elf32_Sym
        {
            [FieldOffset(0)]
            public uint st_name;
            [FieldOffset(4)]
            public uint st_value;
            [FieldOffset(8)]
            public uint st_size;
            [FieldOffset(12)]
            public byte st_info;
            [FieldOffset(13)]
            public byte st_other;
            [FieldOffset(14)]
            public ushort st_shndx;
        };

        /* Identification indexes for e_ident field in ELF header */
        const int EI_MAG0       = 0;         /* file ID byte 0 */
        const int EI_MAG1       = 1;         /* file ID byte 1 */
        const int EI_MAG2       = 2;         /* file ID byte 2 */
        const int EI_MAG3       = 3;         /* file ID byte 3 */
        const int EI_CLASS      = 4;         /* file class (capacity) */
        const int EI_DATA       = 5;         /* data encoding */
        const int EI_VERSION    = 6;         /* file version */
        const int EI_PAD        = 7;         /* start of padding bytes */
        const int EI_NIDENT     = 16;        /* size of e_ident[] */

        /* "Magic number" in e_ident field of ELF header */
        const byte ELFMAG0 = 0x7F;
        const byte ELFMAG1 = (byte)'E';
        const byte ELFMAG2 = (byte)'L';
        const byte ELFMAG3 = (byte)'F';

        /* Relocation Type for i386 machine */
        const byte R_386_NONE       = 0;
        const byte R_386_32         = 1;    /* S + A */
        const byte R_386_PC32       = 2;    /* S + A - P */
        const byte R_386_GOT32      = 3;    /* G + A */
        const byte R_386_PLT32      = 4;    /* L + A - P */
        const byte R_386_COPY       = 5;
        const byte R_386_GLOB_DAT   = 6;    /* S */
        const byte R_386_JMP_SLOT   = 7;    /* S */
        const byte R_386_RELATIVE   = 8;    /* B + A */
        const byte R_386_GOTOFF     = 9;    /* S + A - GOT */
        const byte R_386_GOTPC      = 10;   /* GOT + A - P */
        const byte R_386_32PLT      = 11;	/* L + A */

        /* File class (or capacity) in e_ident[4] of ELF header */
        const byte ELFCLASSNONE = 0;        /* invalid class */
        const byte ELFCLASS32   = 1;        /* 32-bit processor */
        const byte ELFCLASS64   = 2;        /* 64-bit processor */

        /* Data encoding in e_ident[5] of ELF header */
        const byte ELFDATANONE = 0;        /* invalid data encoding */
        const byte ELFDATA2LSB = 1;        /* little-endian format */
        const byte ELFDATA2MSB = 2;        /* big-endian format */

        /* Object file type in e_type field of ELF header */
        const ushort ET_NONE    = 0;         /* no file type */
        const ushort ET_REL     = 1;         /* relocatble file */
        const ushort ET_EXEC    = 2;         /* executable file */
        const ushort ET_DYN     = 3;         /* shared object file */
        const ushort ET_CORE    = 4;         /* core file */
        const ushort ET_LOPROC  = 0xff00;    /* processor-specific */
        const ushort ET_HIPROC  = 0xffff;    /* processor-specific */

        /* Required architecture in e_machine field of ELF header */
        const ushort EM_NONE    = 0;         /* no machine */
        const ushort EM_M32     = 1;         /* AT&T WE 32100 */
        const ushort EM_SPARC   = 2;         /* SPARC */
        const ushort EM_386     = 3;         /* Intel 80386 */
        const ushort EM_68K     = 4;         /* Motorola 68000 */
        const ushort EM_88K     = 5;         /* Motorola 88000 */
        const ushort EM_860     = 7;         /* Intel 80860 */
        const ushort EM_MIPS    = 8;         /* MIPS RS3000 */
        const ushort EM_ARM     = 40;        /* Advanced RISC Machines ARM */

        /* Object file version in e_version field of ELF header */
        const uint EV_NONE      = 0;         /* invalid version */
        const uint EV_CURRENT   = 1;         /* current version */

        /* Section's semantics in sh_type field of ELF section header */
        const uint SHT_NULL     = 0;            /* no section associated with header */
        const uint SHT_PROGBITS = 1;            /* program-defined data */
        const uint SHT_SYMTAB   = 2;            /* link editing & dynamic linking symbols */
        const uint SHT_STRTAB   = 3;            /* string table */
        const uint SHT_RELA     = 4;            /* minimal set of dynamic linking symbols */
        const uint SHT_HASH     = 5;            /* relocation entries with explicit addends */
        const uint SHT_DYNAMIC  = 6;            /* symbol hash table (dynamic linking) */
        const uint SHT_NOTE     = 7;            /* dynamic linking info */
        const uint SHT_NOBITS   = 8;            /* file-marking information */
        const uint SHT_REL      = 9;            /* relocation entries without explicit addends */
        const uint SHT_SHLIB    = 10;           /* reserved */
        const uint SHT_DYNSYM   = 11;           /* dynamic linking symbol table */
        const uint SHT_LOPROC   = 0x70000000;   /* LB for processor-specific dynamics */
        const uint SHT_HIPROC   = 0x7fffffff;   /* UB for processor-specific dynamics */
        const uint SHT_LOUSER   = 0x80000000;   /* LB for application-specific dynamics */
        const uint SHT_HIUSER   = 0x8fffffff;   /* UB for application-specific dynamics */

        /* Section's attribute flags in sh_flags field of ELF section header */
        const uint SHF_WRITE        = 0x1;         /* data writable during execution */
        const uint SHF_ALLOC        = 0x2;         /* occupies memory during execution */
        const uint SHF_EXECINSTR    = 0x4;         /* executable machine instructions */
        const uint SHF_MASKPROC     = 0xf0000000;  /* mask for processor-specific semantics */

        /* Special section indexes (reserved values) */
        const ushort SHN_UNDEF      = 0;            /* undefined section index */
        const ushort SHN_LORESERVE  = 0xff00;       /* LB (lower bound) of ELF reserved indexes */
        const ushort SHN_LOPROC     = 0xff00;       /* LB of processor-specific semantics */
        const ushort SHN_HIPROC     = 0xff1f;       /* UB of processor-specific semantics */
        const ushort SHN_ABS        = 0xfff1;       /* absolute (not relocatable) section */
        const ushort SHN_COMMON     = 0xfff2;       /* C external variables section */
        const ushort SHN_HIRESERVE  = 0xffff;       /* UB (upper bound) of ELF reserved indexes */

        /* Symbol binding */
        const uint STB_LOCAL        = 0;            /* Local scope */
        const uint STB_GLOBAL       = 1;            /* Global scope */
        const uint STB_WEAK         = 2;            /* Weak, (ie. __attribute__((weak))) */

        internal static uint Load(string aPath)
        {
            Stream xStream = VirtualFileSystem.GetFile(aPath);

            if (xStream == null)
                throw new Exception("[ELF]: File not found!");

            var xData = new byte[xStream.FileSize];
            xStream.Read(xData, xData.Length);

            uint BaseAddress = xData.GetDataOffset();
            Elf_Header* Header = (Elf_Header*)BaseAddress;

            /* verify ELF header and if this code support this type of elf */
            CheckHeader(Header);

            /* prepare sections and allocate memory (if required) */
            Elf_Shdr* Shdr = (Elf_Shdr*)(BaseAddress + Header->e_shoff);
            for (int i = 0; i < Header->e_shnum; i++, Shdr++)
            {
                Shdr->sh_addr = BaseAddress + Shdr->sh_offset;
                if ((Shdr->sh_flags & SHF_ALLOC) != 0)
                {
                    LoadSection(BaseAddress, Shdr);
                }
            }

            /* Iterate over all sections and perform relocations */
            Shdr = (Elf_Shdr*)(BaseAddress + Header->e_shoff);
            for (int i = 0; i < Header->e_shnum; i++, Shdr++)
            {
                switch (Shdr->sh_type)
                {
                    case SHT_SYMTAB:
                        {
                            RegisterSymbol(Header, Shdr, aPath);
                        }
                        break;
                    case SHT_REL:
                        {
                            Shdr->sh_addr = BaseAddress + Shdr->sh_offset;
                            Relocate(Header, Shdr);
                        }
                        break;
                }
            }

            return Header->e_entry;
        }

        private static void Relocate(Elf_Header* aHeader, Elf_Shdr* aShdr)
        {
            uint BaseAddress = (uint)aHeader;
            Elf32_Rel* Reloc = (Elf32_Rel*)aShdr->sh_addr;
            Elf_Shdr* TargetSection = (Elf_Shdr*)(BaseAddress + aHeader->e_shoff) + aShdr->sh_info;

            uint RelocCount = aShdr->sh_size / aShdr->sh_entsize;

            byte SymIdx;
            uint SymVal, RelocType;
            for (uint i = 0; i < RelocCount; i++, Reloc++)
            {
                SymVal = 0;
                SymIdx = (byte)(Reloc->r_info >> 8);
                RelocType = Reloc->r_info & 0xFF;

                if (SymIdx != SHN_UNDEF)
                {
                    if (RelocType == R_386_PLT32)
                        SymVal = 0;
                    else
                        SymVal = GetSymValue(aHeader, TargetSection->sh_link, SymIdx);
                }

                uint* add_ref = (uint*)(TargetSection->sh_addr + Reloc->r_offset);
                switch (RelocType)
                {
                    case R_386_32:
                        *add_ref = SymVal + *add_ref; // S + A
                        break;
                    case R_386_PLT32:   // L + A - P
                    case R_386_PC32:    // S + A - P
                    default:
                        throw new Exception("[ELF]: Unsupported Relocation type");
                }
            }
        }

        private static void RegisterSymbol(Elf_Header* aHeader, Elf_Shdr* aShdr, string aPath)
        {
            uint BaseAddress = (uint)aHeader;
            Elf32_Sym* SymTab = (Elf32_Sym*)aShdr->sh_addr;
            var StrTabAdd = ((Elf_Shdr*)(BaseAddress + aHeader->e_shoff) + aShdr->sh_link)->sh_addr;

            uint count = aShdr->sh_size / aShdr->sh_entsize;

            uint Address;
            for (uint i = 0; i < count; i++, SymTab++)
            {
                uint flag = (uint)(SymTab->st_info >> 4);
                if (flag == STB_GLOBAL)
                {
                    switch (SymTab->st_shndx)
                    {
                        case SHN_UNDEF:
                            continue; // for now ignore UNDEF Symbols
                        case SHN_ABS:
                            Address = SymTab->st_value;
                            break;
                        default:
                            var TargetSection = (Elf_Shdr*)(BaseAddress + aHeader->e_shoff) + SymTab->st_shndx;
                            Address = TargetSection->sh_addr + SymTab->st_value;
                            break;
                    }

                    string SymName = new string((sbyte*)(StrTabAdd + SymTab->st_name));
                    Debug.Write("Symbol: %s\n", SymName);
                }
            }
        }

        private static uint GetSymValue(Elf_Header* aHeader, int aTableIdx, int aSymIdx)
        {
            uint BaseAddress = (uint)aHeader;
            Elf_Shdr* SymSection = (Elf_Shdr*)(BaseAddress + aHeader->e_shoff) + aTableIdx;
            Elf32_Sym* SymTab = (Elf32_Sym*)(SymSection->sh_addr) + aSymIdx;

            switch (SymTab->st_shndx)
            {
                case SHN_UNDEF:
                    {
                        var StrTabAdd = ((Elf_Shdr*)(BaseAddress + aHeader->e_shoff) + SymSection->sh_link)->sh_addr;
                        string SymName = new string((sbyte*)(StrTabAdd + SymTab->st_name));

                        Debug.Write("Undefined Symbol: %s\n", SymName);
                        throw new Exception("[ELF]: Extern Symbol not supported");
                    }
                case SHN_ABS:
                    return SymTab->st_value;
                default:
                    Elf_Shdr* TargetSection = (Elf_Shdr*)(BaseAddress + aHeader->e_shoff) + SymTab->st_shndx;
                    return TargetSection->sh_addr + SymTab->st_value;
            }
        }

        private static uint LoadSection(uint aBaseAddress, Elf_Shdr* aShdr)
        {
            // make sure address if aligned
            uint align = aShdr->sh_addralign;
            uint addr = Heap.kmalloc(aShdr->sh_size + align);

            if (align != 0)
            {
                uint offset = addr & (align - 1);
                addr += align - offset;
            }

            if (aShdr->sh_type != SHT_NOBITS)
                Memory.FastCopy(addr, aBaseAddress + aShdr->sh_offset, aShdr->sh_size);

            aShdr->sh_addr = addr;
            return addr;
        }

        private static void CheckHeader(Elf_Header* aHeader)
        {
            /* Check if we are supporting this standard */
            var ident = aHeader->e_ident;
            if ((ident[EI_MAG0] != ELFMAG0) ||
                (ident[EI_MAG1] != ELFMAG1) ||
                (ident[EI_MAG2] != ELFMAG2) ||
                (ident[EI_MAG3] != ELFMAG3))
                throw new Exception("[ELF]: Invalid File format");

            if (ident[EI_CLASS] != ELFCLASS32)
                throw new Exception("[ELF]: Unsupported EI_CLASS");

            if (ident[EI_DATA] != ELFDATA2LSB)
                throw new Exception("[ELF]: Unsupported EI_DATA");

            if (aHeader->e_machine != EM_386)
                throw new Exception("[ELF]: Unsupported Machine Type");

            if (aHeader->e_type != ET_REL)
                throw new Exception("[ELF]: Unsupported ELF Type");

            if (aHeader->e_version != EV_CURRENT)
                throw new Exception("[ELF]: Unsupported ELF Version");
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          FAT Helper
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.IO.FileSystem.FAT.Find
{
    internal class Empty : Comparison
    {
        internal Empty() { }

        internal override bool Compare(byte[] data, int offset, FatType type)
        {
            if ((FileNameAttribute)data[offset + (uint)Entry.DOSName] == FileNameAttribute.LastEntry)
                return true;

            return false;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static unsafe class Enum
    {
        [Plug("System_Void__System_Enum__cctor__")]
        public static void Cctor(byte* Address)
        {
            return;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;
using System.Globalization;

namespace Atomix.mscorlib
{
    public static class Environment
    {
        [Plug("System_String_System_Environment_GetResourceFromDefault_System_String_")]
        public static string GetResourceFromDefault(string aResource)
        {
            return aResource;
        }
        [Plug("System_String_System_Resources_ResourceManager_GetString_System_String__System_Globalization_CultureInfo_")]
        public static string GetString(string aResource, CultureInfo aCultureInfo)
        {
            return aResource;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class ExceptionImpl
    {
        static Exception GlobalException;

        [Plug("System_Void__System_Exception__cctor__")]
        public static unsafe void ctor()
        {
            return;
        }

        [Plug("System_Void__System_Exception__ctor_System_String_")]
        public static unsafe void cctor(byte* aAddress, uint Message)
        {
            *(uint*)(aAddress + 0xC) = Message;
        }

        [Plug("System_String_System_Exception_get_Message__")]
        public static unsafe uint GetMessage(byte* aAddress)
        {
            return *(uint*)(aAddress + 0xC);
        }

        [Label(Helper.lblSetException)]
        public static void SetException(Exception aException)
        {
            GlobalException = aException;
        }

        [Label(Helper.lblGetException)]
        public static Exception GetException()
        {
            return GlobalException;
        }
    }
}
﻿using System;
using System.Collections.Generic;

using Atomixilc.Lib;

using Atomix.Kernel_H.IO;
using Atomix.Kernel_H.Lib;
using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Arch.x86;
using Atomix.Kernel_H.Lib.Cairo;
using Atomix.Kernel_H.Drivers.Video;

namespace Atomix.Kernel_H.Gui.Programs
{
    internal unsafe class Explorer
    {
        static Pipe Client;

        static int DesktopID;
        static int TaskbarID;

        static uint DesktopSurface;
        static uint TaskbarSurface;

        static uint DesktopContext;
        static uint TaskbarContext;

        internal static void Init(Pipe aClient)
        {
            Client = aClient;

            Desktop();
            Taskbar();
        }

        private static void Desktop()
        {
            var Data = new byte[Compositor.PACKET_SIZE];
            var Request = (GuiRequest*)Data.GetDataOffset();

            Request->ClientID = 0;
            Request->Type = RequestType.NewWindow;

            var Window = (NewWindow*)Request;
            Window->X = 0;
            Window->Y = 0;
            Window->Width = VBE.Xres;
            Window->Height = VBE.Yres;

            Compositor.Server.Write(Data);
            Client.Read(Data);

            string HashCode = new string(Window->Buffer);
            var aBuffer = SHM.Obtain(HashCode, 0, false);
            DesktopID = Window->WindowID;

            uint surface = Cairo.ImageSurfaceCreateForData(Window->Width * 4, Window->Height, Window->Width, ColorFormat.ARGB32, aBuffer);
            uint context = Cairo.Create(surface);

            uint wallpaper = Cairo.ImageSurfaceFromPng(Marshal.C_String("disk0/wallpaper.png"));
            Cairo.SetSourceSurface(0, 0, wallpaper, context);
            Cairo.Paint(context);
            Cairo.SurfaceDestroy(wallpaper);

            Request->Type = RequestType.Redraw;
            var Redraw = (Redraw*)Request;
            Redraw->WindowID = DesktopID;
            Redraw->X = 0;
            Redraw->Y = 0;
            Redraw->Width = VBE.Xres;
            Redraw->Height = VBE.Yres;
            Compositor.Server.Write(Data);

            DesktopSurface = surface;
            DesktopContext = context;
        }

        private static void Taskbar()
        {
            var Data = new byte[Compositor.PACKET_SIZE];
            var Request = (GuiRequest*)Data.GetDataOffset();

            Request->ClientID = 0;
            Request->Type = RequestType.NewWindow;

            var Window = (NewWindow*)Request;
            Window->X = 0;
            Window->Y = 0;
            Window->Width = VBE.Xres;
            Window->Height = 30;

            Compositor.Server.Write(Data);
            Client.Read(Data);

            string HashCode = new string(Window->Buffer);
            var aBuffer = SHM.Obtain(HashCode, 0, false);
            TaskbarID = Window->WindowID;

            uint surface = Cairo.ImageSurfaceCreateForData(Window->Width * 4, Window->Height, Window->Width, ColorFormat.ARGB32, aBuffer);
            uint context = Cairo.Create(surface);

            uint pattern = Cairo.PatternCreateLinear(30, 0, 0, 0);
            Cairo.PatternAddColorStopRgba(0.7, 0.42, 0.42, 0.42, 0, pattern);
            Cairo.PatternAddColorStopRgba(0.6, 0.36, 0.36, 0.36, 0.5, pattern);
            Cairo.PatternAddColorStopRgba(0.7, 0.42, 0.42, 0.42, 1, pattern);

            Cairo.SetOperator(Operator.Over, context);
            Cairo.Rectangle(30, VBE.Xres, 0, 0, context);
            Cairo.SetSource(pattern, context);
            Cairo.Fill(context);

            Cairo.Rectangle(2, VBE.Xres, 30 - 2, 0, context);
            Cairo.SetSourceRGBA(0.7, 0.41, 0.41, 0.41, context);
            Cairo.Fill(context);

            Cairo.PatternDestroy(pattern);
            Cairo.Destroy(context);
            Cairo.SurfaceDestroy(surface);

            Request->Type = RequestType.Redraw;
            var Redraw = (Redraw*)Request;
            Redraw->WindowID = TaskbarID;
            Redraw->X = 0;
            Redraw->Y = 0;
            Redraw->Width = VBE.Xres;
            Redraw->Height = 40;
            Compositor.Server.Write(Data);

            TaskbarSurface = surface;
            TaskbarContext = context;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Fat File System
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;

using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Devices;
using Atomix.Kernel_H.IO.FileSystem.FAT;
using Atomix.Kernel_H.IO.FileSystem.FAT.Find;

namespace Atomix.Kernel_H.IO.FileSystem
{
    internal class FatFileSystem : GenericFileSystem
    {
        // They should be private set only, so take care of this later
        internal UInt32 BytePerSector;
        internal UInt32 SectorsPerCluster;
        internal UInt32 ReservedSector;
        internal UInt32 TotalFAT;
        internal UInt32 DirectoryEntry;
        internal UInt32 TotalSectors;
        internal UInt32 SectorsPerFAT;
        internal UInt32 DataSectorCount;
        internal UInt32 ClusterCount;
        internal UInt32 SerialNo;
        internal UInt32 RootCluster;
        internal UInt32 RootSector;
        internal UInt32 RootSectorCount;
        internal UInt32 DataSector;
        internal UInt32 EntriesPerSector;
        internal UInt32 fatEntries;

        protected FatType FatType;

        protected string VolumeLabel;

        public FatFileSystem(Storage Device)
        {
            IDevice = Device;
            mIsValid = IsFAT();
        }

        private unsafe bool IsFAT()
        {
            var BootSector = new byte[512];

            if (!IDevice.Read(0U, 1U, BootSector))
                return false;

            var xSig = BitConverter.ToUInt16(BootSector, 510);
            if (xSig != 0xAA55)
                return false;

            /* BPB (BIOS Parameter Block) */
            BytePerSector = BitConverter.ToUInt16(BootSector, 11);
            SectorsPerCluster = BootSector[13];
            ReservedSector = BitConverter.ToUInt16(BootSector, 14);
            TotalFAT = BootSector[16];
            DirectoryEntry = BitConverter.ToUInt16(BootSector, 17);

            if (BitConverter.ToUInt16(BootSector, 19) == 0)
            {
                /* Large amount of sector on media. This field is set if there are more than 65535 sectors in the volume. */
                TotalSectors = BitConverter.ToUInt32(BootSector, 32);
            }
            else
            {
                TotalSectors = BitConverter.ToUInt16(BootSector, 19);
            }

            /* FAT 12 and FAT 16 ONLY */
            SectorsPerFAT = BitConverter.ToUInt16(BootSector, 22);

            if (SectorsPerFAT == 0)
            {
                /* FAT 32 ONLY */
                SectorsPerFAT = BitConverter.ToUInt32(BootSector, 36);
            }

            /* Not Necessary, To Avoid Crashes during corrupted BPB Info */
            // Just to prevent ourself from hacking
            if (TotalFAT == 0 || TotalFAT > 2 || BytePerSector == 0 || TotalSectors == 0 || SectorsPerCluster == 0)
                return false;

            /* Some basic calculations to check basic error :P */
            uint RootDirSectors = 0;
            DataSectorCount = TotalSectors - (ReservedSector + (TotalFAT * SectorsPerFAT) + RootDirSectors);
            ClusterCount = DataSectorCount / SectorsPerCluster;

            /* Finally we got key xD */
            if (ClusterCount < 4085)
                FatType = FatType.FAT12;
            else if (ClusterCount < 65525)
                FatType = FatType.FAT16;
            else
                FatType = FatType.FAT32;

            /* Now we open door of gold coins xDD */
            if (FatType == FatType.FAT32)
            {
                SerialNo = BitConverter.ToUInt32(BootSector, 39);
                VolumeLabel = new string((sbyte*)BootSector.GetDataOffset(), 71, 11);   // for checking
                RootCluster = BitConverter.ToUInt32(BootSector, 44);
                RootSector = 0;
                RootSectorCount = 0;
            }
            /* The key is of another door */
            else
            {
                SerialNo = BitConverter.ToUInt32(BootSector, 67);
                VolumeLabel = new string((sbyte*)BootSector.GetDataOffset(), 43, 11);
                RootSector = ReservedSector + (TotalFAT * SectorsPerFAT);
                RootSectorCount = (UInt32)((DirectoryEntry * 32 + (BytePerSector - 1)) / BytePerSector);
                fatEntries = SectorsPerFAT * 512 / 4;
            }
            /* Now it shows our forward path ;) */
            EntriesPerSector = (UInt32)(BytePerSector / 32);
            DataSector = ReservedSector + (TotalFAT * SectorsPerFAT) + RootSectorCount;

            mFSType = FileSystemType.FAT;
            return true;
        }

        internal override bool CreateFile(string[] path, int pointer)
        {
            return false;
        }

        internal override Stream GetFile(string[] path, int pointer)
        {
            if (!mIsValid)
                return null;

            FatFileLocation FileLocation = ChangeDirectory(path, pointer);
            if (FileLocation == null)
                return null;

            var xStream = new FatStream(this, path[path.Length - 1], FileLocation.FirstCluster, FileLocation.Size);
            return xStream;
        }

        private FatFileLocation ChangeDirectory(string[] path, int pointer)
        {
            uint CurrentCluster = RootCluster;
            var Compare = new WithName(null);
            FatFileLocation location = null;
            while (pointer < path.Length)
            {
                Compare.Name = path[pointer];
                location = FindEntry(Compare, CurrentCluster);
                if (location == null)
                    return null;
                CurrentCluster = location.FirstCluster;
                pointer++;
            }

            return location;
        }

        private FatFileLocation FindEntry(Comparison compare, uint startCluster)
        {
            uint activeSector = ((startCluster - RootCluster) * SectorsPerCluster) + DataSector;

            if (startCluster == 0)
                activeSector = (FatType == FatType.FAT32) ? GetSectorByCluster(RootCluster) : RootSector;

            byte[] aData = new byte[BytePerSector * SectorsPerCluster];
            this.IDevice.Read(activeSector, SectorsPerCluster, aData);

            for (uint index = 0; index < EntriesPerSector * SectorsPerCluster; index++)
            {
                int offset = (int)(index * (int)Entry.EntrySize);
                if (compare.Compare(aData, offset, FatType))
                {
                    FatFileAttributes attribute = (FatFileAttributes)aData[offset + (int)Entry.FileAttributes];
                    return new FatFileLocation(
                        GetClusterEntry(aData, index, FatType),
                        activeSector,
                        index,
                        (attribute & FatFileAttributes.SubDirectory) != 0,
                        BitConverter.ToInt32(aData, offset + (int)Entry.FileSize));
                }

                if (aData[(int)Entry.DOSName + offset] == (int)FileNameAttribute.LastEntry)
                    break;
            }

            return null;
        }

        internal uint GetClusterEntryValue(uint cluster)
        {
            uint fatoffset = cluster<<2;
            uint sector = ReservedSector + (fatoffset / BytePerSector);
            int sectorOffset = (int)(fatoffset % BytePerSector);

            var aData = new byte[512];
            IDevice.Read(sector, 1U, aData);
            var xNextCluster = (BitConverter.ToUInt32(aData, sectorOffset) & 0x0FFFFFFF);

            return xNextCluster;
        }

        private uint GetSectorByCluster(uint cluster)
        {
            return DataSector + ((cluster - RootCluster) * SectorsPerCluster);
        }

        internal static uint GetClusterEntry(byte[] data, uint index, FatType type)
        {
            uint cluster = BitConverter.ToUInt16(data, (int)((uint)Entry.FirstCluster + (index * (uint)Entry.EntrySize)));

            if (type == FatType.FAT32)
                cluster |= (uint)BitConverter.ToUInt16(data, (int)((uint)Entry.EAIndex + (index * (uint)Entry.EntrySize))) << 16;

            if (cluster == 0)
                cluster = 2;

            return cluster;
        }

        internal static bool IsClusterBad(uint Cluster)
        {
            // Values are depend only on FAT 32 FS
            return (Cluster == 0x0FFFFFF7);
        }

        internal static bool IsClusterFree(uint Cluster)
        {
            // Values are depend only on FAT 32 FS
            return (Cluster == 0x0);
        }

        internal static bool IsClusterReserved(uint Cluster)
        {
            // Values are depend only on FAT 32 FS
            return ((Cluster == 0x0) || (Cluster >= 0xFFF0) && (Cluster < 0x0FFFFFF7));
        }

        internal static bool IsClusterLast(uint Cluster)
        {
            // Values are depend only on FAT 32 FS
            return (Cluster == 0x0FFFFFF8);
        }

        internal byte[] NewBlockArray
        { get { return new byte[SectorsPerCluster * BytePerSector]; } }

        internal void PrintDebugInfo()
        {
            Debug.Write("BytesPerSector\t\t:%d\n", BytePerSector);
            Debug.Write("SectorsPerCluster\t\t:%d\n", SectorsPerCluster);
            Debug.Write("ReservedSector\t\t:%d\n", ReservedSector);
            Debug.Write("TotalFAT\t\t:%d\n", TotalFAT);
            Debug.Write("TotalSectors\t\t:%d\n", TotalSectors);
            Debug.Write("SectorsPerFAT\t\t:%d\n", SectorsPerFAT);
            Debug.Write("DataSectorCount\t\t:%d\n", DataSectorCount);
            Debug.Write("ClusterCount\t\t:%d\n", ClusterCount);
            Debug.Write("SerialNo\t\t:%d\n", SerialNo);
            Debug.Write("RootCluster\t\t:%d\n", RootCluster);
            Debug.Write("RootSector\t\t:%d\n", RootSector);
            Debug.Write("RootSectorCount\t\t:%d\n", RootSectorCount);
            Debug.Write("DataSector\t\t:%d\n", DataSector);
            Debug.Write("EntriesPerSector\t\t:%d\n", EntriesPerSector);
            Debug.Write("fatEntries\t\t:%d\n", fatEntries);
            Debug.Write("VolumeLabel\t\t:%s\n", VolumeLabel);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          FAT Stream Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;

using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.IO.FileSystem.FAT
{
    internal unsafe class FatStream : Stream
    {
        private FatFileSystem mFS;

        private string mFileName;
        private int mFileSize;

        private uint mFirstCluster;
        private uint mCurrentCluster;
        private int mPosition;

        private byte* mBufferCluster;
        private int mBufferLength;

        internal FatStream(FatFileSystem aFS, string aName, uint aFirstCluster, int aSize)
            :base(aName, aSize)
        {
            mFS = aFS;
            mFileName = aName;
            mFileSize = aSize;

            mFirstCluster = aFirstCluster;
            mCurrentCluster = aFirstCluster;
            mPosition = 0;

            mBufferLength = (int)(aFS.SectorsPerCluster * 512);
            mBufferCluster = (byte*)Heap.kmalloc(aFS.SectorsPerCluster * 512);
            LoadCluster(mFirstCluster);
        }

        internal override int Read(byte[] aBuffer, int aCount)
        {
            if (aCount > aBuffer.Length)
                aCount = aBuffer.Length;

            return Read((byte*)aBuffer.GetDataOffset(), aCount);
        }

        internal override int Read(byte* aBuffer, int aCount)
        {
            int BufferPosition = 0, RelativePosition = mPosition % mBufferLength, EffectiveBytesCopied = 0;

            if (mPosition + aCount > mFileSize)
                aCount = mFileSize - mPosition;

            do
            {
                int LengthToCopy = mBufferLength - RelativePosition;

                if (LengthToCopy > aCount)
                    LengthToCopy = aCount;

                Memory.FastCopy((uint)aBuffer + (uint)BufferPosition, (uint)mBufferCluster + (uint)RelativePosition, (uint)LengthToCopy);

                aCount -= LengthToCopy;
                mPosition += LengthToCopy;
                BufferPosition += LengthToCopy;
                RelativePosition += LengthToCopy;
                EffectiveBytesCopied += LengthToCopy;

                if (RelativePosition >= mBufferLength)
                {
                    RelativePosition = 0;
                    if (ReadNextCluster() == false)
                        return EffectiveBytesCopied;
                }
            }
            while (aCount > 0);
            return EffectiveBytesCopied;
        }

        private bool ReadNextCluster()
        {
            uint xNextCluster = mFS.GetClusterEntryValue(mCurrentCluster);

            if (FatFileSystem.IsClusterLast(xNextCluster))
                return false;

            if (FatFileSystem.IsClusterFree(xNextCluster)
                || FatFileSystem.IsClusterBad(xNextCluster)
                || FatFileSystem.IsClusterReserved(xNextCluster))
                return false;

            LoadCluster(xNextCluster);

            mCurrentCluster = xNextCluster;
            return true;
        }

        private bool LoadCluster(uint Cluster)
        {
            UInt32 xSector = mFS.DataSector + ((Cluster - mFS.RootCluster) * mFS.SectorsPerCluster);
            return mFS.IDevice.Read(xSector, mFS.SectorsPerCluster, (byte*)mBufferCluster);
        }

        internal override int Write(byte[] aBuffer, int aCount)
        { return 0; }

        internal override int Write(byte* aBuffer, int aCount)
        { return 0; }

        internal override int Position()
        { return mPosition; }

        internal override bool CanSeek()
        { return true; }

        internal override bool CanRead()
        { return true; }

        internal override bool CanWrite()
        { return false; }

        internal override int Seek(int val, SEEK pos)
        { return 0; }

        internal override bool Close()
        {
            Heap.Free((uint)mBufferCluster, (uint)mBufferLength);
            return true;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          ISR Fault Extension
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Lib;

using Atomix.Kernel_H.Arch.x86;

namespace Atomix.Kernel_H.Core
{
    internal static class Fault
    {
        /// <summary>
        /// System at critical condition, so crash the system by giving exception
        /// </summary>
        internal static void Handle(ref IRQContext aDump)
        {
            Debug.Write("Unhandled Interrupt: %d\nStack Dump::\n", aDump.Interrupt);
            Debug.Write("Error Code: %d\n", aDump.ErrorCode);
            Debug.Write("EIP: %d\n", aDump.EIP);
            Debug.Write("CS: %d\n", aDump.CS);
            Debug.Write("EBP: %d\n", aDump.EBP);
            Debug.Write("ESP: %d\n", aDump.ESP);
            Debug.Write("EAX: %d\n", aDump.EAX);
            Debug.Write("EBX: %d\n", aDump.EBX);
            Debug.Write("ECX: %d\n", aDump.ECX);
            Debug.Write("EDX: %d\n", aDump.EDX);
            Debug.Write("EDI: %d\n", aDump.EDI);
            Debug.Write("ESI: %d\n", aDump.ESI);
            Debug.Write("CR2: %d\n", Native.CR2Register());
            Debug.Write("Thread-ID: %d\n", Scheduler.RunningThread.ThreadID);
            Native.Cli();
            Native.Hlt();
        }
    }
}
﻿using System;
using System.Collections.Generic;

using System.IO;
using System.Text;
using System.Drawing;

namespace Atomix.RamFS
{
    public class FileEntry
    {
        public string FileName { get; private set; }
        public Stream FileData { get; private set; }
        public byte[] RawData { get; private set; }

        public FileEntry(string aName, Stream aData)
        {
            this.FileName = aName;
            this.FileData = aData;

            if (FileName.Length > 32)
                FileName = FileName.Substring(0, 32);

            PrepareRawData();
        }

        private void PrepareRawData()
        {
            switch (Path.GetExtension(FileName).ToLower())
            {
                /*
                case ".png":
                    using (var bitmap = new Bitmap(FileData))
                    {
                        RawData = new byte[(bitmap.Width * bitmap.Height * 4) + 8];
                        Array.Copy(BitConverter.GetBytes(bitmap.Width), 0, RawData, 0, 4);
                        Array.Copy(BitConverter.GetBytes(bitmap.Height), 0, RawData, 4, 4);

                        int pointer = 8;
                        for (int y = 0; y < bitmap.Height; y++)
                            for (int x = 0; x < bitmap.Width; x++, pointer += 4)
                                Array.Copy(BitConverter.GetBytes(bitmap.GetPixel(x, y).ToArgb()), 0, RawData, pointer, 4);
                    }
                    FileName = FileName.Replace(".png", ".xmp");
                    break;*/
                default:
                    {
                        RawData = new byte[FileData.Length];
                        FileData.Read(RawData, 0, RawData.Length);
                    }
                    break;
            }
        }

        public void GetEntryData(int StartAddress, byte[] xResult)
        {
            /*
             * 32 bytes := FileName
             * 4 bytes  := FileStartAddress
             * 4 bytes  := FileLength
             */
            var xNameByteArray = Encoding.ASCII.GetBytes(FileName);
            Array.Copy(xNameByteArray, 0, xResult, 0, xNameByteArray.Length);
            Array.Copy(BitConverter.GetBytes(StartAddress), 0, xResult, 32, 4);
            Array.Copy(BitConverter.GetBytes(RawData.Length), 0, xResult, 36, 4);
        }

        public int Dump(Stream xOutput)
        {
            xOutput.Write(RawData, 0, RawData.Length);
            return RawData.Length;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          FAT Helper
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.IO.FileSystem.FAT
{
    internal class FatFileLocation
    {
        internal readonly uint FirstCluster;
        internal readonly uint DirectorySector;
        internal readonly uint DirectorySectorIndex;
        internal readonly bool directory;
        internal readonly int Size;

        internal FatFileLocation(uint aStartCluster, uint aDirectorySector, uint aDirectoryIndex, bool aDirectory, int aSize)
        {
            FirstCluster = aStartCluster;
            DirectorySector = aDirectorySector;
            DirectorySectorIndex = aDirectoryIndex;
            directory = aDirectory;
            Size = aSize;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          RFS (Ram File System) File Stream class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;

using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.IO.FileSystem.RFS
{
    internal unsafe class FileStream : Stream
    {
        internal readonly RamFile RamFile;
        int mPosition;

        internal FileStream(RamFile aRamFile)
            :base(aRamFile.Name, aRamFile.Length)
        {
            RamFile = aRamFile;
            mPosition = 0;
        }

        internal override int Read(byte[] aBuffer, int aCount)
        {
            if (aBuffer.Length > aCount)
                aCount = aBuffer.Length;

            return Read((byte*)aBuffer.GetDataOffset(), aCount);
        }

        internal override unsafe int Read(byte* aBuffer, int aCount)
        {
            if (aCount + mPosition > RamFile.Length)
                aCount = RamFile.Length - mPosition;

            Memory.FastCopy((uint)aBuffer, RamFile.StartAddress + (uint)mPosition, (uint)aCount);

            mPosition += aCount;
            return aCount;
        }

        internal override int Write(byte[] aBuffer, int aCount)
        {
            return 0;
        }

        internal override unsafe int Write(byte* aBuffer, int aCount)
        {
            return 0;
        }

        internal override bool CanRead()
        { return true; }

        internal override bool CanSeek()
        { return false; }

        internal override bool CanWrite()
        { return false; }

        internal override int Position()
        { return mPosition; }

        internal override int Seek(int val, SEEK pos)
        {
            switch(pos)
            {
                case SEEK.SEEK_FROM_CURRENT:
                    mPosition += val;
                    break;
                case SEEK.SEEK_FROM_ORIGIN:
                    mPosition += val;
                    break;
                case SEEK.SEEK_FROM_END:
                    mPosition = RamFile.Length + val;
                    break;
            }

            mPosition %= RamFile.Length;
            return mPosition;
        }

        internal override bool Close()
        {
            return true;
        }
    }
}
﻿using System;

namespace Atomix.Kernel_H.Lib.Cairo
{
    /* typedef enum _cairo_font_weight {
     *      CAIRO_FONT_WEIGHT_NORMAL,
     *      CAIRO_FONT_WEIGHT_BOLD,
     * } cairo_font_weight_t;
     */
    internal enum FontWeight : int
    {
        Normal = 0,
        Bold = 1
    }

    /* typedef enum _cairo_font_slant {
     *      CAIRO_FONT_SLANT_NORMAL,
     *      CAIRO_FONT_SLANT_ITALIC,
     *      CAIRO_FONT_SLANT_OBLIQUE
     * } cairo_font_slant_t;
     */
    internal enum FontSlant : int
    {
        Normal = 0,
        Italic = 1,
        Oblique = 2
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Garbage Collector
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Lib;

namespace Atomix.Kernel_H.Core
{
    internal static unsafe class GC
    {
        static uint mMemoryUsage;

        static int mAllocatedObjectCount;

        static uint[] mAllocatedObjects;
        static uint[] mAllocatedObjectSize;

        internal static uint MemoryUsage
        { get { return mMemoryUsage; } }

        internal static void Init(uint aMaximumObjectCount = 1024)
        {
            mMemoryUsage = 0;
            mAllocatedObjectCount = 0;

            mAllocatedObjects = new uint[aMaximumObjectCount];
            mAllocatedObjectSize = new uint[aMaximumObjectCount];
        }

        internal static bool Notify(uint aAddress, uint aLength)
        {
                if (mAllocatedObjectCount == mAllocatedObjects.Length)
                return false;
            // add the object to pool and update counter
            int index = mAllocatedObjectCount;
            mAllocatedObjects[index] = aAddress;
            mAllocatedObjectSize[index] = aLength;
            mAllocatedObjectCount = index + 1;
            mMemoryUsage += aLength;

            return true;
        }

        internal static void Collect()
        {
            SortObjects();

            // unmark objects
            int count = mAllocatedObjectCount;
            for (int i = 0; i < count; i++)
                mAllocatedObjectSize[i] &= 0x7FFFFFFF;

            // trace stack
            var threads = Scheduler.SystemProcess.Threads;
            int threadcount = threads.Count;
            for (int i = 0; i < threadcount; i++)
            {
                var thread = threads[i];
                uint limit = thread.StackTop;
                uint pointer = thread.StackCurrent;
                while (pointer < limit)
                {
                    MarkObject(*(uint*)pointer);
                    pointer += 4;
                }
            }

            // trace global
            uint start = Native.GlobalVarStart();
            uint end = Native.GlobalVarEnd();
            while (start < end)
            {
                MarkObject(*(uint*)start);
                start += 4;
            }

            // free unmarked objects
            int index = 0;
            uint MemoryFreed = 0;
            for (int i = 0; i < count; i++)
            {
                if ((mAllocatedObjectSize[i] & (1U << 31)) != 0)
                {
                    mAllocatedObjects[index] = mAllocatedObjects[i];
                    mAllocatedObjectSize[index] = mAllocatedObjectSize[i];
                    index++;
                }
                else
                {
                    MemoryFreed += mAllocatedObjectSize[i];
                    Heap.Free(mAllocatedObjects[i], mAllocatedObjectSize[i]);
                }
            }

            mAllocatedObjectCount = index;
            mMemoryUsage -= MemoryFreed;

            Debug.Write("[GC]\tMemory Freed: %d\n", MemoryFreed);
        }

        public static void Dump()
        {
            Debug.Write("GC Dump()\n");
            int count = mAllocatedObjectCount;
            for (int i = 0; i < count; i++)
            {
                Debug.Write("%d ", mAllocatedObjects[i]);
                Debug.Write("%d\n", mAllocatedObjectSize[i] & 0x7fffffff);
            }
        }

        private static void MarkObject(uint Address)
        {
            if (Address == 0) return;
            int index = BinarySearch(Address);
            // no such object found
            if (index == -1) return;

            // mark if not marked
            if ((mAllocatedObjectSize[index] & (1U << 31)) != 0) return;
            mAllocatedObjectSize[index] |= 1U << 31;

            var data = (uint*)Address;
            uint flag = data[1];

            // check object flag
            if ((flag & 0x3) != 0x1)
            {
                if ((flag & 0x3) == 0x3)
                {
                    int lastIndex = (int)data[2] + 4;
                    for (int i = 4; i < lastIndex; i++)
                        MarkObject(data[i]);
                }
                return;
            }

            // find sub-fields and mark them
            uint childrens = flag >> 2;
            data += 3;
            while (childrens > 0)
            {
                MarkObject(*data);
                data++;
                childrens--;
            }
        }

        private static int BinarySearch(uint Address)
        {
            int left = 0, right = mAllocatedObjectCount - 1;
            while (left <= right)
            {
                int mid = (left + right) >> 1;
                uint found = mAllocatedObjects[mid];

                if (found == Address)
                    return mid;

                if (mAllocatedObjects[mid] > Address)
                    right = mid - 1;
                else
                    left = mid + 1;
            }

            return -1;
        }

        private static void SortObjects()
        {
            int count = mAllocatedObjectCount;
            for (int i = 1; i < count; i++)
            {
                int j = i - 1;
                uint address = mAllocatedObjects[i], length = mAllocatedObjectSize[i];
                while (j >= 0 && mAllocatedObjects[j] > address)
                    j--;
                j++;
                int k = i - 1;
                while (k >= j)
                {
                    mAllocatedObjects[k + 1] = mAllocatedObjects[k];
                    mAllocatedObjectSize[k + 1] = mAllocatedObjectSize[k];
                    k--;
                }
                mAllocatedObjects[j] = address;
                mAllocatedObjectSize[j] = length;
            }
        }
    }
}﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Kernel GDT Setup
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Lib;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

using Atomix.Kernel_H.Core;

using System.Runtime.InteropServices;

namespace Atomix.Kernel_H.Arch.x86
{
    internal static unsafe class GDT
    {
        internal static void Setup()
        {
            var gdt = Heap.kmalloc(46, false);
            var gdt_entries = (GDT_Entries*)(gdt + 6);

            Memory.Write16(gdt, (0x8 * 6) - 1);
            Memory.Write32(gdt + 2, (uint)gdt_entries);

            Debug.Write("GDT Setup!!\n");
            Debug.Write("       Base Address::%d\n", gdt);

            Set_GDT_Gate(gdt_entries + 0, 0, 0, 0, 0);                // Null segment
            Set_GDT_Gate(gdt_entries + 1, 0, 0xFFFFFFFF, 0x9A, 0xCF); // Code segment
            Set_GDT_Gate(gdt_entries + 2, 0, 0xFFFFFFFF, 0x92, 0xCF); // Data segment
            Set_GDT_Gate(gdt_entries + 3, 0, 0xFFFFFFFF, 0xFA, 0xCF); // User mode code segment
            Set_GDT_Gate(gdt_entries + 4, 0, 0xFFFFFFFF, 0xF2, 0xCF); // User mode data segment

            SetupGDT(gdt);
        }

        private static void Set_GDT_Gate(GDT_Entries* gdt_entry, uint address, uint limit, byte access, byte granularity)
        {
            gdt_entry->BaseLow = (ushort)address;
            gdt_entry->BaseMiddle = (byte)(address >> 16);
            gdt_entry->BaseHigh = (byte)(address >> 24);

            gdt_entry->LimitLow = (ushort)limit;
            gdt_entry->Granularity = (byte)(limit >> 16);

            gdt_entry->Granularity |= (byte)(granularity & 0xF0);
            gdt_entry->Access = access;
        }

        [Assembly(true)]
        private static void SetupGDT(uint gdtpointer)
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceIndirect = true, SourceDisplacement = 0x8 };
            new Literal ("lgdt [EAX]");
            new Mov { DestinationReg = Register.EAX, SourceRef = "0x10" };
            new Mov { DestinationReg = Register.DS, SourceReg = Register.EAX, Size = 16 };
            new Mov { DestinationReg = Register.ES, SourceReg = Register.EAX, Size = 16 };
            new Mov { DestinationReg = Register.FS, SourceReg = Register.EAX, Size = 16 };
            new Mov { DestinationReg = Register.GS, SourceReg = Register.EAX, Size = 16 };
            new Mov { DestinationReg = Register.SS, SourceReg = Register.EAX, Size = 16 };
            new Jmp { Selector = 0x8, DestinationRef = ".End" };
        }

        [StructLayout(LayoutKind.Explicit, Size = 0x8)]
        struct GDT_Entries
        {
            [FieldOffset(0)]
            public ushort LimitLow;
            [FieldOffset(2)]
            public ushort BaseLow;
            [FieldOffset(4)]
            public byte BaseMiddle;
            [FieldOffset(5)]
            public byte Access;
            [FieldOffset(6)]
            public byte Granularity;
            [FieldOffset(7)]
            public byte BaseHigh;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Generic File System class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomix.Kernel_H.Devices;

namespace Atomix.Kernel_H.IO.FileSystem
{
    public abstract class GenericFileSystem
    {
        internal Storage IDevice;
        protected bool mIsValid;
        protected FileSystemType mFSType;

        internal bool IsValid
        { get { return mIsValid; } }

        internal FileSystemType FileSystem
        { get { return mFSType; } }

        internal abstract Stream GetFile(string[] path, int pointer);

        internal abstract bool CreateFile(string[] path, int pointer);
    }

    public enum FileSystemType : byte
    {
        None = 0x0,
        FAT = 0x1
    }
}
﻿using System;
using Kernel_alpha.x86;
using Kernel_alpha.x86.Intrinsic;
using System.Collections.Generic;
using Kernel_alpha.Drivers;
using Kernel_alpha.Drivers.Input;
using Kernel_alpha.Drivers.Buses.ATA;

namespace Kernel_alpha
{
    public static class Global
    {
        public static Keyboard KBD;
        public static PS2Mouse Mouse;
        public static acpi ACPI;

        public static IDE PrimaryIDE;
        public static IDE SecondayIDE;

        public static List<BlockDevice> Devices = new List<BlockDevice>();

        public static void Init()
        {
            //Load Serial Port at COM-1
            Console.Write("Loading Serial Ports... ");
            Serials.SetupPort();
            Console.WriteLine("OK");

            // Setup PCI
            Console.Write ("Setting up PCI... ");
            PCI.Setup();
            Console.WriteLine ("OK");

            // Start ACPI
            // Initializes and enables itself
            Console.Write ("Setting up ACPI... ");
            //ACPI = new acpi(true, true);
            Console.WriteLine ("OK");

            // Setup Keyboard
            Console.Write("Setting up PS/2 Keyboard... ");
            KBD = new Keyboard();
            Console.WriteLine("OK");

            // Setup Mouse
            //Console.Write ("Setting up PS/2 Mouse... ");
            Mouse = new PS2Mouse();
            //Console.WriteLine ("OK");

            //Loading ATA
            Console.Write ("Loading ATA/SATA SubSystem... ");
            LoadATA();
            Console.WriteLine("OK");

            //Load Parts
            Console.Write ("Loading Partitions... ");
            if (PrimaryIDE != null && PrimaryIDE.DriveInfo.Device == Device.IDE_ATA)
            {
                var xMBR = new Drivers.PartInfo.MBR(PrimaryIDE);
                for (int i = 0; i < xMBR.PartInfo.Count; i++)
                    Devices.Add(xMBR.PartInfo[i]);
            }
            Console.WriteLine("OK");
        }

        private static void LoadATA()
        {
            PCIDevice xDevice = PCI.GetDeviceClass(0x1, 0x1); //Media Storage - IDE Controller
            if (xDevice != null)
            {
                //We are going to support only parallel ata
                PrimaryIDE = new IDE(false);
                SecondayIDE = new IDE(true);

                if (PrimaryIDE.DriveInfo.Device != Device.IDE_None)
                {
                    Devices.Add(PrimaryIDE);
                    xINT.RegisterHandler(delegate() { PrimaryIDE.IRQInvoked = true; }, 0x2E);
                }

                if (SecondayIDE.DriveInfo.Device != Device.IDE_None)
                {
                    Devices.Add(SecondayIDE);
                    xINT.RegisterHandler(delegate() { SecondayIDE.IRQInvoked = true; }, 0x2F);
                }
            }
            /*
            xDevice = PCI.GetDeviceClass(0x1, 0x6);//Media Storage - SATA
            if (xDevice != null)
            {

            }*/
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Structure defination for different compositor request
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Runtime.InteropServices;

namespace Atomix.Kernel_H.Gui
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    internal struct GuiRequest
    {
        [FieldOffset(0)]
        internal uint HashID;
        [FieldOffset(4)]
        internal int ClientID;
        [FieldOffset(8)]
        internal RequestType Type;
        [FieldOffset(12)]
        internal ErrorType Error;
    };

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    internal unsafe struct MouseEvent
    {
        [FieldOffset(16)]
        internal int WindowID;
        [FieldOffset(20)]
        internal int Button;
        [FieldOffset(24)]
        internal int Xpos;
        [FieldOffset(28)]
        internal int Ypos;
        [FieldOffset(32)]
        internal MouseFunction Function;
    };

    [StructLayout(LayoutKind.Explicit, Size = 44)]
    internal unsafe struct NewWindow
    {
        [FieldOffset(16)]
        internal int X;
        [FieldOffset(20)]
        internal int Y;
        [FieldOffset(24)]
        internal int Width;
        [FieldOffset(28)]
        internal int Height;
        [FieldOffset(32)]
        internal int WindowID;
        [FieldOffset(36)]
        internal fixed sbyte Buffer[8];
    };

    [StructLayout(LayoutKind.Explicit, Size = 36)]
    internal struct Redraw
    {
        [FieldOffset(16)]
        internal int WindowID;
        [FieldOffset(20)]
        internal int X;
        [FieldOffset(24)]
        internal int Y;
        [FieldOffset(28)]
        internal int Width;
        [FieldOffset(32)]
        internal int Height;
    };

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    internal struct WindowMove
    {
        [FieldOffset(16)]
        internal int WindowID;
        [FieldOffset(20)]
        internal int RelX;
        [FieldOffset(24)]
        internal int RelY;
    };

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    internal struct DragRequest
    {
        [FieldOffset(16)]
        internal int WindowID;
    };

    [StructLayout(LayoutKind.Explicit, Size = 36)]
    internal struct InfoRequest
    {
        [FieldOffset(16)]
        internal int WindowID;
        [FieldOffset(20)]
        internal int X;
        [FieldOffset(24)]
        internal int Y;
        [FieldOffset(28)]
        internal int Width;
        [FieldOffset(32)]
        internal int Height;
    };

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    internal struct Rect
    {
        [FieldOffset(0)]
        internal int X;
        [FieldOffset(4)]
        internal int Y;
        [FieldOffset(8)]
        internal int Width;
        [FieldOffset(12)]
        internal int Height;
    };

    internal enum RequestType : uint
    {
        None = 0,
        NewWindow = 1,
        Redraw = 2,
        WindowMove = 3,
        MouseEvent = 4,
        KeyboardEvent = 5,
        DragRequest = 6,
        InfoRequest = 7
    };

    internal enum ErrorType : uint
    {
        None = 0,
        BadRequest = 1,
        BadParameters = 2,
        OutOfMemory = 3,
        BadFunction = 4,
    };

    internal enum MouseIcon : int
    {
        None = 0,
        Idle = 1,
        Help = 2,
        Clipboard = 3,
        Busy = 4
    };

    internal enum WindowState : int
    {
        None = 0,
        FullScreen = 1,
        Minimized = 2,
        Close = 3,
    };

    internal enum MouseFunction : int
    {
        None = 0,
        KeyUp = 1,
        KeyDown = 2,
        Move = 4,
        Enter = 8,
        Click = 16
    };
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          kernel Heap Memory Manager
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Lib;
using Atomixilc.Attributes;

namespace Atomix.Kernel_H.Core
{
    internal static unsafe class Heap
    {
        static uint HeapStart;
        static uint HeapCurrent;
        static uint HeapEnd;

        /// <summary>
        /// Keep track of free block address and there size (contigous) in the memory
        /// These array should not free up, and hence resides in old heap space
        /// </summary>
        static uint[] BlockAddress;
        static uint[] BlockSize;

#warning [Heap] : "HeapManagerSize" is a constant
        static bool HeapManagerSetup;
        static int HeapManagerPosition;
        // ~16K items, complete assumption, so should take care of this
        const int HeapManagerSize = 1024 * 16;

        static uint HeapLock;

        internal static void Init(uint InitHeap)
        {
            HeapStart = InitHeap;
            HeapCurrent = InitHeap;
#warning [Heap] : "HeapEnd" and "HeapStart" are based on assumption for initial heap setup.
            HeapEnd = HeapStart + 0x100000;
            HeapManagerSetup = false;

            Debug.Write("Heap Initialized!!\n");
            Debug.Write("       Start Address::%d\n", InitHeap);
            Debug.Write("       End Address  ::%d\n", HeapEnd);

            // Allocate memory for future heap manager
            BlockSize = new uint[HeapManagerSize];
            BlockAddress = new uint[HeapManagerSize];
        }

        internal static void Setup(uint Start, uint End)
        {
            HeapStart = Start;
            HeapCurrent = Start;
            HeapEnd = End;

            Debug.Write("New Heap Setup!!\n");
            Debug.Write("       Start Address::%d\n", Start);
            Debug.Write("       End Address  ::%d\n", End);

            // Assign rest of memory as free
            BlockAddress[0] = HeapStart;
            BlockSize[0] = HeapEnd - HeapStart;
            HeapManagerPosition = 1;
            HeapManagerSetup = true;
        }

        [Label(Atomixilc.Helper.Heap_Label)]
        internal static uint kmalloc(uint len)
        {
            if (!HeapManagerSetup)
            {
                if (HeapCurrent + len > HeapEnd)
                {
                    Debug.Write("Memory out of run before real heap :(");
                }
                uint tmp = HeapCurrent;
                HeapCurrent += len;
                Memory.FastClear(tmp, len);
                return tmp;
            }
            else
            {
                var address = kmalloc(len, false);
                GC.Notify(address, len);
                return address;
            }
        }

        internal static uint kmalloc(uint len, bool Aligned)
        {
            // If Heap Manager is not setup then use our old heap alogrithm -- Basically paging is calling this
            if (Aligned && !HeapManagerSetup)
            {
                if ((HeapCurrent & 0xFFFFF000) != HeapCurrent)
                {
                    HeapCurrent = (HeapCurrent & 0xFFFFF000) + 0x1000;
                }
                return kmalloc(len);
            }

            Monitor.AcquireLock(ref HeapLock);

            // Find a suitable hole
            int iterator;
            for (iterator = 0; iterator < HeapManagerPosition; iterator++)
            {
                if (Aligned)
                {
                    uint pos = BlockAddress[iterator];
                    uint size = BlockSize[iterator];
                    uint offset = 0;
                    if ((pos & 0xFFFFF000) != pos)
                    {
                        // Not aligned
                        offset = (pos & 0xFFFFF000) - pos + 0x1000;
                    }

                    // Check if we fit?
                    if (size >= len + offset)
                        break; // Yes :)
                }
                else if (BlockSize[iterator] >= len)
                    break; // Yes :)
            }

            if (iterator == HeapManagerPosition || HeapManagerPosition == HeapManagerSize) //No block to allocate :(
            {
                Debug.Write("Memory out of run :(\n");
                while (true) ;
            }

            // So, memory need to be aligned?
            if (Aligned)
                return malloc_aligned(iterator, len);

            // So we have a block, right?
            uint Address = BlockAddress[iterator];
            uint Size = BlockSize[iterator];
            if (Size > len) // we have to split the block
            {
                uint Add2 = Address + len;
                uint Size2 = Size - len;
                for (int i = 0; i <= iterator; i++)
                {
                    if (BlockSize[i] > Size2)
                    {
                        // here we have to put this
                        // Shift everything else
                        for (int j = iterator; j >= i + 1; j--)
                        {
                            BlockSize[j] = BlockSize[j - 1];
                            BlockAddress[j] = BlockAddress[j - 1];
                        }
                        BlockSize[i] = Size2; // Now put this element and come out
                        BlockAddress[i] = Add2;
                        break;
                    }
                }
            }
            else // we find a perfect size
            {
                // Remove this from free and return it
                iterator++;
                for (; iterator < HeapManagerPosition; iterator++)
                {
                    BlockAddress[iterator - 1] = BlockAddress[iterator];
                    BlockSize[iterator - 1] = BlockSize[iterator];
                }
                HeapManagerPosition--; // Reduce size of array, no need to clear last empty because we never read it
            }
            Monitor.ReleaseLock(ref HeapLock);
            Memory.FastClear(Address, len); // Clear the memory and return
            return Address;
        }

        private static uint malloc_aligned(int iterator, uint len)
        {
            uint Address = BlockAddress[iterator];
            uint Size = BlockSize[iterator];

            uint pos = Address;
            if ((Address & 0xFFFFF000) != Address)
            {
                pos = (Address & 0xFFFFF000) + 0x1000; // Align it first
            }

            uint NewSize = (pos - Address);
            if (NewSize != 0) // Maybe it is not aligned left, so mark left part free
            {
                for (int i = 0; i <= iterator; i++)
                {
                    if (BlockSize[i] > NewSize)
                    {
                        for (int j = iterator; j >= i + 1; j--)
                        {
                            BlockSize[j] = BlockSize[j - 1];
                            BlockAddress[j] = BlockAddress[j - 1];
                        }
                        BlockSize[i] = NewSize;
                        BlockAddress[i] = Address;
                        break;
                    }
                }
            }

            NewSize = Size - len - NewSize; // End block
            Address = pos + len;
            if (NewSize != 0) // Free up end part of this too
            {
                int i;
                for (i = 0; i <= iterator; i++)
                {
                    if (BlockSize[i] > NewSize)
                    {
                        for (int j = iterator; j >= i + 1; j--)
                        {
                            BlockSize[j] = BlockSize[j - 1];
                            BlockAddress[j] = BlockAddress[j - 1];
                        }
                        BlockSize[i] = NewSize;
                        BlockAddress[i] = Address;
                        break;
                    }
                }

                if (i > iterator)
                {
                    // we are at the end
                    BlockSize[HeapManagerPosition] = NewSize;
                    BlockAddress[HeapManagerPosition] = Address;
                    HeapManagerPosition++;
                }
            }
            Monitor.ReleaseLock(ref HeapLock);
            Memory.FastClear(pos, len);
            return pos;
        }

        [Label("__Heap_Free__")]
        internal static void Free(uint Address, uint len)
        {
            if (len == 0)
                return;

            Monitor.AcquireLock(ref HeapLock);

            // Check if any block can fit to left/Right of this
            int iterator, left = -1, right = -1;
            for (iterator = 0; iterator < HeapManagerPosition; iterator++)
            {
                uint Add = BlockAddress[iterator];
                uint Size = BlockSize[iterator];
                if (Add + Size == Address)
                {
                    left = iterator;
                }
                else if (Add == Address + len)
                {
                    right = iterator;
                }
            }

            // Compute new address and new size of block
            uint NewAddress = Address;
            uint NewSize = len;
            if (left != -1)
            {
                NewAddress = BlockAddress[left];
                NewSize += BlockSize[left];
            }

            if (right != -1)
            {
                NewSize += BlockSize[right];
            }

            // Remove left and right blocks
            int lastempty = 0;
            for (iterator = 0; iterator < HeapManagerPosition; iterator++)
            {
                if (iterator == left ||
                    iterator == right)
                    continue;
                BlockAddress[lastempty] = BlockAddress[iterator];
                BlockSize[lastempty] = BlockSize[iterator];
                lastempty++;
            }
            HeapManagerPosition = lastempty;

            // Add our new block to memory
            for (iterator = 0; iterator < HeapManagerPosition; iterator++)
            {
                if (BlockSize[iterator] > NewSize)
                {
                    // here we have to put this
                    // Shift everything else
                    for (int j = HeapManagerPosition; j >= iterator + 1; j--)
                    {
                        BlockSize[j] = BlockSize[j - 1];
                        BlockAddress[j] = BlockAddress[j - 1];
                    }
                    BlockSize[iterator] = NewSize; // Now put this element and come out
                    BlockAddress[iterator] = NewAddress;
                    HeapManagerPosition++;
                    iterator = -1; // Flag
                    break;
                }
            }
            if (iterator != -1) // End of loop
            {
                BlockSize[HeapManagerPosition] = NewSize;
                BlockAddress[HeapManagerPosition] = NewAddress;
                HeapManagerPosition++;
            }
            Monitor.ReleaseLock(ref HeapLock);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          File Contains various mscorlib plug
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomix.Kernel_H.plugs
{
    internal static class PlugHelper
    {
        /// <summary>
        /// Dummy plug don't let the compiler to compile method with given signature
        /// </summary>
        [Plug("System_Void_System_Char__cctor__")]
        internal static void Char_ctor()
        {

        }

        [Plug("System_Boolean_System_Object_Equals_System_Object_")]
        internal static bool Object_Equals(uint aObjA, uint aObjB)// Treat it as address
        {
            return (aObjA == aObjB);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Text;
using Kernel_alpha.x86;
using Kernel_alpha.x86.Intrinsic;
using Kernel_alpha.Drivers;

namespace Kernel_alpha.Drivers.Buses.ATA
{
    public class IDE : BlockDevice
    {
        private IOPort DataReg;
        private IOPort FeatureReg;
        private IOPort CommandReg;
        private IOPort StatusReg;
        private IOPort AltStatusReg;
        private IOPort ControlReg;
        private IOPort SectorCountReg;

        private IOPort LBA0;
        private IOPort LBA1;
        private IOPort LBA2;

        private IOPort DeviceSelect;

        private UInt16 xBAR0;
        private UInt16 xBAR1;

        public DriveInfo DriveInfo;
        public bool IRQInvoked;

        public IDE(bool aSecondary, bool IsMaster = true)
        {
            xBAR0 = (ushort)(aSecondary ? 0x0170 : 0x01F0);
            xBAR1 = (ushort)(aSecondary ? 0x0376 : 0x03F6);

            DriveInfo.Channel = (aSecondary ? Channel.ATA_SECONDARY : Channel.ATA_PRIMARY);
            DriveInfo.Type = (aSecondary ? DeviceType.ATA_MASTER : DeviceType.ATA_SLAVE);

            Init();
        }

        private void Init()
        {
            DataReg = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_DATA));
            FeatureReg = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_FEATURES));
            SectorCountReg = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_SECCOUNT0));
            CommandReg = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_COMMAND));
            StatusReg = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_STATUS));
            AltStatusReg = new IOPort((UInt16)(xBAR1 + (byte)Register.ATA_REG_ALTSTATUS));
            ControlReg = new IOPort((UInt16)(xBAR1 + (byte)Register.ATA_REG_CONTROL));

            LBA0 = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_LBA0));
            LBA1 = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_LBA1));
            LBA2 = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_LBA2));

            DeviceSelect = new IOPort((UInt16)(xBAR0 + (byte)Register.ATA_REG_HDDEVSEL));
            DriveInfo = new ATA.DriveInfo();

            // 2- Disable IRQs:
            ControlReg.Byte = 0x2;

            //Discover what we have =P
            Discover();
        }

        /// <summary>
        /// This method discover the current ATA device and try to read all its configurations
        /// </summary>
        private void Discover()
        {
            DriveInfo.Device = Device.IDE_None;
            DriveInfo.BufferSize = 0;

            Status xStatus;
            bool Error = false;

            //Select Drive
            SelectDrive();

            //Send Identify command
            CommandReg.Byte = (byte)Cmd.ATA_CMD_IDENTIFY;
            Wait();

            if (StatusReg.Byte == 0)
                return; //No Device

            while (true)
            {
                xStatus = (Status)StatusReg.Byte;
                if ((xStatus & Status.ATA_SR_ERR) != 0)
                {
                    Error = true; // If Err, Device is not ATA.
                    break;
                }

                if (((xStatus & Status.ATA_SR_BSY) == 0) && ((xStatus & Status.ATA_SR_DRQ) != 0))
                    break; //Everything is fine
                Wait();
            }

            DriveInfo.Device = Device.IDE_ATA;
            DriveInfo.BufferSize = 512;

            // (IV) Probe for ATAPI Devices:
            if (Error)
            {
                ushort xTypeID = (ushort)(LBA2.Byte << 8 | LBA1.Byte);
                if (xTypeID == 0xEB14 || xTypeID == 0x9669)
                {
                    DriveInfo.Device = Device.IDE_ATAPI;
                    DriveInfo.BufferSize = 2048;
                }
                else
                {
                    DriveInfo.Device = Device.IDE_None;
                    DriveInfo.BufferSize = 0;
                    return;
                }

                //Send Identify packet command
                CommandReg.Byte = (byte)Cmd.ATA_CMD_IDENTIFY_PACKET;
                Wait();
            }

            var xBuff = new ushort[256];
            DataReg.Read16(xBuff);

            //ATA/ATAPI COnfig
            DriveInfo.IsRemovable       = (xBuff[(int)Identify.ATA_IDENT_DEVICETYPE] & (1 << 7)) > 0;

            //CHS configurations
            DriveInfo.Cylinder          = xBuff.ToUInt32((int)Identify.ATA_IDENT_CYLINDERS);
            DriveInfo.Heads             = xBuff.ToUInt32((int)Identify.ATA_IDENT_HEADS);
            DriveInfo.SectorsPerTrack   = xBuff.ToUInt32((int)Identify.ATA_IDENT_SECTORS);
            DriveInfo.CommandSet        = xBuff.ToUInt32((int)Identify.ATA_IDENT_COMMANDSETS);

            ushort xFieldValid = xBuff[(int)Identify.ATA_IDENT_FIELDVALID];
            //1st bit determine weather it support LBA or not
            DriveInfo.LBASupport = (bool)((xFieldValid & 1) == 1);

            if ((DriveInfo.CommandSet & (1 << 26)) != 0)
                // Device uses 48-Bit Addressing:
                DriveInfo.Size = xBuff.ToUInt48((int)Identify.ATA_IDENT_MAX_LBA_EXT);
            else
                // Device uses CHS or 28-bit Addressing:
                DriveInfo.Size = xBuff.ToUInt32((int)Identify.ATA_IDENT_MAX_LBA);

            //Read Model, Firmware, SerialNo.
            DriveInfo.Model = xBuff.GetString((int)Identify.ATA_IDENT_MODEL, 40);
            DriveInfo.SerialNo = xBuff.GetString((int)Identify.ATA_IDENT_SERIAL, 20);
        }

        public override void Read(UInt32 SectorNo, uint SectorCount, byte[] xData)
        {
            Access_Disk(SectorNo, SectorCount, xData, true);
        }

        public override void Write(UInt32 SectorNo, uint SectorCount, byte[] xData)
        {
            Access_Disk(SectorNo, SectorCount, xData, false);
        }

        private byte[] xATAPI_Packet = new byte[12] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        private void Access_Disk(UInt32 SectorNo, uint SectorCount, byte[] xData, bool IsReading)
        {
            if (DriveInfo.Device == Device.IDE_ATAPI)
            {
                /*
                 * Only 1 sector we can read at a time
                 */
                if (IsReading)
                {
                    //SCSI Packet Command
                    xATAPI_Packet[0] = (byte)Cmd.ATAPI_CMD_READ;
                    xATAPI_Packet[1] = 0x00;
                    xATAPI_Packet[2] = (byte)((SectorNo >> 24) & 0xFF);
                    xATAPI_Packet[3] = (byte)((SectorNo >> 16) & 0xFF);
                    xATAPI_Packet[4] = (byte)((SectorNo >> 8) & 0xFF);
                    xATAPI_Packet[5] = (byte)((SectorNo >> 0) & 0xFF);
                    xATAPI_Packet[6] = 0x00;
                    xATAPI_Packet[7] = 0x00;
                    xATAPI_Packet[8] = 0x00;
                    xATAPI_Packet[9] = (byte)(SectorCount & 0xFF);
                    xATAPI_Packet[10] = 0x00;
                    xATAPI_Packet[11] = 0x00;

                    //Enable IRQ
                    IRQInvoked = false;
                    ControlReg.Byte = 0x0;

                    SelectDrive();

                    FeatureReg.Byte = 0x0;//Tell controller that we are going to use PIO mode

                    //Tell constroller the size of each buffer
                    LBA1.Byte = (byte)((DriveInfo.BufferSize) & 0xFF);// Lower Byte of Sector Size. ATA_LBA_MID_PORT
                    LBA2.Byte = (byte)((DriveInfo.BufferSize >> 8) & 0xFF);// Upper Byte of Sector Size. ATA_LBA_HI_PORT

                    //Send Packet command
                    Send_SCSI_Package();

                    //Actual size that is to transferred
                    UInt32 size = (UInt32)(LBA2.Byte << 8 | LBA1.Byte);

                    //Read the data
                    DataReg.Read16(xData, size);

                    WaitIRQ();
                    while (((Status)StatusReg.Byte & (Status.ATA_SR_BSY | Status.ATA_SR_DRQ)) != 0) ;
                }
            }
            else if (DriveInfo.Device == Device.IDE_ATA)
            {
                //Disable IRQ
                IRQInvoked = false;
                ControlReg.Byte = 0x2;

                ushort lba_mode, cyl;
                byte head, sect;
                byte[] lba_io = new byte[6];

                // (I) Select one from LBA28, LBA48 or CHS;
                if (SectorNo >= 0x10000000)
                {
                    // LBA48:
                    lba_mode = 2;
                    lba_io[0] = (byte)((SectorNo & 0x000000FF) >> 0);
                    lba_io[1] = (byte)((SectorNo & 0x0000FF00) >> 8);
                    lba_io[2] = (byte)((SectorNo & 0x00FF0000) >> 16);
                    lba_io[3] = (byte)((SectorNo & 0xFF000000) >> 24);
                    lba_io[4] = 0; // LBA28 is integer, so 32-bits are enough to access 2TB.
                    lba_io[5] = 0; // LBA28 is integer, so 32-bits are enough to access 2TB.
                    head = 0; // Lower 4-bits of HDDEVSEL are not used here.
                }
                else if ((DriveInfo.CommandSet & (1 << 26)) != 0)
                {
                    // LBA28:
                    lba_mode = 1;
                    lba_io[0] = (byte)((SectorNo & 0x00000FF) >> 0);
                    lba_io[1] = (byte)((SectorNo & 0x000FF00) >> 8);
                    lba_io[2] = (byte)((SectorNo & 0x0FF0000) >> 16);
                    lba_io[3] = 0; // These Registers are not used here.
                    lba_io[4] = 0; // These Registers are not used here.
                    lba_io[5] = 0; // These Registers are not used here.
                    head = (byte)((SectorNo & 0xF000000) >> 24);
                }
                else
                {
                    // CHS:
                    lba_mode = 0;
                    sect = (byte)((SectorNo % 63) + 1);
                    cyl = (ushort)((SectorNo + 1 - sect) / (16 * 63));
                    lba_io[0] = (byte)(sect & 0xFF);
                    lba_io[1] = (byte)((cyl >> 0) & 0xFF);
                    lba_io[2] = (byte)((cyl >> 8) & 0xFF);
                    lba_io[3] = 0;
                    lba_io[4] = 0;
                    lba_io[5] = 0;
                    head = (byte)((SectorNo + 1 - sect) % (16 * 63) / (63)); // Head number is written to HDDEVSEL lower 4-bits.
                }

                while (((Status)StatusReg.Byte & Status.ATA_SR_BSY) != 0) ;

                // (IV) Select Drive from the controller;
                if (lba_mode == 0)
                    SelectDrive(head, false);
                else
                    SelectDrive(head, true);

                // (V) Write Parameters;
                if (lba_mode == 2)
                {
                    throw new Exception("Yet to implement");
                }
                SectorCountReg.Byte = (byte)(SectorCount & 0xFF);
                LBA0.Byte = lba_io[0];
                LBA1.Byte = lba_io[1];
                LBA2.Byte = lba_io[2];

                //We are not using DMA so don't care about that
                byte cmd = 0;
                if (lba_mode == 0 && IsReading) cmd = (byte)Cmd.ATA_CMD_READ_PIO;
                else if (lba_mode == 1 && IsReading) cmd = (byte)Cmd.ATA_CMD_READ_PIO;
                else if (lba_mode == 2 && IsReading) cmd = (byte)Cmd.ATA_CMD_READ_PIO_EXT;
                else if (lba_mode == 0 && !IsReading) cmd = (byte)Cmd.ATA_CMD_WRITE_PIO;
                else if (lba_mode == 1 && !IsReading) cmd = (byte)Cmd.ATA_CMD_WRITE_PIO;
                else if (lba_mode == 2 && !IsReading) cmd = (byte)Cmd.ATA_CMD_WRITE_PIO_EXT;

                CommandReg.Byte = cmd;

                if (IsReading)
                {
                    // PIO Read.
                    Poll(true);// Polling, set error and exit if there is.
                    DataReg.Read16(xData);
                }
                else
                {
                    // PIO Write.
                    Poll(false);//Just Poll we don't want any error
                    DataReg.Write16(xData);
                    switch (lba_mode)
                    {
                        case 0:
                        case 1:
                            CommandReg.Byte = (byte)Cmd.ATA_CMD_CACHE_FLUSH;
                            break;
                        case 2:
                            CommandReg.Byte = (byte)Cmd.ATA_CMD_CACHE_FLUSH_EXT;
                            break;
                    };
                    Poll(false);
                }
            }
        }

        public void Eject()
        {
            if (DriveInfo.Device == Device.IDE_ATAPI)
            {
                //SCSI Packet Command
                xATAPI_Packet[0] = (byte)Cmd.ATAPI_CMD_EJECT;
                xATAPI_Packet[1] = 0x00;
                xATAPI_Packet[2] = 0x00;
                xATAPI_Packet[3] = 0x00;
                xATAPI_Packet[4] = 0x02;
                xATAPI_Packet[5] = 0x00;
                xATAPI_Packet[6] = 0x00;
                xATAPI_Packet[7] = 0x00;
                xATAPI_Packet[8] = 0x00;
                xATAPI_Packet[9] = 0x00;
                xATAPI_Packet[10] = 0x00;
                xATAPI_Packet[11] = 0x00;

                //Enable IRQ; Currently IRQ is not working...so we ignore it but very important
                IRQInvoked = false;
                ControlReg.Byte = 0x0;

                SelectDrive();

                Send_SCSI_Package();
            }
        }

        private void Send_SCSI_Package()
        {
            //Tell Controller that we are sending package
            CommandReg.Byte = (byte)Cmd.ATA_CMD_PACKET;

            //Wait till device get ready
            Poll(true);

            //Send SCSI-Packet command to controller
            DataReg.Write16(xATAPI_Packet);

            //IRQ
            WaitIRQ();

            //Poll and check for error
            Poll(false);
        }

        private void Poll(bool AdvancedCheck)
        {
            // (I) Delay 400 nanosecond for BSY to be set:
            Wait();

            // (II) Wait for BSY to be cleared:
            // -------------------------------------------------
            while (((Status)StatusReg.Byte & Status.ATA_SR_BSY) != 0)
                ; // Wait for BSY to be zero.

            if (AdvancedCheck)
            {
                var xState = (Status)StatusReg.Byte;

                // (III) Check For Errors:
                // -------------------------------------------------
                if ((xState & Status.ATA_SR_ERR) != 0)
                    throw new Exception("ATA Error");

                // (IV) Check If Device fault:
                // -------------------------------------------------
                if ((xState & Status.ATA_SR_DF) != 0)
                    throw new Exception("ATA Device Fault");

                // (V) Check DRQ:
                // -------------------------------------------------
                // BSY = 0; DF = 0; ERR = 0 so we should check for DRQ now.
                if ((xState & Status.ATA_SR_DRQ) == 0)
                    throw new Exception("ATA DRQ should be set");
            }
        }
        /// <summary>
        /// 0 - Master
        /// 1 - Slave
        /// </summary>
        /// <param name="disk"></param>
        private void SelectDrive()
        {
            DeviceSelect.Byte = (byte)((byte)DriveInfo.Type << 4);
            Wait();
        }

        private void SelectDrive(byte head, bool lba)
        {
            if (!lba)
                DeviceSelect.Byte = (byte)(0xA0 | ((byte)DriveInfo.Type << 4) | head); // Drive & CHS.
            else
                DeviceSelect.Byte = (byte)(0xE0 | ((byte)DriveInfo.Type << 4) | head); // Drive & LBA
            Wait();
        }

        private void Wait()
        {
            //reading status byte takes 100ns
            byte n;
            n = StatusReg.Byte;
            n = StatusReg.Byte;
            n = StatusReg.Byte;
            n = StatusReg.Byte;
        }

        private void WaitIRQ()
        {
            while (!IRQInvoked) ;
            IRQInvoked = false;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          IDictionay Generic Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.Lib
{
    internal class IDictionary<_key, _value>
    {
        const uint Capacity = (1 << 5);// Should be a power of 2

        uint mModulo;
        Bucket[] mBuckets;

        HashFunction<_key> mFunction;
        EqualityFunction<_key> mEquality;

        class Bucket
        {
            public _key mKey;
            public _value mValue;
            public Bucket mNext;
        }

        internal IDictionary(HashFunction<_key> aFunction, EqualityFunction<_key> aEquality)
        {
            mFunction = aFunction;
            mEquality = aEquality;
            mModulo = Capacity - 1;
            mBuckets = new Bucket[Capacity];
        }

        internal _value this[_key aKey]
        {
            get
            {
                uint Index = mFunction(aKey) & mModulo;
                Bucket Current = mBuckets[Index];

                while (Current != null && !mEquality(Current.mKey, aKey))
                    Current = Current.mNext;

                if (Current == null || !mEquality(Current.mKey, aKey))
                    throw new Exception("[IDictionary]: Key not found!");

                return Current.mValue;
            }
        }

        internal _value GetValue(_key aKey, _value defaultValue)
        {
            uint Index = mFunction(aKey) & mModulo;
            Bucket Current = mBuckets[Index];

            while (Current != null && !mEquality(Current.mKey, aKey))
                Current = Current.mNext;

            if (Current == null || !mEquality(Current.mKey, aKey))
                return defaultValue;

            return Current.mValue;
        }

        internal void Add(_key aKey, _value aValue)
        {
            if (SafeAdd(aKey, aValue))
                return;
            throw new Exception("[IDictionary]: Key Already present!");
        }

        internal bool SafeAdd(_key aKey, _value aValue)
        {
            uint Index = mFunction(aKey) & mModulo;
            Bucket Current = mBuckets[Index];

            Bucket NewBucket = new Bucket
            {
                mKey = aKey,
                mValue = aValue,
                mNext = null
            };

            if (Current == null)
            {
                mBuckets[Index] = NewBucket;
                return true;
            }

            while (Current.mNext != null && !mEquality(Current.mKey, aKey))
                Current = Current.mNext;

            if (Current.mNext != null)
                return false;

            Current.mNext = NewBucket;
            return true;
        }

        internal bool ContainsKey(_key aKey)
        {
            uint Index = mFunction(aKey) & mModulo;
            Bucket Current = mBuckets[Index];

            while (Current != null && !mEquality(Current.mKey, aKey))
                Current = Current.mNext;

            if (Current == null)
                return false;

            return true;
        }

        internal void RemoveKey(_key mKey)
        {
            uint Index = mFunction(mKey) & mModulo;
            Bucket Current = mBuckets[Index];

            if (Current == null)
                throw new Exception("[IDictionary]: Key not present!");

            Bucket ToDelete;
            if (mEquality(Current.mKey, mKey))
            {
                mBuckets[Index] = Current.mNext;
                ToDelete = Current;
            }
            else
            {
                while (Current.mNext != null && !mEquality(Current.mNext.mKey, mKey))
                    Current = Current.mNext;

                if (Current.mNext == null)
                    throw new Exception("[IDictionary]: Key not present!");

                ToDelete = Current.mNext;
                Current.mNext = ToDelete.mNext;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Kernel IDT Setup
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

using Atomix.Kernel_H.Core;

using System.Runtime.InteropServices;

namespace Atomix.Kernel_H.Arch.x86
{
    internal delegate void InterruptHandler(ref IRQContext state);

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    internal struct IRQContext
    {
        [FieldOffset(0)]
        public int EDI;
        [FieldOffset(4)]
        public int ESI;
        [FieldOffset(8)]
        public int EBP;
        [FieldOffset(12)]
        public int ESP;
        [FieldOffset(16)]
        public int EBX;
        [FieldOffset(20)]
        public int EDX;
        [FieldOffset(24)]
        public int ECX;
        [FieldOffset(28)]
        public int EAX;
        [FieldOffset(32)]
        public int Interrupt;
        [FieldOffset(36)]
        public int ErrorCode;
        [FieldOffset(40)]
        public int EIP;
        [FieldOffset(44)]
        public int CS;
        [FieldOffset(48)]
        public int EFlags;
    };

    internal static unsafe class IDT
    {
        private static InterruptHandler[] xINT;

        internal static void Setup()
        {
            var idt = Heap.kmalloc(2048 + 6, false);
            var idt_entries = idt + 6;

            Memory.Write16(idt, (0x8 * 256) - 1);
            Memory.Write32(idt + 2, idt_entries);

            Debug.Write("IDT Setup!!\n");
            Debug.Write("       Table Address::%d\n", idt);
            Debug.Write("       Entry Address::%d\n", idt_entries);

            LoadIDT(idt, idt_entries);
            Debug.Write("       IDT-Loaded\n");

            xINT = new InterruptHandler[256];
        }

        [Label("__Interrupt_Handler__")]
        private static unsafe void ProcessInterrupt(ref IRQContext xContext)
        {
            var interrupt = xContext.Interrupt;
            var Handler = xINT[interrupt];

            if (Handler != null)
                Handler(ref xContext);
            else if (interrupt < 0x20)
                Fault.Handle(ref xContext);
            else
                Debug.Write("Unhandled Interrupt %d\n", (uint)interrupt);

            // Send End of Interrupt for IRQs
            if (interrupt >= 0x20)
                PIC.EndOfInterrupt(interrupt);
        }

        internal static void RegisterInterrupt(InterruptHandler xHandler, uint Interrupt)
        {
            xINT[Interrupt] = xHandler;
            Debug.Write("Interrupt Handler Registered: %d\n", Interrupt);
        }

        [Assembly(true)]
        private static void LoadIDT(uint idt_table, uint idt_entries)
        {
            new Cli ();
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            for (int i = 0; i <= 0xFF; i++)
            {
                if (i == 1 || i == 3)
                    continue;

                var xHex = i.ToString("X2");

                new Mov { DestinationReg = Register.EBX, SourceRef = "__ISR_Handler_" + xHex };
                new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = (i * 8) + 0, SourceReg = Register.BX, Size = 16 };

                new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = (i * 8) + 2, SourceRef = "0x8", Size = 8 };
                new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = (i * 8) + 5, SourceRef = "0x8E", Size = 8 };

                new Shr { DestinationReg = Register.EBX, SourceRef = "0x10" };

                new Mov { DestinationReg = Register.EAX, DestinationIndirect = true, DestinationDisplacement = (i * 8) + 6, SourceReg = Register.BX, Size = 16 };
            }
            var xLabel = Label.Primary + ".End";
            new Jmp { DestinationRef = xLabel };

            var xInterruptsWithParam = new int[] { 8, 10, 11, 12, 13, 14 };
            for (int i = 0; i <= 255; i++)
            {
                if (i == 1 || i == 3 || i == 0x20 || i == 0x75)
                    continue;

                var xHex = i.ToString("X2");
                new Label ("__ISR_Handler_" + xHex);

                new Cli ();
                if(Array.IndexOf(xInterruptsWithParam, i) == -1)
                {
                    new Push { DestinationRef = "0x0" };
                }

                new Push { DestinationRef = "0x" + xHex };
                new Pushad();
                new Mov { DestinationReg = Register.EAX, SourceReg = Register.ESP };
                new And { DestinationReg = Register.ESP, SourceRef = "0xFFFFFFF0" };
                new Sub { DestinationReg = Register.ESP, SourceRef = "0x200" };
                new Literal("fxsave [ESP]");
                new Push { DestinationReg = Register.EAX };
                new Push { DestinationReg = Register.EAX };
                new Literal("jmp 8:__ISR_Handler_" + xHex + ".SetCS");

                new Label("__ISR_Handler_" + xHex + ".SetCS");
                new Call { DestinationRef = "__Interrupt_Handler__", IsLabel = true };
                new Pop { DestinationReg = Register.EAX };
                new Literal("fxrstor [ESP]");
                new Mov { DestinationReg = Register.ESP, SourceReg = Register.EAX };
                new Popad();
                new Add { DestinationReg = Register.ESP, SourceRef = "0x8" };
                new Sti();
                new Iret();
            }

            new Label (xLabel);
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0xC, SourceIndirect = true };
            new Literal ("lidt [EAX]");
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          IList Generic Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.Lib
{
    internal class IList<T>
    {
        T[] _items;
        int _size;
        int _capacity;

        internal IList(int capacity = 1)
        {
            _items = new T[capacity];
            _size = 0;
            _capacity = capacity;
        }

        internal void Add(T item)
        {
            if (_capacity <= _size)
            {
                var _new = new T[_size + _size];
                Array.Copy(_items, _new, _size);
                _items = _new;
                _capacity += _size;
            }
            _items[_size++] = item;
        }

        internal T this[int index]
        {
            get
            {
                return _items[index];
            }
            set
            {
                _items[index] = value;
            }
        }

        internal int Count
        {
            get
            {
                return _size;
            }
        }

        internal void Clear()
        {
            _size = 0;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class Int32
    {
        [Plug("System_String_System_Int32_ToString__")]
        public static string ToString(ref int aThis)
        {
            int x = aThis;
            if (x >= 0)
                return Number.ToString32Bit((uint)x, false);
            else
                return Number.ToString32Bit((uint)(x * -1), true);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class Int64
    {
        [Plug("System_String_System_Int64_ToString__")]
        public static string ToString(ref long aThis)
        {
            long x = aThis;
            if (x >= 0)
                return Number.ToString64Bit((ulong)x, false);
            else
                return Number.ToString64Bit((ulong)(x * -1), true);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          IQueue Generic Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.Lib
{
    internal class IQueue<T>
    {
        T[] _items;
        int _size;
        int _capacity;

        internal IQueue(int capacity = 1)
        {
            _items = new T[capacity];
            _size = 0;
            _capacity = capacity;
        }

        internal void Enqueue(T item)
        {
            if (_capacity <= _size)
            {
                var _new = new T[_size + 1];
                Array.Copy(_items, _new, _size);
                _items = _new;
                _capacity++;
            }
            _items[_size++] = item;
        }

        internal T Dequeue()
        {
            var res = _items[0];
            for (int i = 1; i < _size; i++)
                _items[i - 1] = _items[i];
            _size--;
            return res;
        }

        internal int Count
        {
            get
            {
                return _size;
            }
        }

        internal void Clear()
        {
            _size = 0;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          ISet Generic Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomix.Kernel_H.Lib
{
    internal class ISet<_type>
    {
        const uint Capacity = (1 << 5);// Should be a power of 2

        uint mModulo;
        Bucket[] mBuckets;

        HashFunction<_type> mFunction;
        EqualityFunction<_type> mEquality;

        class Bucket
        {
            public _type mKey;
            public Bucket mNext;
        }

        internal ISet(HashFunction<_type> aFunction, EqualityFunction<_type> aEquality)
        {
            mFunction = aFunction;
            mEquality = aEquality;
            mModulo = Capacity - 1;
            mBuckets = new Bucket[Capacity];
        }

        internal bool ContainsKey(_type mKey)
        {
            uint Index = mFunction(mKey) & mModulo;
            Bucket Current = mBuckets[Index];

            while (Current != null && !mEquality(Current.mKey, mKey))
                Current = Current.mNext;

            return (Current != null);
        }

        internal void RemoveKey(_type mKey)
        {
            uint Index = mFunction(mKey) & mModulo;
            Bucket Current = mBuckets[Index];

            if (Current == null)
                throw new Exception("[ISet]: Key not present!");

            if (mEquality(Current.mKey, mKey))
                mBuckets[Index] = Current.mNext;

            while (Current.mNext != null && !mEquality(Current.mNext.mKey, mKey))
                Current = Current.mNext;

            if (Current.mNext == null)
                throw new Exception("[ISet]: Key not present!");

            var ToDelete = Current.mNext;
            Current.mNext = ToDelete.mNext;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;
using Atomix.Assembler;
using Atomix.Assembler.x86;
using Kernel_alpha.x86;
using Kernel_alpha.x86.Intrinsic;
using AssemblyHelper = Atomix.Assembler.AssemblyHelper;

namespace Kernel_alpha
{
    [Kernel(CPUArch.x86, "0x000000")]//Fixed Entrypoint, if you change it than i kill you :)
    public static class Kernel_x86
    {
        [Assembly]
        public static void main()
        {
            const uint MultibootMagic = 0x1BADB002;
            const uint MultibootFlags = 0x10007;
            const uint InitalStackSize = 0x50000;

            /* Multiboot Config */
            AssemblyHelper.AssemblerCode.Add(new Literal("MultibootSignature dd {0}", MultibootMagic));
            AssemblyHelper.AssemblerCode.Add(new Literal("MultibootFlags dd {0}", 65543));
            AssemblyHelper.AssemblerCode.Add(new Literal("MultibootChecksum dd {0}", -(MultibootMagic + MultibootFlags)));
            AssemblyHelper.AssemblerCode.Add(new Literal("MultibootHeaderAddr dd {0}", 0));
            AssemblyHelper.AssemblerCode.Add(new Literal("MultibootLoadAddr dd {0}", 0));
            AssemblyHelper.AssemblerCode.Add(new Literal("MultibootLoadEndAddr dd {0}", 0));
            AssemblyHelper.AssemblerCode.Add(new Literal("MultibootBSSEndAddr dd {0}", 0));
            AssemblyHelper.AssemblerCode.Add(new Literal("MultibootEntryAddr dd {0}", 0));

            AssemblyHelper.InsertData(new AsmData("InitialStack", InitalStackSize));

            AssemblyHelper.AssemblerCode.Add(new Label("_Kernel_Main"));

            /* Here is Entrypoint Method */
            AssemblyHelper.AssemblerCode.Add(new Cli()); //Clear interrupts first !!

            //Setup Stack pointer, We do rest things later (i.e. Another method) because they are managed :)
            AssemblyHelper.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESP, SourceRef = "InitialStack" });
            AssemblyHelper.AssemblerCode.Add(new Add { DestinationReg = Registers.ESP, SourceRef = InitalStackSize.ToString() });

            AssemblyHelper.AssemblerCode.Add(new Push { DestinationReg = Registers.EAX });
            AssemblyHelper.AssemblerCode.Add(new Push { DestinationReg = Registers.EBX });//Push Multiboot Header Info Address
            AssemblyHelper.AssemblerCode.Add(new Call ("Kernel_Start"));
        }

        [Plug("Kernel_Start")]
        public static unsafe void Start (uint magic, uint address)
        {
            /* Setup Multiboot */
            Multiboot.Setup(magic, address);

            /* Placement Address */
            Heap.PlacementAddress = Native.EndOfKernel();

            /* Clear Interrupts */
            Native.ClearInterrupt();

            /* Setup PIC */
            PIC.Setup();

            /* Setup GDT & Enter into protected mode */
            GDT.Setup();

            /* Setup IDT */
            IDT.Setup();

            /* Enable Interrupts */
            Native.SetInterrupt();

            /* Setup Paging */
            Paging.Setup(Multiboot.RAM);

            /* Setup Multitasking */
            Multitasking.CreateTask(0, true); //This is System Update thread
            Multitasking.Init();//Start Multitasking

            /* Call our kernel instance now */
            try
            {
                Caller.Start();
                while(true)
                {
                    Caller.Update();
                }
            }
            catch (Exception e)
            {
                //Kernel PANIC !!
                Console.WriteLine(e.Message);
            }

            while (true)  //Set CPU in Infinite loop DON'T REMOVE THIS ELSE I'll KILL YOU (^ . ^)
            {
                Native.ClearInterrupt();
                Native.Halt();
            };
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Kernel_alpha.x86;
using Kernel_alpha.x86.Intrinsic;

namespace Kernel_alpha.Drivers.Input
{
    public class Keyboard
    {
        private Queue<Keys> Buffer;
        private int MaxBuffer;

        public bool NumLock;
        public bool CapsLock;
        public bool ScrollLock;

        public bool Shift;
        public bool Alt;
        public bool Ctrl;

        private KeyCode[] Set = new KeyCode[]
        {
            KeyCode.None,           KeyCode.Esc,            KeyCode.D1,             KeyCode.D2,             //0x00
            KeyCode.D3,             KeyCode.D4,             KeyCode.D5,             KeyCode.D6,             //0x04
            KeyCode.D7,             KeyCode.D8,             KeyCode.D9,             KeyCode.D0,             //0x08
            KeyCode.Dash,           KeyCode.Equals,         KeyCode.Backspace,      KeyCode.Tab,            //0x0C
            KeyCode.Q,              KeyCode.W,              KeyCode.E,              KeyCode.R,              //0x10
            KeyCode.T,              KeyCode.Y,              KeyCode.U,              KeyCode.I,              //0x14
            KeyCode.O,              KeyCode.P,              KeyCode.OpenBracket,    KeyCode.CloseBracket,   //0x18
            KeyCode.Enter,          KeyCode.LCtrl,          KeyCode.A,              KeyCode.S,              //0x1C
            KeyCode.D,              KeyCode.F,              KeyCode.G,              KeyCode.H,              //0x20
            KeyCode.J,              KeyCode.K,              KeyCode.L,              KeyCode.SemiColon,      //0x24
            KeyCode.Singlequote,    KeyCode.Backtick,       KeyCode.LShift,         KeyCode.Backslash,      //0x28
            KeyCode.Z,              KeyCode.X,              KeyCode.C,              KeyCode.V,              //0x2C
            KeyCode.B,              KeyCode.N,              KeyCode.M,              KeyCode.Comma,          //0x30
            KeyCode.FullStop,       KeyCode.ForwardSlash,   KeyCode.RShift,         KeyCode.NumMultiply,    //0x34
            KeyCode.LAlt,           KeyCode.Space,          KeyCode.Caps,           KeyCode.F1,             //0x38
            KeyCode.F2,             KeyCode.F3,             KeyCode.F4,             KeyCode.F5,             //0x3C
            KeyCode.F6,             KeyCode.F7,             KeyCode.F8,             KeyCode.F9,             //0x40
            KeyCode.F10,            KeyCode.Num,            KeyCode.Scroll,         KeyCode.Num7,           //0x44
            KeyCode.Num8,           KeyCode.Num9,           KeyCode.NumSubtract,    KeyCode.Num4,           //0x48
            KeyCode.Num5,           KeyCode.Num6,           KeyCode.NumAdd,         KeyCode.Num1,           //0x4C
            KeyCode.Num2,           KeyCode.Num3,           KeyCode.Num0,           KeyCode.NumDecimal,     //0x50
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.F11,            //0x54
            KeyCode.F12,

        };

        private KeyCode[] extSet = new KeyCode[]
        {
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x00
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x04
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x08
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x0C
            KeyCode.PrevTrack,      KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x10
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x14
            KeyCode.None,           KeyCode.NextTrack,      KeyCode.None,           KeyCode.None,           //0x18
            KeyCode.NumEnter,       KeyCode.RCtrl,          KeyCode.None,           KeyCode.None,           //0x1C
            KeyCode.Mute,           KeyCode.Calculator,     KeyCode.Play,           KeyCode.None,           //0x20
            KeyCode.Stop,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x24
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x28
            KeyCode.None,           KeyCode.None,           KeyCode.VolumeDown,     KeyCode.None,           //0x2C
            KeyCode.VolumeUp,       KeyCode.None,           KeyCode.WWWHome,        KeyCode.None,           //0x30
            KeyCode.None,           KeyCode.NumDivide,      KeyCode.None,           KeyCode.None,           //0x34
            KeyCode.RAlt,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x38
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x3C
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x40
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.Home,           //0x44
            KeyCode.CursorUp,       KeyCode.PageUP,         KeyCode.NumSubtract,    KeyCode.CursorLeft,     //0x48
            KeyCode.None,           KeyCode.CursorRight,    KeyCode.NumAdd,         KeyCode.End,            //0x4C
            KeyCode.CursorDown,     KeyCode.PageDown,       KeyCode.Insert,         KeyCode.Delete,         //0x50
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x54
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.LGUI,           //0x58
            KeyCode.RGUI,           KeyCode.Apps,           KeyCode.None,           KeyCode.None,           //0x5C
            KeyCode.None,           KeyCode.None,           KeyCode.None,           KeyCode.None,           //0x60
            KeyCode.None,           KeyCode.WWWSearch,      KeyCode.WWWFavorites,   KeyCode.WWWRefresh,     //0x64
            KeyCode.WWWStop,        KeyCode.WWWForward,     KeyCode.WWWBack,        KeyCode.MyComputer,     //0x68
            KeyCode.Email,          KeyCode.MediaSelect,    KeyCode.None,           KeyCode.None,           //0x6C
        };

        public Keyboard()
        {
            /* Set Buffer size and init buffer */
            MaxBuffer = 100;
            Buffer = new Queue<Keys>(MaxBuffer);

            /* Set LEDs */
            //UpdateLEDs();
            xINT.RegisterHandler(HandleIRQ, 0x21);
        }

        private bool IsExtended = false;
        public void HandleIRQ()
        {
            uint xScanCode = Native.In8((ushort)Ports.PS2_Cmd);

            if (xScanCode == 0xE0)
            {
                IsExtended = true; //The ScanCode is extended
                return;
            }

            //Set break
            bool xReleased = (xScanCode & 0x80) == 0x80;
            if (xReleased)
            {
                xScanCode = (uint)(xScanCode ^ 0x80);
            }

            KeyCode xKey = KeyCode.None;

            if (IsExtended || (NumLock && (xScanCode >= 0x47 && xScanCode <= 0x53)))
                xKey = extSet[xScanCode];
            else
                xKey = Set[xScanCode];

            switch (xKey)
            {
                case KeyCode.None: //We will not check any code which we don't know
                    break;
                case KeyCode.LShift:
                case KeyCode.RShift:
                    Shift = !xReleased;
                    break;
                case KeyCode.LCtrl:
                    Ctrl = !xReleased;
                    break;
                case KeyCode.LAlt:
                    Alt = !xReleased;
                    break;
                default:
                    {
                        if (!xReleased)
                        {
                            bool UpdateLED = false;
                            switch (xKey)
                            {
                                case KeyCode.Caps:
                                    CapsLock = !CapsLock;
                                    UpdateLED = true;
                                    break;
                                case KeyCode.Num:
                                    NumLock = !NumLock;
                                    UpdateLED = true;
                                    break;
                                case KeyCode.Scroll:
                                    ScrollLock = !ScrollLock;
                                    UpdateLED = true;
                                    break;
                                default:
                                    {
                                        Buffer.Enqueue(new Keys(xKey, GetKeyChar(xKey)));
                                    }
                                    break;
                            }

                            if (UpdateLED)
                                UpdateLEDs();
                        }
                    }
                    break;
            }
            IsExtended = false;
        }

        private void UpdateLEDs()
        {
            byte Value = (byte)((byte)(CapsLock ? 0x4 : 0x0) |
                                (byte)(NumLock ? 0x2 : 0x0) |
                                (byte)(ScrollLock ? 0x1 : 0x0));
            misc.PS2_Cmd(Cmd.Key_LEDs, Value);
        }

        private char GetKeyChar(KeyCode aKey)
        {
            bool Case = (CapsLock && !Shift) ? true : ((!CapsLock && Shift) ? true : false);
            switch (aKey)
            {
                #region Alphabets
                case KeyCode.A: return Case ? 'A' : 'a';
                case KeyCode.B: return Case ? 'B' : 'b';
                case KeyCode.C: return Case ? 'C' : 'c';
                case KeyCode.D: return Case ? 'D' : 'd';
                case KeyCode.E: return Case ? 'E' : 'e';
                case KeyCode.F: return Case ? 'F' : 'f';
                case KeyCode.G: return Case ? 'G' : 'g';
                case KeyCode.H: return Case ? 'H' : 'h';
                case KeyCode.I: return Case ? 'I' : 'i';
                case KeyCode.J: return Case ? 'J' : 'j';
                case KeyCode.K: return Case ? 'K' : 'k';
                case KeyCode.L: return Case ? 'L' : 'l';
                case KeyCode.M: return Case ? 'M' : 'm';
                case KeyCode.N: return Case ? 'N' : 'n';
                case KeyCode.O: return Case ? 'O' : 'o';
                case KeyCode.P: return Case ? 'P' : 'p';
                case KeyCode.Q: return Case ? 'Q' : 'q';
                case KeyCode.R: return Case ? 'R' : 'r';
                case KeyCode.S: return Case ? 'S' : 's';
                case KeyCode.T: return Case ? 'T' : 't';
                case KeyCode.U: return Case ? 'U' : 'u';
                case KeyCode.V: return Case ? 'V' : 'v';
                case KeyCode.W: return Case ? 'W' : 'w';
                case KeyCode.X: return Case ? 'X' : 'x';
                case KeyCode.Y: return Case ? 'Y' : 'y';
                case KeyCode.Z: return Case ? 'Z' : 'z';
                #endregion
                case KeyCode.D1: return (Shift) ? '!' : '1';
                case KeyCode.D2: return (Shift) ? '@' : '2';
                case KeyCode.D3: return (Shift) ? '#' : '3';
                case KeyCode.D4: return (Shift) ? '$' : '4';
                case KeyCode.D5: return (Shift) ? '%' : '5';
                case KeyCode.D6: return (Shift) ? '^' : '6';
                case KeyCode.D7: return (Shift) ? '&' : '7';
                case KeyCode.D8: return (Shift) ? '*' : '8';
                case KeyCode.D9: return (Shift) ? '(' : '9';
                case KeyCode.D0: return (Shift) ? ')' : '0';

                case KeyCode.Num0: return '0';
                case KeyCode.Num1: return '1';
                case KeyCode.Num2: return '2';
                case KeyCode.Num3: return '3';
                case KeyCode.Num4: return '4';
                case KeyCode.Num5: return '5';
                case KeyCode.Num6: return '6';
                case KeyCode.Num7: return '7';
                case KeyCode.Num8: return '8';
                case KeyCode.Num9: return '9';
                case KeyCode.NumEnter: return '\n';
                case KeyCode.NumAdd: return '+';
                case KeyCode.NumSubtract: return '-';
                case KeyCode.NumDivide: return '/';
                case KeyCode.NumMultiply: return '*';
                case KeyCode.NumDecimal: return '.';

                case KeyCode.Enter: return '\n';
                case KeyCode.Dash: return (Shift) ? '_' : '-';
                case KeyCode.Equals: return (Shift) ? '+' : '=';
                case KeyCode.OpenBracket: return (Shift) ? '{' : '[';
                case KeyCode.CloseBracket: return (Shift) ? '}' : ']';
                case KeyCode.Backslash: return (Shift) ? '|' : '\\';
                case KeyCode.SemiColon: return (Shift) ? ':' : ';';
                case KeyCode.Singlequote: return (Shift) ? '"' : '\'';
                case KeyCode.Comma: return (Shift) ? '<' : ',';
                case KeyCode.FullStop: return (Shift) ? '>' : '.';
                case KeyCode.ForwardSlash: return (Shift) ? '?' : '/';
                case KeyCode.Backtick: return (Shift) ? '~' : '`';

                case KeyCode.Backspace: return '\b';
                case KeyCode.Space: return ' ';
                default: return '\0';
            }
        }


        public Keys ReadKey()
        {
            if (Buffer.Count == 0)
                return null;

            return Buffer.Dequeue();
        }

        public Keys Peekkey()
        {
            if (Buffer.Count == 0)
                return null;

            return Buffer.Peek();
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Kernel_alpha.Drivers.Input
{
    public class Keys
    {
        protected KeyCode aKeyCode;
        protected char aChar;
        public KeyCode Code
        {
            get { return aKeyCode; }
        }

        public char Char
        {
            get { return aChar; }
        }

        public Keys(KeyCode kc, char c)
        {
            aKeyCode = kc;
            aChar = c;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Atomix.Debugger
{
    public partial class MainFrm : Form
    {
        public MainFrm()
        {
            InitializeComponent();
        }
    }
}
﻿namespace Atomix.Debugger
{
    partial class MainFrm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.SuspendLayout();
            //
            // MainFrm
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(616, 387);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.Name = "MainFrm";
            this.Text = "Atomix Kernel Debugger";
            this.ResumeLayout(false);

        }

        #endregion
    }
}

﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Marshal extension functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;

using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.Lib
{
    internal unsafe static class Marshal
    {
        internal static sbyte* C_String(string aStr)
        {
            int len = aStr.Length;
            sbyte* cstr = (sbyte*)Heap.kmalloc((uint)len + 1);

            int i = 0;
            while (len-- != 0)
                cstr[i] = (sbyte)aStr[i++];
            return cstr;
        }

        internal static void Copy(string aStr, sbyte* aCstr, int aLen)
        {
            int i = 0;
            while (aLen-- != 0)
                aCstr[i] = (sbyte)aStr[i++];
            aCstr[i] = 0;
        }

        internal static void Copy(char* aDes, string aSrc, int aLen)
        {
            Memory.FastCopy((uint)aDes, aSrc.GetDataOffset(), (uint)(aLen * sizeof(char)));
            aDes[aLen] = '\0';
        }

        internal static string[] Split(this string aStr, char aDelimiter)
        {
            var aArray = aStr.ToCharArray();

            int len = aStr.Length, count = 1;

            for (int i = 0; i < len; i++)
            {
                if (aArray[i] == aDelimiter)
                    count++;
            }

            int last = 0, index = 0;

            var strs = new string[count];
            for (int i = 0; i < len; i++)
            {
                if (aArray[i] == aDelimiter)
                {
                    strs[index++] = new string(aArray, last, i - last);
                    last = i + 1;
                }
            }

            if (index != count)
                strs[index] = new string(aArray, last, len - last);

            return strs;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          File Contains various mscorlib plug belongs to Math class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomix.Kernel_H.plugs
{
    internal static class Math
    {
        [Plug("System_Int32_System_Math_Max_System_Int32__System_Int32_")]
        internal static int Max(int a, int b)
        {
            return a >= b ? a : b;
        }

        [Plug("System_UInt32_System_Math_Max_System_UInt32__System_UInt32_")]
        internal static uint Max(uint a, uint b)
        {
            return a >= b ? a : b;
        }

        [Plug("System_Int32_System_Math_Min_System_Int32__System_Int32_")]
        internal static int Min(int a, int b)
        {
            return a >= b ? b : a;
        }

        [Plug("System_UInt32_System_Math_Min_System_UInt32__System_UInt32_")]
        internal static uint Min(uint a, uint b)
        {
            return a >= b ? b : a;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using Kernel_alpha.Drivers.Buses.ATA;
using Kernel_alpha.Drivers;

namespace Kernel_alpha.Drivers.PartInfo
{
    public class MBR
    {
        protected IDE aDisk;
        protected List<Partition> aPartitions;

        public List<Partition> PartInfo
        { get { return aPartitions; } }

        public MBR(IDE mDisk)
        {
            this.aDisk = mDisk;
            this.aPartitions = new List<Partition>();

            var aMBR = new byte[512];
            mDisk.Read(0U, 1U, aMBR);
            ParseData(aMBR, 446);
            ParseData(aMBR, 462);
            ParseData(aMBR, 478);
            ParseData(aMBR, 494);
        }

        private void ParseData(byte[] aMBR, Int32 aLoc)
        {
            byte xSystemID = aMBR[aLoc + 4];
            if (xSystemID == 0x5 || xSystemID == 0xF || xSystemID == 0x85)
            {
                //Extended Partition Detected
                //DOS only knows about 05, Windows 95 introduced 0F, Linux introduced 85
                //Search for logical volumes
                //http://thestarman.pcministry.com/asm/mbr/PartTables2.htm
            }
            else if (xSystemID != 0)
            {
                UInt32 xSectorCount = BitConverter.ToUInt32(aMBR, aLoc + 12);
                UInt32 xStartSector = BitConverter.ToUInt32(aMBR, aLoc + 8);
                aPartitions.Add(new Partition(this.aDisk, xStartSector, xSectorCount));
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Kernel_alpha.Drivers.Video.Vmware
{
    public enum IOPortOffset : ushort
    {
        Index   = 0x0,
        Value   = 0x1,
        Bios    = 0x2,
        IRQ     = 0x8
    };

    public enum Versions : uint
    {
        SVGA_ID_0 = (UInt32)(0x900000UL << 8 | 0x0),
        SVGA_ID_1 = (UInt32)(0x900000UL << 8 | 0x1),
        SVGA_ID_2 = (UInt32)(0x900000UL << 8 | 0x2)
    };

    public enum Registers : uint
    {
        SVGA_REG_ID = 0,
        SVGA_REG_ENABLE = 1,
        SVGA_REG_WIDTH = 2,
        SVGA_REG_HEIGHT = 3,
        SVGA_REG_MAX_WIDTH = 4,
        SVGA_REG_MAX_HEIGHT = 5,
        SVGA_REG_DEPTH = 6,
        SVGA_REG_BITS_PER_PIXEL = 7,       /* Current bpp in the guest */
        SVGA_REG_PSEUDOCOLOR = 8,
        SVGA_REG_RED_MASK = 9,
        SVGA_REG_GREEN_MASK = 10,
        SVGA_REG_BLUE_MASK = 11,
        SVGA_REG_BYTES_PER_LINE = 12,
        SVGA_REG_FB_START = 13,            /* (Deprecated) */
        SVGA_REG_FB_OFFSET = 14,
        SVGA_REG_VRAM_SIZE = 15,
        SVGA_REG_FB_SIZE = 16,

        /* ID 0 implementation only had the above registers, then the palette */

        SVGA_REG_CAPABILITIES = 17,
        SVGA_REG_MEM_START = 18,           /* (Deprecated) */
        SVGA_REG_MEM_SIZE = 19,
        SVGA_REG_CONFIG_DONE = 20,         /* Set when memory area configured */
        SVGA_REG_SYNC = 21,                /* See "FIFO Synchronization Registers" */
        SVGA_REG_BUSY = 22,                /* See "FIFO Synchronization Registers" */
        SVGA_REG_GUEST_ID = 23,            /* Set guest OS identifier */
        SVGA_REG_CURSOR_ID = 24,           /* (Deprecated) */
        SVGA_REG_CURSOR_X = 25,            /* (Deprecated) */
        SVGA_REG_CURSOR_Y = 26,            /* (Deprecated) */
        SVGA_REG_CURSOR_ON = 27,           /* (Deprecated) */
        SVGA_REG_HOST_BITS_PER_PIXEL = 28, /* (Deprecated) */
        SVGA_REG_SCRATCH_SIZE = 29,        /* Number of scratch registers */
        SVGA_REG_MEM_REGS = 30,            /* Number of FIFO registers */
        SVGA_REG_NUM_DISPLAYS = 31,        /* (Deprecated) */
        SVGA_REG_PITCHLOCK = 32,           /* Fixed pitch for all modes */
        SVGA_REG_IRQMASK = 33,             /* Interrupt mask */

        /* Legacy multi-monitor support */
        SVGA_REG_NUM_GUEST_DISPLAYS = 34,/* Number of guest displays in X/Y direction */
        SVGA_REG_DISPLAY_ID = 35,        /* Display ID for the following display attributes */
        SVGA_REG_DISPLAY_IS_PRIMARY = 36,/* Whether this is a primary display */
        SVGA_REG_DISPLAY_POSITION_X = 37,/* The display position x */
        SVGA_REG_DISPLAY_POSITION_Y = 38,/* The display position y */
        SVGA_REG_DISPLAY_WIDTH = 39,     /* The display's width */
        SVGA_REG_DISPLAY_HEIGHT = 40,    /* The display's height */

        /* See "Guest memory regions" below. */
        SVGA_REG_GMR_ID = 41,
        SVGA_REG_GMR_DESCRIPTOR = 42,
        SVGA_REG_GMR_MAX_IDS = 43,
        SVGA_REG_GMR_MAX_DESCRIPTOR_LENGTH = 44,

        SVGA_REG_TRACES = 45,            /* Enable trace-based updates even when FIFO is on */
        SVGA_REG_TOP = 46,               /* Must be 1 more than the last register */

        SVGA_PALETTE_BASE = 1024,        /* Base of SVGA color map */
        SVGA_FIFO_NUM_REGS = 293
    };

    public enum FIFO : ushort
    {
        SVGA_FIFO_MIN = 0,
        SVGA_FIFO_MAX = 4,
        SVGA_FIFO_NEXT_CMD = 8,
        SVGA_FIFO_STOP = 12,
        SVGA_FIFO_CAPABILITIES = 4,
        SVGA_FIFO_GUEST_3D_HWVERSION = 0,
        Update = 1,
    };

    public static class misc
    {
        public const ushort PCI_VENDOR_ID_VMWARE = 0x15AD;
        public const ushort PCI_DEVICE_ID_VMWARE_SVGA2 = 0x0405;
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Kernel_alpha.Drivers.Video.VGA
{
    public class modes
    {
        public readonly static byte[] g_320x200x256 = new byte[]
        {
            /* MISC */
	        0x63,
            /* SEQ */
	        0x03, 0x01, 0x0F, 0x00, 0x0E,
            /* CRTC */
	        0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F,
	        0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	        0x9C, 0x0E, 0x8F, 0x28,	0x40, 0x96, 0xB9, 0xA3,
	        0xFF,
            /* GC */
	        0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
	        0xFF,
            /* AC */
	        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	        0x41, 0x00, 0x0F, 0x00,	0x00
        };

        public readonly static byte[] g_640x480x16 = new byte[]
        {
            /* MISC */
			0xE3,
			/* SEQ */
			0x03, 0x01, 0x08, 0x00, 0x06,
			/* CRTC */
			0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E,
			0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEA, 0x0C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
			0xFF,
			/* GC */
			0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x05, 0x0F,
			0xFF,
			/* AC */
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
			0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
			0x01, 0x00, 0x0F, 0x00, 0x00
        };

        public readonly static byte[] g_720x480x256 = new byte[]
        {
            /* MISC
             * 1110 0111b
             * I/OAS    --> 1
             * RAM En.  --> 1
             * Clock    --> 01 (28Mhz)
             * O/E Page --> High page
             * HSYNCP   --> Negative Horizontal Sync Polarity
             * VSYNCP   --> Negative Vertical Sync Polarity
             */
	        0xE7,
            /* SEQ */
	        0x03, 0x01, 0x08, 0x00, 0x06,
            /* CRTC */
	        0x6B, 0x59, 0x5A, 0x82, 0x60, 0x8D, 0x0B, 0x3E,
	        0x00, 0x40, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00,
	        0xEA, 0x0C, 0xDF, 0x2D, 0x08, 0xE8, 0x05, 0xE3,
	        0xFF,
            /* GC */
	        0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x05, 0x0F,
	        0xFF,
            /* AC */
	        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	        0x01, 0x00, 0x0F, 0x00, 0x00
        };
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Apply a mutual exclusive lock to thread also implements `lock`keyword
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Lib;

namespace Atomix.Kernel_H.Core
{
    internal static class Monitor
    {
        internal static void AcquireLock(ref uint aLock)
        {
            while (Native.AtomicExchange(ref aLock, 1) != 0)
                Task.Switch();
        }

        internal static void ReleaseLock(ref uint aLock)
        {
            aLock = 0;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          PS2 mouse driver
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Kernel_H.IO;
using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Arch.x86;

namespace Atomix.Kernel_H.Drivers.Input
{
    internal static class Mouse
    {
        const byte MOUSE_PORT = 0x60;
        const byte MOUSE_STATUS = 0x64;
        const byte MOUSE_ABIT = 0x02;
        const byte MOUSE_BBIT = 0x01;
        const byte MOUSE_WRITE = 0xD4;
        const byte MOUSE_F_BIT = 0x20;
        const byte MOUSE_V_BIT = 0x08;

        const byte LEFT_CLICK = 0x1;
        const byte RIGHT_CLICK = 0x2;
        const byte MIDDLE_CLICK = 0x4;

        public const byte MOUSE_MAGIC = 0xAC;

        internal static Pipe MousePipe;

        internal static void Setup()
        {
            Debug.Write("PS/2 Mouse Controller Setup\n");
            MouseCycle = 0;
            MouseData = new byte[4];
            MouseData[0] = MOUSE_MAGIC;
            MousePipe = new Pipe(4, 1024);
            IDT.RegisterInterrupt(HandleIRQ, 0x2C);

            Wait(true);
            PortIO.Out8(MOUSE_STATUS, 0xA8);
            Wait(true);
            PortIO.Out8(MOUSE_STATUS, 0x20);
            Wait(false);

            byte status = (byte)(PortIO.In8(MOUSE_PORT) | 2);
            Wait(true);
            PortIO.Out8(MOUSE_STATUS, 0x60);
            Wait(true);
            PortIO.Out8(MOUSE_PORT, status);
            Write(0xF6);
            Read();
            Write(0xF4);
            Read();

            Debug.Write("Mouse Done\n");
        }

        static uint MouseCycle;
        static byte[] MouseData;

        private static void HandleIRQ(ref IRQContext context)
        {
            int status = PortIO.In8(MOUSE_STATUS);

            while((status & MOUSE_BBIT) != 0)
            {
                if ((status & MOUSE_F_BIT) != 0)
                {
                    byte input = PortIO.In8(MOUSE_PORT);
                    switch (MouseCycle)
                    {
                        case 0:
                            {
                                MouseData[1] = input;
                                if ((input & MOUSE_V_BIT) != 0)
                                    MouseCycle = 1;
                            }
                            break;
                        case 1:
                            {
                                MouseData[2] = input;
                                MouseCycle = 2;
                            }
                            break;
                        case 2:
                            {
                                MouseData[3] = input;
                                MouseCycle = 0;
                                /*
                                 * http://wiki.osdev.org/Mouse_Input
                                 * The top two bits of the first byte (values 0x80 and 0x40) supposedly show Y and X overflows,
                                 * respectively. They are not useful. If they are set, you should probably just discard the entire packet.
                                 */
                                if ((MouseData[1] & 0xC0) != 0) // X-Y (0x40 & 0x80) Overflow
                                    break;

                                // Send packet to kernel:= { MAGIC, btn, X-Pos, Y-Pos }
                                // Send package and seek the read pointer if necessary
                                MousePipe.Write(MouseData, false);
                            }
                            break;
                    }
                }
                status = PortIO.In8(MOUSE_STATUS);
            }
        }

        private static void Write(byte data)
        {
            Wait(true);
            PortIO.Out8(MOUSE_STATUS, MOUSE_WRITE);
            Wait(true);
            PortIO.Out8(MOUSE_PORT, data);
        }

        private static byte Read()
        {
            Wait(false);
            return PortIO.In8(MOUSE_PORT);
        }

        private static void Wait(bool type)
        {
            int timeout = 100000;
            if (!type)
            {
                while (--timeout > 0)
                {
                    if ((PortIO.In8(MOUSE_STATUS) & MOUSE_BBIT) != 0)
                        return;
                }
                Debug.Write("[mouse]: TIMEOUT\n");
                return;
            }
            else
            {
                while (--timeout > 0)
                {
                    if ((PortIO.In8(MOUSE_STATUS) & MOUSE_ABIT) == 0)
                        return;
                }
                Debug.Write("[mouse]: TIMEOUT\n");
                return;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Multiboot Information Parsing
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Kernel_H.Core;

using System.Runtime.InteropServices;

namespace Atomix.Kernel_H.Arch.x86
{
    /// <summary>
    /// For now it is fine, http://git.savannah.gnu.org/cgit/grub.git/tree/doc/multiboot.h?h=multiboot
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 88)]
    internal unsafe struct Multiboot_Info
    {
        /* Multiboot info version number */
        [FieldOffset(0)]
        public uint Flags;

        /* Available memory from BIOS */
        [FieldOffset(4)]
        public uint mem_lower;
        [FieldOffset(8)]
        public uint mem_upper;

        /* "root" partition */
        [FieldOffset(12)]
        public uint boot_device;

        /* Kernel command line */
        [FieldOffset(16)]
        public uint cmdline;

        /* Boot-Module list */
        [FieldOffset(20)]
        public uint mods_count;
        [FieldOffset(24)]
        public uint mods_addr;

        /* if bits 4 or 5 in flags are set */
        [FieldOffset(28)]
        public fixed uint syms[4];
        /* if bit 6 in flags is set */
        [FieldOffset(44)]
        public uint memMapLength;
        /* if bit 6 in flags is set */
        [FieldOffset(48)]
        public uint memMapAddress;
        /* if bit 7 in flags is set */
        [FieldOffset(52)]
        public uint drivesLength;
        /* if bit 7 in flags is set */
        [FieldOffset(56)]
        public uint drivesAddress;
        /* if bit 8 in flags is set */
        [FieldOffset(60)]
        public uint configTable;

        // Bootloader name =D

        /* if bit 9 in flags is set */
        [FieldOffset(68)]
        public uint apmTable;
        /* if bit 10 in flags is set */
        [FieldOffset(72)]
        public uint vbeControlInfo;
        /* if bit 11 in flags is set */
        [FieldOffset(76)]
        public uint vbeModeInfo;
        /* all vbe_* set if bit 12 in flags are set */
        [FieldOffset(80)]
        public ushort vbeMode;
        [FieldOffset(82)]
        public ushort vbeInterfaceSeg;
        [FieldOffset(84)]
        public ushort vbeInterfaceOff;
        [FieldOffset(86)]
        public ushort vbeInterfaceLength;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public unsafe struct MemoryMap_Info
    {
        [FieldOffset(0)]
        public uint Size;
        [FieldOffset(4)]
        public uint BaseAddress_Low;
        [FieldOffset(8)]
        public uint BaseAddress_High;
        [FieldOffset(12)]
        public uint Length_Low;
        [FieldOffset(16)]
        public uint Length_High;
        [FieldOffset(20)]
        public uint Type;
    }

    internal static unsafe class Multiboot
    {
        const uint MULTIBOOT_MEMORY_AVAILABLE = 1;
        const uint MULTIBOOT_MEMORY_RESERVED = 2;

        static Multiboot_Info* Mb_Info;
        static bool aIsValid;
        static uint Initrd;
        static uint InitrdSize;

        internal static bool IsValid
        { get { return aIsValid; } }

        internal static uint VBE_Control_Info
        {
            get { return Mb_Info->vbeControlInfo; }
        }

        internal static uint VBE_Mode_Info
        {
            get { return Mb_Info->vbeModeInfo; }
        }

        internal static uint RAM
        {
            get { return (Mb_Info->mem_upper + Mb_Info->mem_lower) * 1024; }
        }

        internal static uint RamDisk
        {
            get { return Initrd; }
        }

        internal static uint RamDiskSize
        {
            get { return InitrdSize; }
        }

        internal static uint RamDiskEnd
        {
            get { return Initrd + InitrdSize; }
        }

        internal static unsafe void Setup(uint xSig, uint Address)
        {
            if (xSig != 0x2BADB002)
            {
                aIsValid = false;
                Debug.Write("Invalid Multiboot Signature\n");
                return;
            }
            aIsValid = true;
            Address += 0xC0000000;// We are in higher half =D
            Mb_Info = (Multiboot_Info*)Address;
            Debug.Write("Multiboot Found!!\n");
            Debug.Write("       Address       ::%d\n", Address);
            Debug.Write("       VBEModeInfo   ::%d\n", Mb_Info->vbeModeInfo);
            Debug.Write("       VBEControlInfo::%d\n", Mb_Info->vbeControlInfo);

            Initrd = 0;
            InitrdSize = 0;
            var modules = (UInt32*)(Mb_Info->mods_addr + 0xC0000000);
            Debug.Write("       Modules Count:%d\n", Mb_Info->mods_count);
            if (Mb_Info->mods_count > 0)
            {
                Initrd = modules[0];
                InitrdSize = modules[1] - Initrd;
                Initrd += 0xC0000000;
                Debug.Write("       RamDisk:%d\n", Initrd);
                Debug.Write("       RamDisk-Size:%d\n", InitrdSize);
            }
            if (Mb_Info->mods_count == 0)
                Debug.Write("       No Initial RAM Disk Found!!\n");
            Debug.Write("       Flags:%d\n", Mb_Info->Flags);
        }

        internal static void DetectMemory()
        {
            if ((Mb_Info->Flags & (0x1<<6)) != 0)
            {
                Debug.Write("Parsing Memory Map\n");
                MemoryMap_Info* mmap = (MemoryMap_Info*)(Mb_Info->memMapAddress + 0xC0000000);

                uint EndAddress = Mb_Info->memMapAddress + 0xC0000000 + Mb_Info->memMapLength;
                while((uint)mmap < EndAddress)
                {
                    if (mmap->Type == MULTIBOOT_MEMORY_RESERVED)
                    {
                        // Let's assume High part is 0 always, because we are running on 32bit CPU
                        for (uint index = 0; index < mmap->Length_Low; index += 0x1000)// Page size
                        {
                            uint Address = mmap->BaseAddress_Low + index;
                            Debug.Write("Marking Address: %d\n", Address);
                            Paging.SetFrame((Address & 0xFFFFF000) / 0x1000);
                        }
                    }
                    mmap = (MemoryMap_Info*)((uint)mmap + (uint)sizeof(MemoryMap_Info) + mmap->Size);
                }
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;
using Atomix.Assembler;
using Atomix.Assembler.x86;
using Kernel_alpha.x86;
using Kernel_alpha.x86.Intrinsic;
using Core = Atomix.Assembler.AssemblyHelper;
using System.Runtime.InteropServices;

namespace Kernel_alpha
{
    public static class Multitasking
    {
        private static Task[] mTasks = new Task[255];
        private static int mCurrentTask = -1;
        private static int Counter = 0;

        private static Queue<int> RunningTasks = new Queue<int>();

        public static Task[] Tasks
        {
            get { return mTasks; }
        }

        public static int CurrentTask
        {
            get { return mCurrentTask; }
        }

        public static void Init()
        {
            uint divisor = (1193180 * 10) / 1000;               /* Calculate our divisor */ //10ms
            Native.Out8(0x43, 0x36);                            /* Set our command byte 0x36 */
            Native.Out8(0x40, (byte)(divisor & 0xFF));          /* Set low byte of divisor */
            Native.Out8(0x40, (byte)(divisor >> 8));            /* Set high byte of divisor */

            mCurrentTask = 0;
            PIC.ClearMask(0);
        }

        [Plug("__Task_Switcher__")]
        public static uint TaskSwitcher(uint context)
        {
            // save the old context into current task
            mTasks[mCurrentTask].Stack = context;

            //Update the sleeping tasks
            UpdateHaltedTasks();

            //Get Task to Run
            mCurrentTask = GetTaskToRun();

            // Return new task's context.
            return mTasks[mCurrentTask].Stack;
        }

        public static int GetTaskToRun()
        {
            var xState = mTasks[mCurrentTask].state;
            switch ((State)xState)
            {
                case State.Alive:
                    RunningTasks.Enqueue(mCurrentTask);
                    break;
                case State.Dead:
                case State.None:
                    break;
            }

            return RunningTasks.Dequeue();
        }

        public static void UpdateHaltedTasks()
        {
            int xState;

            /* Sleeping Tasks */
            for (int i = 0; i < Counter; i++)
            {
                xState = mTasks[i].state;
                if (xState > 0)
                {
                    mTasks[i].state--;
                    if (xState == 1)
                        RunningTasks.Enqueue(i);
                }
            }
        }

        public static unsafe Thread CreateTask(uint xLoc, bool isRunning)
        {
            Native.ClearInterrupt();

            uint* stack;

            Task* task = (Task*)(Heap.AllocateMem((uint)sizeof(Task)));
            task->Stack = Heap.AllocateMem(0x1000) + 0x1000;//Put pointer at end

            stack = (uint*)task->Stack;

            // Expand down stack
            // processor data
            *--stack = 0x202;       // EFLAGS
            *--stack = 0x08;        // CS
            *--stack = xLoc;        // EIP

            // pusha
            *--stack = 0;           // EDI
            *--stack = 0;           // ESI
            *--stack = 0;           // EBP
            *--stack = 0;           // ESP
            *--stack = 0;           // EBX
            *--stack = 0;           // EDX
            *--stack = 0;           // ECX
            *--stack = 0;           // EAX

            // data segments
            *--stack = 0x10;        // DS
            *--stack = 0x10;        // ES
            *--stack = 0x10;        // FS
            *--stack = 0x10;        // GS

            task->Stack = (uint)stack;
            task->Address = (uint*)xLoc;
            task->state = (byte)(isRunning ? State.Alive : State.None);

            mTasks[Counter++] = *task;

            if (isRunning)
                RunningTasks.Enqueue(Counter - 1);

            Native.SetInterrupt();
            return new Thread(Counter - 1);
        }

        [Assembly, Plug("__ISR_Handler_20")]
        private static void SetupIRQ0()
        {
            //Restore Registers
            Core.AssemblerCode.Add(new Pushad());

            //Restore Data Selectors
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.DS, Size = 16 });
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ES, Size = 16 });
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.FS, Size = 16 });
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.GS, Size = 16 });

            //Reset DataSelectors
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.AX, SourceRef = "0x10", Size = 16 });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.DS, SourceReg = Registers.AX, Size = 16 });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ES, SourceReg = Registers.AX, Size = 16 });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.FS, SourceReg = Registers.AX, Size = 16 });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.GS, SourceReg = Registers.AX, Size = 16 });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.SS, SourceReg = Registers.AX, Size = 16 });

            //Push ESP
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.ESP });
            Core.AssemblerCode.Add(new Call("__Task_Switcher__"));

            //Get New task ESP
            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ESP });

            //Tell CPU that we have recieved IRQ
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.AL, SourceRef = "0x20", Size = 8 });
            Core.AssemblerCode.Add(new Out { DestinationRef = "0x20", SourceReg = Registers.AL });

            //Load New task's data selector
            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.GS, Size = 16 });
            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.FS, Size = 16 });
            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ES, Size = 16 });
            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.DS, Size = 16 });

            //Load Registers
            Core.AssemblerCode.Add(new Popad());
            Core.AssemblerCode.Add(new Iret());
        }
    }
}
﻿using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    internal static class NativeException
    {
        [Plug("System_Void_System_ThrowHelper_ThrowArgumentOutOfRangeException_System_ExceptionArgument__System_ExceptionResource_")]
        internal static void ThrowHelper(int Argument, int Resource)
        {
            return;
        }

        [Plug("System_Void_System_ThrowHelper_ThrowArgumentOutOfRangeException__")]
        internal static void ThrowArgumentOutOfRangeException()
        {
            return;
        }

        [Plug("System_Void_System_ThrowHelper_ThrowInvalidOperationException_System_ExceptionResource_")]
        internal static void ThrowInvalidOperationException(int ExceptionResource)
        {
            return;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Atomix.mscorlib
{
    public static class Number
    {
        public const string xDigits = "0123456789";
        public static string ToString8Bit(uint aNum, bool IsSigned)
        {
            if (aNum == 0)
                return "0";

            char[] xResult = new char[3];//0-255

            int c = 2;
            uint v = aNum;
            while (v > 0)
            {
                int r = (int)(v % 10);
                v /= 10;

                xResult[c] = xDigits[r];
                c--;
            }

            return new string(xResult);
        }

        public static string ToString16Bit(uint aNumber, bool IsSigned)
        {
            return string.Empty;
        }

        public static string ToString32Bit(uint aNumber, bool IsSigned)
        {
            uint xValue = aNumber;

            if (xValue == 0)
                return "0";

            char[] xResultChars = new char[11];
            int xCurrentPos = 10;
            
            while (xValue > 0)
            {
                byte xPos = (byte)(xValue % 10);
                xValue /= 10;
                xResultChars[xCurrentPos] = xDigits[xPos];
                xCurrentPos -= 1;
            }
            
            if (IsSigned)
            {
                xResultChars[xCurrentPos] = '-';
                xCurrentPos -= 1;
            }
            
            return new string(xResultChars, xCurrentPos + 1, 10 - xCurrentPos);
        }

        public static string ToString64Bit(ulong aNumber, bool IsSigned)
        {
            if (aNumber == 0)
                return "0";
            char[] xResultChars = new char[21];
            int xCurrentPos = 20;
            while (aNumber > 0)
            {
                byte xPos = (byte)(aNumber % 10);
                aNumber /= 10;
                xResultChars[xCurrentPos] = xDigits[xPos];
                xCurrentPos -= 1;
            }
            if (IsSigned)
            {
                xResultChars[xCurrentPos] = '-';
                xCurrentPos -= 1;
            }
            return new string(xResultChars, xCurrentPos + 1, 20 - xCurrentPos);
        }

        public static string ToStringHex(byte aByte)
        {
            const string xHex = "0123456789ABCDEF";
            char[] xResult = new char[2];
            xResult[0] = xHex[(int)((aByte >> 4) & 0xF)];
            xResult[1] = xHex[(int)(aByte & 0xF)];

            return new String(xResult);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Nunerics Helper Functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

namespace Atomix.Kernel_H.Lib
{
    class Numerics
    {
        internal static uint ParseHex(string str)
        {
            uint ans = 0;
            int temp, index = 0, len = str.Length;
            while(index < len && (temp = str[index++]) >= '0')
            {
                ans <<= 0x4;
                if (temp <= '9')
                    ans += (uint)(temp - '0');
                else if (temp <= 'F')
                    ans += (uint)(temp - 'A') + 10;
                else
                    ans += (uint)(temp - 'a') + 10;
            }
            return ans;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class Object
    {
        [Plug("System_Void__System_Object__ctor__")]
        public static void Cctor(object obj)
        {
            return;
        }
        [Plug("System_Type_System_Object_GetType__")]
        public static Type GetType(object obj)
        {
            return null;
        }
    }
}
﻿using System;

namespace Atomix.Kernel_H.Lib.Cairo
{
    /* typedef enum _cairo_operator {
     *      CAIRO_OPERATOR_CLEAR,
     *      CAIRO_OPERATOR_SOURCE,
     *      CAIRO_OPERATOR_OVER,
     *      CAIRO_OPERATOR_IN,
     *      CAIRO_OPERATOR_OUT,
     *      CAIRO_OPERATOR_ATOP,
     *      CAIRO_OPERATOR_DEST,
     *      CAIRO_OPERATOR_DEST_OVER,
     *      CAIRO_OPERATOR_DEST_IN,
     *      CAIRO_OPERATOR_DEST_OUT,
     *      CAIRO_OPERATOR_DEST_ATOP,
     *      CAIRO_OPERATOR_XOR,
     *      CAIRO_OPERATOR_ADD,
     *      CAIRO_OPERATOR_SATURATE,
     *      CAIRO_OPERATOR_MULTIPLY,
     *      CAIRO_OPERATOR_SCREEN,
     *      CAIRO_OPERATOR_OVERLAY,
     *      CAIRO_OPERATOR_DARKEN,
     *      CAIRO_OPERATOR_LIGHTEN,
     *      CAIRO_OPERATOR_COLOR_DODGE,
     *      CAIRO_OPERATOR_COLOR_BURN,
     *      CAIRO_OPERATOR_HARD_LIGHT,
     *      CAIRO_OPERATOR_SOFT_LIGHT,
     *      CAIRO_OPERATOR_DIFFERENCE,
     *      CAIRO_OPERATOR_EXCLUSION,
     *      CAIRO_OPERATOR_HSL_HUE,
     *      CAIRO_OPERATOR_HSL_SATURATION,
     *      CAIRO_OPERATOR_HSL_COLOR,
     *      CAIRO_OPERATOR_HSL_LUMINOSITY,
     * } cairo_operator_t;
     */
    internal enum Operator : int
    {
        Clear = 0,
        Source = 1,
        Over = 2,
        In = 3,
        Out = 4,
        Atop = 5,
        Dest = 6,
        DestOver = 7,
        DestIn = 8,
        DestOut = 9,
        DestAtop = 10,
        Xor = 11,
        Add = 12,
        Saturate = 13,
        Multiply = 14,
        Screen = 15,
        Overlay = 16,
        Darken = 17,
        Lighten = 18,
        ColorDodge = 19,
        ColorBurn = 20,
        HardLight = 21,
        SoftLight = 22,
        Difference = 23,
        Exclusion = 24,
        HslHue = 25,
        HslSaturation = 26,
        HslColor = 27,
        HslLuminosity = 28
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Paging Setup
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/


using System;

using Atomix.Kernel_H.Core;

using Atomixilc.Lib;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomix.Kernel_H.Arch.x86
{
    internal static unsafe class Paging
    {
        public static uint* KernelDirectory;
        public static uint* CurrentDirectory;
        private static uint[] Frames;

        internal const uint PageSize = 0x1000;

        internal static void Setup(uint aKernelDirectory)
        {
            KernelDirectory = (uint*)aKernelDirectory;
            Frames = new uint[Multiboot.RAM / 0x20000];

            // Tell Frame Allocator that we have already used first 4MB
            uint i = 0;
            while (i < 32)
                Frames[i++] = 0xFFFFFFFF;

            //Detect memory that can we use and mark rest as already used
            Multiboot.DetectMemory();

            /*
             * First 4MB of BIOS is mapped
             * [0x0 - 0x400000) -> [0xc0000000 - 0xc0400000)
             * So, we have to first map rest of kernel code + Heap
             */
            uint phy = 0x400000, virt = 0xc0400000, end = Multiboot.RamDiskEnd;
            if (end == 0)
                end = Native.EndOfKernel();

            while (virt < end)
            {
                AllocateFrame(GetPage(KernelDirectory, virt, true), phy, false);
                virt += 0x1000;
                phy += 0x1000;
            }

            // Lets Map the new Heap; Just to the end of kernel
            uint HeapSize = 0x2000000, HeapStart = virt;//32MB
            end = virt + HeapSize;

            while (virt < end)
            {
                AllocateFrame(GetPage(KernelDirectory, virt, true), 0, true);
                virt += 0x1000;
            }

            // Setup our New Heap
            Heap.Setup(HeapStart, end);
            CurrentDirectory = KernelDirectory;
            Debug.Write("@Paging:: Directory: %d\n", (uint)CurrentDirectory);
        }

        internal static uint AllocateMainBuffer(uint phybase)
        {
            // 4MB * 1 => 4MB
            uint VirtLocation = 0xE0000000, VirtEnd = VirtLocation + 0x400000;
            while(VirtLocation < VirtEnd)
            {
                AllocateFrame(GetPage(KernelDirectory, VirtLocation, true), phybase, false);
                phybase += 0x1000;
                VirtLocation += 0x1000;
            }

            return 0xE0000000;
        }

        internal static uint AllocateSecondayBuffer()
        {
            // 4MB * 1 => 4MB
            uint VirtLocation = 0xE0400000, VirtEnd = VirtLocation + 0x400000;
            while (VirtLocation < VirtEnd)
            {
                AllocateFrame(GetPage(KernelDirectory, VirtLocation, true), 0, true);
                VirtLocation += 0x1000;
            }

            return 0xE0400000;
        }

        internal static void AllocateFrame(uint Page, uint PhyPage, bool Allocate, uint flags = 0x3)//Present, ReadWrite, Supervisor
        {
            Page += 0xC0000000;
            var Add = *((uint*)Page);
            if (Add != 0)
                return; // We don't want to overwrite anything
            else
            {
                if (Allocate)
                    PhyPage = FirstFreeFrame() * 0x1000;
                *((uint*)Page) = PhyPage | flags;
                SetFrame(PhyPage / 0x1000);
            }
        }

        internal static uint FirstFreeFrame()
        {
            int Length = Frames.Length;
            var MemoryFrames = Frames;
            for (int i = 0; i < Length; i++)
            {
                if (MemoryFrames[i] != 0xFFFFFFFF)
                {
                    for (int j = 0; j < 32; j++)
                    {
                        uint index = (uint)(1 << j);
                        if ((MemoryFrames[i] & index) == 0)
                            return (uint)((i << 5) + j);
                    }
                }
            }
            Debug.Write("No Free Frame! :(");
            while (true) ;
        }

        internal static uint GetPage(uint* Directory, uint VirtAddress, bool Make, uint flags = 0x3)//Present, ReadWrite, Supervisor
        {
            VirtAddress /= 0x1000; // Align it to page
            int index = (int)(VirtAddress / 1024);

            if (Directory[index] != 0)
            {
                return (Directory[index] & 0xFFFFF000) + (VirtAddress % 1024) * 4;
            }
            else if (Make)
            {
                var tmp = Heap.kmalloc(0x1000, true);
                tmp -= 0xC0000000;
                Directory[index] = tmp | flags;
                return tmp + ((VirtAddress % 1024) * 4);
            }
            return 0;
        }

        internal static uint* CloneKernelDirectory()
        {
            uint* NewDirectory = (uint*)(Heap.kmalloc(0x1000, true));
            for (uint Table = 768; Table < 1024; Table++)
            {
                NewDirectory[Table] = KernelDirectory[Table];
            }
            return NewDirectory;
        }

        internal static void FreeDirectory(uint* Directory)
        {
            for (uint Table = 0; Table < 768; Table++)
            {
                ClearFrame(Directory[Table] / 0x1000);
            }
            ClearFrame((uint)Directory / 0x1000);
        }

        internal static void SetFrame(uint page)
        {
            Frames[(page >> 5)] |= (uint)(0x1 << ((int)page & 31));
        }

        internal static void ClearFrame(uint page)
        {
            Frames[(page >> 5)] &= ~(uint)(0x1 << ((int)page & 31));
        }

        [Assembly(true)]
        internal static void RefreshTLB()
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.CR3 };
            new Mov { DestinationReg = Register.CR3, SourceReg = Register.EAX };
        }

        [Assembly(true)]
        internal static void InvalidatePageAt(uint xAddress)
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            new Literal ("invlpg [EAX]");
        }

        [Assembly(true)]
        public static void SwitchDirectory(uint Directory)
        {
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            new Mov { DestinationRef = "static_Field__System_UInt32__Atomix_Kernel_H_Arch_x86_Paging_CurrentDirectory", DestinationIndirect = true, SourceReg = Register.EAX };
            new Mov { DestinationReg = Register.CR3, SourceReg = Register.EAX };
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Pair Generic Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.Lib
{
    internal class Pair<A, B>
    {
        A aItem;
        B bItem;

        internal Pair(A item1, B item2)
        {
            aItem = item1;
            bItem = item2;
        }

        internal A First
        { get { return aItem; } }

        internal B Second
        { get { return bItem; } }
    }
}
﻿using System;
using System.Collections.Generic;
using Kernel_alpha.Drivers.Buses.ATA;

namespace Kernel_alpha.Drivers
{
    public class Partition : BlockDevice
    {
        protected IDE aDisk;
        protected UInt32 aStartSector;
        protected UInt32 aSectorCount;

        public Partition(IDE Disk, UInt32 StartSector, UInt32 SectorCount)
        {
            this.aDisk = Disk;
            this.aStartSector = StartSector;
            this.aSectorCount = SectorCount;
        }

        public override void Read(UInt32 BlockNo, UInt32 BlockCount, byte[] aData)
        {
            #warning Add Overflow exception
            aDisk.Read(BlockNo + aStartSector, BlockCount, aData);
        }

        public override void Write(UInt32 BlockNo, UInt32 BlockCount, byte[] aData)
        {
            #warning Add Overflow exception
            aDisk.Write(BlockNo + aStartSector, BlockCount, aData);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Programmable Interrupt Controller 8086 Chip Handler, basically remapping IRQs
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.Arch.x86
{
    internal static class PIC
    {
        const byte PIC1_Command = 0x20;
        const byte PIC2_Command = 0xA0;

        const byte PIC1_Data = 0x21;
        const byte PIC2_Data = 0xA1;

        const byte ICW1_ICW4 = 0x01;
        const byte ICW1_SingleCascadeMode = 0x02;
        const byte ICW1_Interval4 = 0x04;
        const byte ICW1_LevelTriggeredEdgeMode = 0x08;
        const byte ICW1_Initialization = 0x10;
        const byte ICW2_MasterOffset = 0x20;
        const byte ICW2_SlaveOffset = 0x28;
        const byte ICW4_8086 = 0x01;
        const byte ICW4_AutoEndOfInterrupt = 0x02;
        const byte ICW4_BufferedSlaveMode = 0x08;
        const byte ICW4_BufferedMasterMode = 0x0C;
        const byte ICW4_SpecialFullyNested = 0x10;

        const byte EOI = 0x20;

        internal static void Setup()
        {
            Remap(0x20, 0xF9, 0x28, 0xFF);
        }

        private static void Remap(byte masterStart, byte masterMask, byte slaveStart, byte slaveMask)
        {
            PortIO.Out8(PIC1_Command, ICW1_Initialization + ICW1_ICW4);
            PortIO.Wait();
            PortIO.Out8(PIC2_Command, ICW1_Initialization + ICW1_ICW4);
            PortIO.Wait();
            PortIO.Out8(PIC1_Data, masterStart);
            PortIO.Wait();
            PortIO.Out8(PIC2_Data, slaveStart);
            PortIO.Wait();

            PortIO.Out8(PIC1_Data, 4);
            PortIO.Wait();
            PortIO.Out8(PIC2_Data, 2);
            PortIO.Wait();

            // set modes:
            PortIO.Out8(PIC1_Data, ICW4_8086);
            PortIO.Wait();
            PortIO.Out8(PIC2_Data, ICW4_8086);
            PortIO.Wait();

            // set masks:
            PortIO.Out8(PIC1_Data, masterMask);
            PortIO.Wait();
            //PortIO.Out8(PIC2_Data, slaveMask);
            //PortIO.Wait();
        }

        internal static void EndOfInterrupt(int irq)
        {
            if (irq >= 40) // or untranslated IRQ >= 8
                PortIO.Out8(PIC2_Command, EOI);

            PortIO.Out8(PIC1_Command, EOI);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Pipe Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Lib;

using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.IO
{
    internal unsafe class Pipe
    {
        uint* Buffer;
        uint BufferSize;
        bool[] BufferStatus;

        int ReadingPointer;
        int WritingPointer;

        internal readonly int PacketSize;
        internal readonly int PacketsCount;

        internal Pipe(int aPacketSize, int aPacketsCount)
        {
            PacketsCount = aPacketsCount;
            PacketSize = aPacketSize;
            BufferSize = (uint)(PacketsCount * PacketSize);
            Buffer = (uint*)Heap.kmalloc(BufferSize);
            BufferStatus = new bool[PacketsCount];

            ReadingPointer = WritingPointer = 0;
        }

        internal bool Write(byte[] aData, bool Hangup = true)
        {
            return Write((byte*)aData.GetDataOffset(), Hangup);
        }

        internal bool Write(byte* aData, bool Hangup = true)
        {
            while (Hangup && BufferStatus[WritingPointer])
                Task.Switch();

            if (BufferStatus[WritingPointer])
                return false;

            Memory.FastCopy((uint)Buffer + (uint)(WritingPointer * PacketSize), (uint)aData, (uint)PacketSize);
            BufferStatus[WritingPointer] = true;

            WritingPointer = (WritingPointer + 1) % PacketsCount;
            return true;
        }

        internal bool Read(byte[] aData)
        {
            while (!BufferStatus[ReadingPointer])
                Task.Switch();

            Memory.FastCopy(aData.GetDataOffset(), (uint)Buffer + (uint)(ReadingPointer * PacketSize), (uint)PacketSize);
            BufferStatus[ReadingPointer] = false;

            ReadingPointer = (ReadingPointer + 1) % PacketsCount;
            return true;
        }
    }
}﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          I/O Port In out Functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomix.Kernel_H.Arch.x86
{
    internal static class PortIO
    {
        /// <summary>
        /// Read 8 bit from IO/Port
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [Assembly(true)]
        internal static byte In8(uint aAddress)
        {
            // Load address into EDX
            new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Set EAX = 0x00000000
            new Xor { DestinationReg = Register.EAX, SourceReg = Register.EAX };
            // Read 8 byte And put result into EAX (AL)
            new In { DestinationReg = Register.AL, SourceReg = Register.DX };
            // push EAX
            new Push { DestinationReg = Register.EAX };

            return 0x0;
        }

        /// <summary>
        /// Write 8 bit from IO/Port
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [Assembly(true)]
        internal static void Out8(uint aAddress, byte aValue)
        {
            // Load address into EDX
            new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0xC, SourceIndirect = true };
            // Load value into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Write 8 byte
            new Out { DestinationReg = Register.DX, SourceReg = Register.AL };
        }

        /// <summary>
        /// Read 16 bit from IO/Port
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [Assembly(true)]
        internal static ushort In16(uint aAddress)
        {
            // Load address into EDX
            new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Set EAX = 0x00000000
            new Xor { DestinationReg = Register.EAX, SourceReg = Register.EAX };
            // Read 16 byte And put result into EAX (AX)
            new In { DestinationReg = Register.AX, SourceReg = Register.DX };
            // push EAX
            new Push { DestinationReg = Register.EAX };

            return 0x0;
        }

        /// <summary>
        /// Write 16 bit from IO/Port
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [Assembly(true)]
        internal static void Out16(uint aAddress, ushort aValue)
        {
            // Load address into EDX
            new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0xC, SourceIndirect = true };
            // Load value into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Write 16 byte
            new Out { DestinationReg = Register.DX, SourceReg = Register.AX };
        }

        /// <summary>
        /// Read 32 bit from IO/Port
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [Assembly(true)]
        internal static uint In32(uint aAddress)
        {
            // Load address into EDX
            new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Set EAX = 0x00000000
            new Xor { DestinationReg = Register.EAX, SourceReg = Register.EAX };
            // Read 16 byte And put result into EAX (AX)
            new In { DestinationReg = Register.EAX, SourceReg = Register.DX };
            // push EAX
            new Push { DestinationReg = Register.EAX };

            return 0x0;
        }

        /// <summary>
        /// Write 32 bit from IO/Port
        /// </summary>
        /// <param name="aAddress">Address of memory</param>
        /// <returns></returns>
        [Assembly(true)]
        internal static void Out32(uint aAddress, uint aValue)
        {
            // Load address into EDX
            new Mov { DestinationReg = Register.EDX, SourceReg = Register.EBP, SourceDisplacement = 0xC, SourceIndirect = true };
            // Load value into EAX
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            // Write 16 byte
            new Out { DestinationReg = Register.DX, SourceReg = Register.EAX };
        }

        internal static void Read16(uint aAddress, UInt16[] xData)
        {
            for (int i = 0; i < xData.Length; i++)
            {
                xData[i] = In16(aAddress);
            }
        }

        internal static void Read16(uint aAddress, byte[] xData)
        {
            for (int i = 0; i < xData.Length; i += 2)
            {
                var aData = In16(aAddress);
                xData[i] = (byte)(aData & 0xFF);
                xData[i + 1] = (byte)(aData >> 8);
            }
        }

        internal static void Read16(uint aAddress, byte[] xData, int size)
        {
            Read16(aAddress, xData);

            for (int i = xData.Length - 1; i < size; i += 2)
                In16(aAddress);
        }

        internal static void Write16(uint aAddress, UInt16[] xData)
        {
            for (int i = 0; i < xData.Length; i++)
            {
                Out16(aAddress, xData[i]);
            }
        }

        internal static void Write16(uint aAddress, byte[] xData)
        {
            for (int i = 0; i < xData.Length; i += 2)
            {
                Out16(aAddress, (ushort)(xData[i + 1] << 8 | xData[i]));
            }
        }

        internal static void Wait()
        {
            Out8(0x80, 0x22);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Process Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;

using Atomix.Kernel_H.IO;
using Atomix.Kernel_H.Lib;
using Atomix.Kernel_H.Arch.x86;

namespace Atomix.Kernel_H.Core
{
    internal class Process
    {
        internal readonly uint ID;
        internal readonly string Name;
        internal readonly uint PageDirectory;
        internal readonly IList<Thread> Threads;
        internal readonly uint[] shm_mapping;
        internal readonly IList<Stream> Files;

        internal uint HeapCurrent;
        internal uint HeapEndAddress;
        internal readonly uint HeapStartAddress;

        internal Process(string aName, uint aDirectory)
        {
            Name = aName;
            ID = GetNewProcessID();
            PageDirectory = aDirectory;

            Files = new IList<Stream>();
            Threads = new IList<Thread>();

            // TODO: Should be a random address
            HeapStartAddress = 0xA0000000;
            HeapCurrent = HeapStartAddress;
            HeapEndAddress = HeapStartAddress;

            shm_mapping = new uint[SHM.LIMIT_TO_PROCESS];
        }

        internal void SetEnvironment()
        {
            Paging.SwitchDirectory(PageDirectory);
        }

        static uint _pid = 0;
        static uint GetNewProcessID()
        {
            return _pid++;
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Atomix.Debugger
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainFrm());
        }
    }
}
﻿using System;
using Kernel_alpha.x86;
using Kernel_alpha.x86.Intrinsic;

namespace Kernel_alpha.Drivers.Input
{
    // PS/2 Mouse Interface stuff

    public class PS2Mouse
    {
        /// <summary>
        /// The X coordinate
        /// </summary>
        public int X = 0;

        /// <summary>
        /// The Y coordinate
        /// </summary>
        public int Y = 0;

        /// <summary>
        /// The mouse buttons
        /// </summary>
        private MouseButtons button = MouseButtons.None;

        public MouseButtons Button
        { get { return button; } }

        // We'll be using 40 as sample rate
        // That's not too slow and not too fast
        byte SampleRate = 40;

        // We'll be receiving packets from here
        IOPort Data = null;

        // We'll be using this port to check if
        // packets are available
        IOPort Poll = null;

        byte cycle = 0;
        byte[] packet = new byte[4];

        public PS2Mouse ()
        {
            // I guess we'll be receiving data from Port 0x60
            Data = new IOPort (0x60);

            // And polling port 0x64
            Poll = new IOPort (0x64);

            //Init
            Initialize();

            //Register the Handler =D
            xINT.RegisterHandler(HandleIRQ, 0x2C);
        }

        public void Initialize ()
        {
            // Enable the Aux Input
            WaitSignal ();
            Poll.Byte = (byte)MouseCommandSet.Enable;

            // EnableInterrupt
            WaitSignal();
            Poll.Byte = 0x20;
            WaitData();

            byte status = (byte)(Data.Byte | 2);
            WaitSignal();
            Poll.Byte = 0x60;
            WaitSignal();
            Data.Byte = status;

            // Set defaults
            SendCommand (MouseCommandSet.SetDefaults);
            Read();

            // Enable the mouse
            SendCommand (MouseCommandSet.EnablePacketStreaming);
            Read();
        }

        public void SetSampleRate ()
        {
            SendCommand (MouseCommandSet.SetSampleRate);
            SendCommand (SampleRate);
        }

        public void HandleIRQ ()
        {
            var xRead = Read();
            switch (cycle)
            {
                case 0:
                    {
                        packet[0] = xRead;
                        if ((xRead & 0x8) == 0x8)
                            cycle++;
                        break;
                    }
                case 1:
                    {
                        packet[1] = xRead;
                        cycle++;
                        break;
                    }
                case 2:
                    {
                        packet[2] = xRead;
                        cycle = 0;

                        if ((packet[0] & 0x10) == 0x10)
                            X -= packet[1] ^ 0xFF;
                        else
                            X += packet[1];

                        if ((packet[0] & 0x20) == 0x20)
                            Y += packet[2] ^ 0xFF;
                        else
                            Y -= packet[2];

                        if (X < 0)
                            X = 0;

                        if (Y < 0)
                            Y = 0;

                        button = (MouseButtons)(packet[0] & 0x7);
                        break;
                    }
                default:
                    cycle = 0;
                    break;
            }
        }

        public void SendCommand (byte cmd)
        {
            // Wait till we can send a command
            WaitSignal ();

            // Tell the poll port that we
            // want to send a command to the mouse
            Poll.Byte = (byte)MouseCommandSet.Send;

            // Wait till we can send a command
            WaitSignal ();

            // Send the command to the data port
            Data.Byte = cmd;
        }

        public void SendCommand (MouseCommandSet cmd)
        {
            SendCommand ((byte)cmd);
        }

        public byte Read ()
        {
            // Wait for data to arrive
            WaitData ();

            // Return the data
            return Data.Byte;
        }

        public void WaitData ()
        {
            for (int i = 0; i < 1000 & ((Poll.Byte & 1) == 1); i++)
            {
                // Do nothing
            }
        }

        public void WaitSignal ()
        {
            for (int i = 0; i < 1000 & ((Poll.Byte & 2) != 0); i++)
            {
                // Do nothing
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          RFS (Ram File System) Helper
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.IO.FileSystem.RFS
{
    internal class RamFile
    {
        internal readonly string Name;
        internal readonly uint StartAddress;
        internal readonly int Length;

        internal RamFile(string aName, uint aStartAddress, int aLength)
        {
            Name = aName;
            StartAddress = aStartAddress;
            Length = aLength;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Ram File System
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Lib;

using Atomix.Kernel_H.Lib;
using Atomix.Kernel_H.IO.FileSystem.RFS;

using System.Runtime.InteropServices;

namespace Atomix.Kernel_H.IO.FileSystem
{
    internal unsafe class RamFileSystem : GenericFileSystem
    {
        uint DataAddress;
        uint DataLength;
        IDictionary<string, RamFile> Files;

        internal RamFileSystem(uint aAddress, uint aLength)
        {
            DataAddress = aAddress;
            DataLength = aLength;
            Files = new IDictionary<string, RamFile>(Internals.GetHashCode, string.Equals);
            mIsValid = LoadFileSystem();
        }

        private bool LoadFileSystem()
        {
            var Entries = (FileEntry*)DataAddress;
            Entries++;
            while(Entries->StartAddress != 0)
            {
                var FileName = new string(Entries->Name);
                Files.Add(FileName, new RamFile(FileName, Entries->StartAddress + DataAddress, Entries->Length));
                Entries++;
            }
            return true;
        }

        internal override Stream GetFile(string[] path, int pointer)
        {
            var FileName = path[pointer];
            if (Files.ContainsKey(FileName))
                return new FileStream(Files[FileName]);
            return null;
        }

        internal override bool CreateFile(string[] path, int pointer)
        {
            return false;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        struct FileEntry
        {
            [FieldOffset(0)]
            public fixed sbyte Name[32];

            [FieldOffset(32)]
            public uint StartAddress;

            [FieldOffset(36)]
            public int Length;
        }
    }
}
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Atomix.Debugger.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Atomix.Debugger.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;
using Kernel_alpha.x86.Intrinsic;
using Atomix.Assembler;
using Atomix.Assembler.x86;
using Core = Atomix.Assembler.AssemblyHelper;

namespace Atomix.mscorlib.Runtime.CompilerServices
{
    public static class RuntimeHelpers
    {
        [Assembly(true), Plug("System_Void_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray_System_Array__System_RuntimeFieldHandle_")]
        public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle)
        {
            var xLabel = "System_Void_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray_System_Array__System_RuntimeFieldHandle_";

            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, SourceReg = Registers.EBP, SourceIndirect = true, SourceDisplacement = 0xC });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ESI, SourceReg = Registers.EBP, SourceIndirect = true, SourceDisplacement = 0x8 });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EDI, SourceRef = "0x8" });
            Core.AssemblerCode.Add(new Push { DestinationReg = Registers.EDI, DestinationIndirect = true });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EDI, SourceRef = "0x4" });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceReg = Registers.EDI, SourceIndirect = true });
            Core.AssemblerCode.Add(new Multiply { DestinationReg = Registers.ESP, DestinationIndirect = true, Size = 32 });
            Core.AssemblerCode.Add(new Pop { DestinationReg = Registers.ECX });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.ECX, SourceReg = Registers.EAX });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EAX, SourceRef = "0x0" });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EDI, SourceRef = "0x4" });

            Core.AssemblerCode.Add(new Label(xLabel + ".StartLoop"));
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.DL, SourceReg = Registers.ESI, SourceIndirect = true, Size = 8 });
            Core.AssemblerCode.Add(new Mov { DestinationReg = Registers.EDI, DestinationIndirect = true, SourceReg = Registers.DL, Size = 8 });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EAX, SourceRef = "0x1" });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.ESI, SourceRef = "0x1" });
            Core.AssemblerCode.Add(new Add { DestinationReg = Registers.EDI, SourceRef = "0x1" });
            Core.AssemblerCode.Add(new Cmp { DestinationReg = Registers.EAX, SourceReg = Registers.ECX });
            Core.AssemblerCode.Add(new Jmp { Condition = ConditionalJumpEnum.JE, DestinationRef = xLabel + ".EndLoop" });
            Core.AssemblerCode.Add(new Jmp {DestinationRef = xLabel + ".StartLoop"});

            Core.AssemblerCode.Add(new Label(xLabel + ".EndLoop"));
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class SByte
    {
        [Plug("System_String_System_SByte_ToString__")]
        public static string ToString(ref sbyte aThis)
        {
            if (aThis > 0)
                return Number.ToString8Bit((byte)aThis, false);
            else
                return Number.ToString8Bit((byte)(-1 * aThis), true);
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Kernel Thread Scheduler
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Machine;
using Atomixilc.Attributes;

using Atomix.Kernel_H.Lib;
using Atomix.Kernel_H.Arch.x86;

namespace Atomix.Kernel_H.Core
{
    internal static class Scheduler
    {
        static Thread CurrentTask;
        static IQueue<Thread> ThreadQueue;

        internal static Process SystemProcess;

        internal static Process RunningProcess
        {
            get { return CurrentTask.Process; }
        }

        internal static Thread RunningThread
        {
            get { return CurrentTask; }
        }

        internal static void Init(uint KernelDirectory, uint StackStart)
        {
            ThreadQueue = new IQueue<Thread>(100);

            SystemProcess = new Process("System", KernelDirectory);
            CurrentTask = new Thread(SystemProcess, 0, StackStart, 10000, false);

            CurrentTask.Start();
        }

        internal static void AddThread(Thread th)
        {
            ThreadQueue.Enqueue(th);
        }

        [Label("__Switch_Task__")]
        internal static uint SwitchTask(uint aStack)
        {
            var NextTask = InvokeNext();

            if (CurrentTask == NextTask)
                return aStack;

            CurrentTask.SaveStack(aStack);
            if (NextTask.Process != CurrentTask.Process)
                NextTask.Process.SetEnvironment();

            CurrentTask = NextTask;
            return NextTask.LoadStack();
        }

        private static Thread InvokeNext()
        {
            var state = CurrentTask.Status;
            switch (state)
            {
                case ThreadState.Running:
                    ThreadQueue.Enqueue(CurrentTask);
                    break;
                default:// Do nothing for not active
                    break;
            }

            return ThreadQueue.Dequeue();
        }
    }
}
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Atomix.Debugger.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Handles Shared memory allocation stuffs
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomixilc.Lib;

using Atomix.Kernel_H.Lib;
using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.Arch.x86
{
    internal class shm_chunk
    {
        public uint RefCount;
        public uint[] Frames;
    }

    internal class SHM
    {
        public const uint START = 0xB0000000;

        // Maximum of 0x10000 frames starting from SHM_Start to any process
        public const int LIMIT_TO_PROCESS = 0x10000 >> 5;

        static uint aLock;
        static IDictionary<string, shm_chunk> Nodes;

        internal static void Install()
        {
            Nodes = new IDictionary<string, shm_chunk>(Internals.GetHashCode, string.Equals);
        }

        internal static unsafe uint Obtain(string aID, uint aSize, bool aDoAllocate = false)
        {
            Monitor.AcquireLock(ref aLock);

            if (!Nodes.ContainsKey(aID))
            {
                if (!aDoAllocate)
                {
                    Monitor.ReleaseLock(ref aLock);
                    return 0;
                }
                CreateNew(aID, aSize);
            }

            shm_chunk Current;
            Current = Nodes[aID];
            Current.RefCount++;

            var ParentProcess = Scheduler.RunningThread.Process;
            var shm_mapping = ParentProcess.shm_mapping;

            int FramesRequired = Current.Frames.Length;
            int CurrentFrameCount = 0;
            for (int i = 0; i < LIMIT_TO_PROCESS; i++)
            {
                for (int j = 0; j < 32; j++)
                {
                    uint index = (uint)(1 << j);
                    if ((shm_mapping[i] & index) == 0)
                    {
                        CurrentFrameCount++;
                        if (CurrentFrameCount == FramesRequired)
                        {
                            int xOffset = (i << 5) + j - FramesRequired + 1;
                            uint xVirtualAddress = START + (uint)(xOffset << 12);
                            uint xReturnAddress = xVirtualAddress;
                            var CurrentDirectory = Paging.CurrentDirectory;
                            var Frames = Current.Frames;

                            int Index = 0;
                            while (Index < FramesRequired)
                            {
                                Paging.AllocateFrame(Paging.GetPage(CurrentDirectory, xVirtualAddress, true), (Frames[Index] << 12), false);
                                Paging.InvalidatePageAt(xVirtualAddress);

                                // Also Mark in shm_mapping
                                shm_mapping[(xOffset >> 5)] |= (uint)(0x1 << (xOffset & 31));

                                xVirtualAddress += 0x1000;
                                xOffset++;
                                Index++;
                            }
                            Monitor.ReleaseLock(ref aLock);
                            return xReturnAddress;
                        }
                    }
                    else
                    {
                        CurrentFrameCount = 0;
                    }
                }
            }

            Monitor.ReleaseLock(ref aLock);
            Debug.Write("shm_mapping failed, Process id:=%d ", ParentProcess.ID);
            Debug.Write("shm_id := %s ", aID);
            Debug.Write("FramesRequired: %d\n", (uint)FramesRequired);
            return 0;
        }

        private static void CreateNew(string aID, uint Size)
        {
            uint NumberOfFrames = Size / 0x1000;
            if ((Size % 0x1000) != 0) NumberOfFrames++;

            var NewChunk = new shm_chunk();
            NewChunk.RefCount = 0;
            NewChunk.Frames = new uint[NumberOfFrames];

            for (uint index = 0; index < NumberOfFrames; index++)
            {
                // Allocate New Frame to this guy!
                uint NewFrame = Paging.FirstFreeFrame();
                Paging.SetFrame(NewFrame);

#warning [SHM] : Check for memory out of run condition.

                NewChunk.Frames[index] = NewFrame;
            }
            Nodes.Add(aID, NewChunk);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class SRImpl
    {
        [Plug("System_String_System_SR_GetString_System_String_")]
        public static string GetString(string aString)
        {
            return aString;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Kernel Start point
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc;
using Atomixilc.Lib;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Devices;
using Atomix.Kernel_H.Arch.x86;
using Atomix.Kernel_H.Drivers.Video;
using Atomix.Kernel_H.IO.FileSystem;

namespace Atomix.Kernel_H
{
    /// <summary>
    /// Startpoint for x86 CPU
    /// Kernel will be organised at 0xC0000000
    /// </summary>
    [Entrypoint(Architecture.x86, "(_Kernel_Main - 0xC0000000)")]
    public static class Startx86
    {
        [NoException]
        [Assembly(false)]
        public static void main()
        {
            const uint MultibootMagic = 0x1BADB002;
            const uint MultibootFlags = 0x10007;
            const uint InitalStackSize = 0x50000;
            const uint InitalHeapSize = 0x100000;

            /* Multiboot Config */
            new Literal("MultibootSignature dd {0}", MultibootMagic);
            new Literal("MultibootFlags dd {0}", MultibootFlags);
            new Literal("MultibootChecksum dd {0}", -(MultibootMagic + MultibootFlags));
            new Literal("MultibootHeaderAddr dd {0}", 0);
            new Literal("MultibootLoadAddr dd {0}", 0);
            new Literal("MultibootLoadEndAddr dd {0}", 0);
            new Literal("MultibootBSSEndAddr dd {0}", 0);
            new Literal("MultibootEntryAddr dd {0}", 0);
            new Literal("MultibootVesaMode dd {0}", 0);
            new Literal("MultibootVesaWidth dd {0}", 1024);
            new Literal("MultibootVesaHeight dd {0}", 768);
            new Literal("MultibootVesaDepth dd {0}", 32);

            Helper.InsertData("InitialStack", InitalStackSize);
            Helper.InsertData("InitialHeap", InitalHeapSize);

            new Label("_Kernel_Main");

            #region KernelPageDirectory
            Helper.InsertData(new AsmData("align 0x1000"));
            Helper.InsertData(new AsmData("KernelPageDirectory:"));
            Helper.InsertData(new AsmData("dd (KernelPageTable - 0xC0000000 + 0x3)"));
            Helper.InsertData(new AsmData("times (0x300 - 1) dd 0"));
            Helper.InsertData(new AsmData("dd (KernelPageTable - 0xC0000000 + 0x3)"));
            Helper.InsertData(new AsmData("times (1024 - 0x300 - 1) dd 0"));
            var xPageTable = new uint[1024];
            for (int i = 0; i < 1024; i++)
                xPageTable[i] = (uint)((i * 0x1000) | 0x3);
            Helper.InsertData(new AsmData("KernelPageTable", xPageTable));
            #endregion

            /* Load Page Directory Base Register. */
            new Mov { DestinationReg = Register.ECX, SourceRef = "(KernelPageDirectory - 0xC0000000)" };
            new Mov { DestinationReg = Register.CR3, SourceReg = Register.ECX };

            /* Set PG bit in CR0 to enable paging. */
            new Mov { DestinationReg = Register.ECX, SourceReg = Register.CR0 };
            new Or { DestinationReg = Register.ECX, SourceRef = "0x80000000" };
            new Mov { DestinationReg = Register.CR0, SourceReg = Register.ECX };

            /* Prepare for our quantum jump to Higher address */
            new Lea { DestinationReg = Register.ECX, SourceRef = "Higher_Half_Kernel", SourceIndirect = true };
            new Jmp { DestinationRef = "ECX" };

            new Label("Higher_Half_Kernel");
            new Mov { DestinationRef = "KernelPageDirectory", DestinationIndirect = true, SourceRef = "0x0" };
            new Literal("invlpg [0]");

            /* Setup Kernel stack */
            new Mov { DestinationReg = Register.ESP, SourceRef = "InitialStack" };
            new Add { DestinationReg = Register.ESP, SourceRef = InitalStackSize.ToString() };

            /* Push relevent data to the stack */
            new Push { DestinationReg = Register.EAX };//Push Magic Number
            new Push { DestinationReg = Register.EBX };//Push Multiboot Address
            new Push { DestinationRef = "KernelPageDirectory" };
            new Push { DestinationRef = "InitialHeap" };

            /* Enable Floating Point Unit */
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.CR0 };
            new And { DestinationReg = Register.AX, SourceRef = "0xFFFD", Size = 16 };
            new Or { DestinationReg = Register.AX, SourceRef = "0x10", Size = 16 };
            new Mov { DestinationReg = Register.CR0, SourceReg = Register.EAX };
            new Literal("fninit");

            /* Enable SSE */
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.CR0 };
            new And { DestinationReg = Register.AX, SourceRef = "0xFFFB", Size = 16 };
            new Or { DestinationReg = Register.AX, SourceRef = "0x2", Size = 16 };
            new Mov { DestinationReg = Register.CR0, SourceReg = Register.EAX };
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.CR4 };
            new Or { DestinationReg = Register.AX, SourceRef = "0x600", Size = 16 };
            new Mov { DestinationReg = Register.CR4, SourceReg = Register.EAX };

            /* push initial stack */
            new Push { DestinationReg = Register.ESP };

            /* Call Kernel Start */
            new Cli();
            new Call { DestinationRef = "Kernel_Start", IsLabel = true };
        }

        /// <summary>
        /// Kernel Call point
        /// </summary>
        /// <param name="magic">Magic Number of Multiboot</param>
        /// <param name="address">Multiboot Address</param>
        [Label("Kernel_Start")]
        internal static void Start(uint magic, uint address, uint KernelDirectory, uint InitialHeap, uint StackStart)
        {
            /* Kernel Logger init */
            Debug.Init();

            /* Initalize Heap */
            Heap.Init(InitialHeap);

            /* Init GC */
            Core.GC.Init();

            /* Multiboot Info Parsing */
            Multiboot.Setup(magic, address);

            /* Setup Paging */
            Paging.Setup(KernelDirectory);

            /* Setup GDT */
            GDT.Setup();

            /* Remap PIC */
            PIC.Setup();

            /* Setup IDT */
            IDT.Setup();

            /* Enable Interrupt */
            Native.Sti();

            /* Setup Scheduler */
            Scheduler.Init(KernelDirectory, StackStart);

            /* Setup System Timer */
            Timer.Setup();

            /* Install SHM */
            SHM.Install();

            /* Initialise VBE 2.0 Driver */
            VBE.Init();

            /* Initialise Virtual File system */
            VirtualFileSystem.Setup();

            /* Setup Syscall */
            Syscall.Setup();

            /* Initialise C library */
            Libc.Init();

            try
            {
                Boot.Init();
            }
            catch (Exception e)
            {
                Debug.Write("[@SystemThread] => [EXIT]: %s\n", e.Message);
            }

            while (true);
        }
    }
}
﻿using System;

namespace Atomix.Kernel_H.Lib.Cairo
{
    /* typedef enum _cairo_status {
     *      CAIRO_STATUS_SUCCESS = 0,
     *      CAIRO_STATUS_NO_MEMORY,
     *      CAIRO_STATUS_INVALID_RESTORE,
     *      CAIRO_STATUS_INVALID_POP_GROUP,
     *      CAIRO_STATUS_NO_CURRENT_POINT,
     *      CAIRO_STATUS_INVALID_MATRIX,
     *      CAIRO_STATUS_INVALID_STATUS,
     *      CAIRO_STATUS_NULL_POINTER,
     *      CAIRO_STATUS_INVALID_STRING,
     *      CAIRO_STATUS_INVALID_PATH_DATA,
     *      CAIRO_STATUS_READ_ERROR,
     *      CAIRO_STATUS_WRITE_ERROR,
     *      CAIRO_STATUS_SURFACE_FINISHED,
     *      CAIRO_STATUS_SURFACE_TYPE_MISMATCH,
     *      CAIRO_STATUS_PATTERN_TYPE_MISMATCH,
     *      CAIRO_STATUS_INVALID_CONTENT,
     *      CAIRO_STATUS_INVALID_FORMAT,
     *      CAIRO_STATUS_INVALID_VISUAL,
     *      CAIRO_STATUS_FILE_NOT_FOUND,
     *      CAIRO_STATUS_INVALID_DASH,
     *      CAIRO_STATUS_INVALID_DSC_COMMENT,
     *      CAIRO_STATUS_INVALID_INDEX,
     *      CAIRO_STATUS_CLIP_NOT_REPRESENTABLE,
     *      CAIRO_STATUS_TEMP_FILE_ERROR,
     *      CAIRO_STATUS_INVALID_STRIDE,
     *      CAIRO_STATUS_FONT_TYPE_MISMATCH,
     *      CAIRO_STATUS_USER_FONT_IMMUTABLE,
     *      CAIRO_STATUS_USER_FONT_ERROR,
     *      CAIRO_STATUS_NEGATIVE_COUNT,
     *      CAIRO_STATUS_INVALID_CLUSTERS,
     *      CAIRO_STATUS_INVALID_SLANT,
     *      CAIRO_STATUS_INVALID_WEIGHT,
     *      CAIRO_STATUS_INVALID_SIZE,
     *      CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED,
     *      CAIRO_STATUS_DEVICE_TYPE_MISMATCH,
     *      CAIRO_STATUS_DEVICE_ERROR,
     *      CAIRO_STATUS_INVALID_MESH_CONSTRUCTION,
     *      CAIRO_STATUS_DEVICE_FINISHED,
     *      CAIRO_STATUS_LAST_STATUS
     * } cairo_status_t;
     */

    [Serializable]
    internal enum Status
    {
        Success = 0,
        NoMemory,
        InvalidRestore,
        InvalidPopGroup,
        NoCurrentPoint,
        InvalidMatrix,
        InvalidStatus,
        NullPointer,
        InvalidString,
        InvalidPathData,
        ReadError,
        WriteError,
        SurfaceFinished,
        SurfaceTypeMismatch,
        PatternTypeMismatch,
        InvalidContent,
        InvalidFormat,
        InvalidVisual,
        FileNotFound,
        InvalidDash,
        InvalidDscComment,
        InvalidIndex,
        ClipNotRepresentable,
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Storage Abstract class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.Devices
{
    internal abstract class Storage
    {
        internal abstract unsafe bool Read(uint SectorNo, uint SectorCount, byte* xData);
        internal abstract unsafe bool Write(uint SectorNo, uint SectorCount, byte* xData);

        internal abstract bool Read(uint SectorNo, uint SectorCount, byte[] xData);
        internal abstract bool Write(uint SectorNo, uint SectorCount, byte[] xData);

        internal abstract bool Eject();
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Stream Abstract Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.IO
{
    public abstract class Stream
    {
        internal readonly string FileName;
        internal readonly int FileSize;

        internal Stream(string aFileName, int aSize)
        {
            FileName = aFileName;
            FileSize = aSize;
        }

        internal abstract bool CanSeek();
        internal abstract int Position();
        internal abstract bool CanRead();
        internal abstract bool CanWrite();

        internal abstract unsafe int Write(byte* aBuffer, int aCount);
        internal abstract unsafe int Read(byte* aBuffer, int aCount);

        internal abstract int Write(byte[] aBuffer, int aCount);
        internal abstract int Read(byte[] aBuffer, int aCount);
        internal abstract int Seek(int val, SEEK pos);

        internal abstract bool Close();
    }

    public enum SEEK : int
    {
        SEEK_FROM_ORIGIN = 0,
        SEEK_FROM_CURRENT = 1,
        SEEK_FROM_END = 2,
    }
}
﻿using System;
using System.Collections.Generic;

namespace Atomix.mscorlib
{
    public class StringBuilder
    {
        private List<char> xTemp;

        public StringBuilder ()
        {
            xTemp = new List<char> ();
        }

        public void Clear ()
        {
            xTemp = new List<char> ();
        }

        public void Append (char xChar)
        {
            xTemp.Add (xChar);
        }

        public void Append (string Str)
        {
            for (int i = 0; i < Str.Length; i++)
                xTemp.Add (Str[i]);
        }

        public void CutOne ()
        {
            List<char> newTemp = new List<char> ();

            for (int i = 0; i < xTemp.Count - 1; i++)
            {
                newTemp.Add (xTemp[i]);
            }

            xTemp = newTemp;
        }

        public void InsertAt (int pos, char chr)
        {
            List<char> newTemp = new List<char> ();

            for (int i = 0; i< xTemp.Count + 1; i++)
            {
                if (i < pos)
                {
                    newTemp.Add (xTemp[i]);
                }
                if (i == pos)
                {
                    newTemp.Add (chr);
                }
                if (i > pos)
                {
                    newTemp.Add (xTemp[i - 1]);
                }
            }

            xTemp = newTemp;
        }

        public void UpdateAt (int pos, char chr)
        {
            xTemp[pos] = chr;
        }

        public void RemoveAt (int pos)
        {
            List<char> newTemp = new List<char> ();

            for (int i = 0; i < xTemp.Count; i++)
            {
                if (i < pos)
                    newTemp.Add (xTemp[i]);
                if (i > pos)
                    newTemp.Add (xTemp[i]);
            }

            xTemp = newTemp;
        }

        public string Flush ()
        {
            //Calling two time count use more memory so save it as local variable
            var len = xTemp.Count;

            char[] xResult = new char[len];
            for (int i = 0; i < len; i++)
            {
                xResult[i] = xTemp[i];
            }

            return new String (xResult);
        }
    }
}
﻿using System;
using sys = System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;
using Kernel_alpha.x86.Intrinsic;

namespace Atomix.mscorlib
{
    public static class StringImpl
    {
        /*
            Length Offset   =>  [0x0C - 0x10)
            Data Offset     =>  [0x10 -  ∞)
        */
        [Plug("System_Void__System_String__ctor_System_Char___")]
        public static unsafe void ctor(byte* aFirstChar, char[] aChar)
        {
            ctor(aFirstChar, aChar, 0, aChar.Length);
        }

        [Plug("System_Void__System_String__ctor_System_Char__")]
        public static unsafe void ctor(byte* aFirstChar, char* aChar)
        {
            int i = 0;
            char* chars = (char*)(aFirstChar + 0x10);
            while (*aChar != '\0')
            {
                *chars = *aChar;
                ++chars;
                ++aChar;
                ++i;
            }
            *((int*)(aFirstChar + 0xC)) = i;
        }

        [Plug("System_Void__System_String__ctor_System_Char____System_Int32__System_Int32_")]
        public static unsafe void ctor(byte* aFirstChar, char[] aChar, int Start, int Length)
        {
            int i;
            char* chars = (char*)(aFirstChar + 0x10);
            for (i = 0; i < Length; i++)
                chars[i] = aChar[i + Start];

            *((int*)(aFirstChar + 0xC)) = i;
        }

        [Plug("System_Char_System_String_get_Chars_System_Int32_")]
        public static unsafe char Get_Chars(byte* aThis, int aIndex)
        {
            if (aIndex < 0 || aIndex >= Get_Length(aThis))
                return '\0';

            var xCharIdx = (char*)(aThis + 16);
            return xCharIdx[aIndex];
        }

        [Plug("System_Int32_System_String_get_Length__")]
        public unsafe static int Get_Length(byte* aThis)
        {
            var xCharIdx = (byte*)(aThis + 12);
            return (int)(xCharIdx[3] << 24 | xCharIdx[2] << 16 | xCharIdx[1] << 8 | xCharIdx[0]);
        }

        [Plug("System_String_System_String_Concat_System_String__System_String__System_String__System_String_")]
        public static string Concat(string s0, string s1, string s2, string s3)
        {
            return ConcatArray(new string[] { s0, s1, s2, s3 }, s0.Length + s1.Length + s2.Length + s3.Length);
        }

        [Plug("System_String_System_String_Concat_System_String__System_String__System_String_")]
        public static string Concat(string s0, string s1, string s2)
        {
            return ConcatArray(new string[] { s0, s1, s2 }, s0.Length + s1.Length + s2.Length);
        }

        [Plug("System_String_System_String_Concat_System_String__System_String_")]
        public static string Concat(string s0, string s1)
        {
            return ConcatArray(new string[] { s0, s1 }, s0.Length + s1.Length);
        }

        [Plug("System_String_System_String_Concat_System_String___")]
        public static string Concat(params string[] strs)
        {
            int len= 0;
            for (int i = 0; i < strs.Length; i++)
                len += strs[i].Length;

            return ConcatArray(strs, len);
        }

        private static string ConcatArray(string[] strs, int length)
        {
            char[] xResult = new char[length];
            int p = 0;
            for (int i = 0; i < strs.Length; i++)
            {
                var str = strs[i];
                for (int j = 0; j < str.Length; j++)
                {
                    xResult[p++] = str[j];
                }
            }

            return new String(xResult);
        }

        [Plug("System_String_System_String_Substring_System_Int32__System_Int32_")]
        public static string SubString(string aThis, int index, int length)
        {
            char[] xResult = new char[length];

            for (int i = 0; i < length; i++)
            {
                xResult[i] = aThis[index + i];
            }
            return new String(xResult);
        }

        [Plug("System_String_System_String_Substring_System_Int32_")]
        public static string SubString(string aThis, int index)
        {
            return SubString(aThis, index, aThis.Length - index + 1);
        }

        [Plug("System_String_System_String_ToLower__")]
        public static string ToLower(string aThis)
        {
            return ChangeCase(aThis, 65, 90, 32);
        }

        [Plug("System_String_System_String_ToUpper__")]
        public static string ToUpper(string aThis)
        {
            return ChangeCase(aThis, 97, 122, -32);
        }

        [Plug("System_String_System_String_PadLeft_System_Int32__System_Char_")]
        public static string PadLeft(string aThis, int TotalWidth, char paddingchar)
        {
            return Padding(aThis, TotalWidth, paddingchar, false);
        }

        [Plug("System_String_System_String_PadRight_System_Int32__System_Char_")]
        public static string PadRight(string aThis, int TotalWidth, char paddingchar)
        {
            return Padding(aThis, TotalWidth, paddingchar, true);
        }

        [Label("getLength_System_Char__")]
        public unsafe static int getLength(char* str)
        {
            int length = 0;
            while (*str != '\0')
            {
                ++str;
                ++length;
            }
            return length;
        }

        private static string Padding(string aThis, int TotalWidth, char PaddingChar, bool Direction)
        {
            var len = aThis.Length;

            if (len >= TotalWidth)
                return aThis;

            char[] xResult = new char[TotalWidth];
            if (Direction)
            {
                //Padding Right
                for (int i = 0; i < TotalWidth; i++)
                {
                    if (len <= i)
                        xResult[i] = PaddingChar;
                    else
                        xResult[i] = aThis[i];
                }
            }
            else
            {
                var xOffset = TotalWidth - len;
                //Padding Left
                for (int i = 0; i < TotalWidth; i++)
                {
                    if (i < xOffset)
                        xResult[i] = PaddingChar;
                    else
                        xResult[i] = aThis[i - xOffset];
                }
            }
            return new String(xResult);
        }

        private static string ChangeCase(string xStr, int lowerACII, int upperASCII, int value)
        {
            char[] xResult = new char[xStr.Length];
            for (int i = 0; i < xStr.Length; i++)
            {
                var xChar = xStr[i];
                if (xChar >= lowerACII && xChar <= upperASCII)
                {
                    xChar = (char)(xChar + value);
                }

                xResult[i] = xChar;
            }
            return new String(xResult);
        }

        [Plug("System_String___System_String_Split_System_Char___")]
        public static string[] Split(string str, char[] c)
        {
            int counter = 0;
            for (int i = 0; i < str.Length; i++)
            {
                if (str[i] == c[0])
                {
                    counter++;
                }
            }
            string[] xResult = new string[counter + 1];
            char[] xTemp = new char[255];

            int mcounter = 0;
            int zcounter = 0;
            for (int i = 0; i < str.Length; i++)
            {
                if (str[i] == c[0])
                {
                    char[] xTemp2 = new char[mcounter + 1];
                    for (int j = 0; j < mcounter; j++)
                    {
                        xTemp2[j] = xTemp[j];
                    }
                    mcounter = 0;
                    xResult[zcounter] = new string(xTemp2);
                    zcounter++;
                }
                else
                {
                    xTemp[mcounter] = str[i];
                    mcounter++;

                    if (i == str.Length - 1)
                    {
                        char[] xTemp2 = new char[mcounter + 1];
                        for (int j = 0; j < mcounter; j++)
                        {
                            xTemp2[j] = xTemp[j];
                        }
                        mcounter = 0;
                        xResult[zcounter] = new string(xTemp2);
                        zcounter++;
                    }
                }
            }
            return xResult;
        }

        [Plug("System_String_System_String_Trim__")]
        public static string Trim(string aThis)
        {
            int c = 0;
            for (int i = 0; i < aThis.Length; i++)
            {
                if (aThis[i] == ' ')
                    break;
                c++;
            }
            return aThis.Substring(0, c);
        }

        [Plug("System_String_System_String_Trim_System_Char___")]
        public static string Trim(string aThis, char[] aChar)
        {
            /* Done it in very hurry, haha...so it do limited work */
            int c = 0;
            for (int i = 0; i < aThis.Length; i++)
            {
                if (aThis[i] == aChar[0])
                    break;
                c++;
            }
            return aThis.Substring(0, c);
        }

        [Plug("System_Boolean_System_String_op_Equality_System_String__System_String_")]
        public static bool Equality(string str1, string str2)
        {
            var len = str1.Length;
            if (len != str2.Length)
                return false;

            for (int i = 0; i < len; i++)
            {
                if (str1[i] != str2[i])
                    return false;
            }
            return true;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          To Implement Syscall
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Kernel_H.IO;
using Atomix.Kernel_H.Arch.x86;
using Atomix.Kernel_H.IO.FileSystem;

namespace Atomix.Kernel_H.Core
{
    internal static class Syscall
    {
        internal static void Setup()
        {
            IDT.RegisterInterrupt(Handler, 0x7F);
        }

        private static unsafe void Handler(ref IRQContext context)
        {
            switch((Function)context.EAX)
            {
                case Function.SYS_brk:
                    context.EAX = (int)sys_brk(context.EBX);
                    break;
                case Function.SYS_read:
                    context.EAX = sys_read(context.EBX, (byte*)context.ECX, context.EDX);
                    break;
                case Function.SYS_open:
                    context.EAX = sys_open((sbyte*)context.EBX, context.ECX, context.EDX);
                    break;
                case Function.SYS_seek:
                    context.EAX = sys_seek(context.EBX, context.ECX, context.EDX);
                    break;
                case Function.SYS_close:
                    context.EAX = sys_close(context.EBX);
                    break;
                case Function.SYS_write:
                    context.EAX = sys_write(context.EBX, (byte*)context.ECX, context.EDX);
                    break;
                default:
                    Debug.Write("Unhandled syscall %d\n", context.EAX);
                    break;
            }
        }

        private static unsafe uint sys_brk(int len)
        {
            var Process = Scheduler.RunningProcess;

            uint directory = Process.PageDirectory;
            uint current = Process.HeapCurrent;
            uint end = Process.HeapEndAddress;

            // Assert EAX == sys_brk

            uint addr = current;
            current += (uint)len;

            if (current > 0xA5000000)
            {
                Debug.Write("sys_brk failed\n");
                return 0;
            }

            // Assert end should be page aligned

            while (current > end)
            {
                Paging.AllocateFrame(Paging.GetPage((uint*)directory, end, true), 0, true);
                Paging.InvalidatePageAt(end);
                end += Paging.PageSize;
            }

            Process.HeapCurrent = current;
            Process.HeapEndAddress = end;

            return addr;
        }

        private static unsafe int sys_write(int fb, byte* buffer, int count)
        {
            for (int i = 0; i < count; i++)
                Debug.Write(*(buffer + i));
            return count;
        }

        private static unsafe int sys_read(int fd, byte* buffer, int count)
        {
            if (fd < 0) return -1;

            var Process = Scheduler.RunningProcess;
            var files = Process.Files;

            if (fd >= files.Count) return -1;

            var stream = Process.Files[fd];
            return stream.Read(buffer, count);
        }

        private static int sys_seek(int fd, int offset, int origin)
        {
            if (fd < 0) return -1;

            var Process = Scheduler.RunningProcess;
            var files = Process.Files;

            if (fd >= files.Count) return -1;
            if (origin > 2) return -1;

            var stream = Process.Files[fd];
            return stream.Seek(offset, (SEEK)origin);
        }

        private static int sys_close(int fd)
        {
            if (fd < 0) return -1;

            var Process = Scheduler.RunningProcess;
            var files = Process.Files;

            if (fd >= files.Count) return -1;

            var stream = Process.Files[fd];
            Process.Files[fd] = null;

            stream.Close();
            Debug.Write("close() : %d\n", fd);

            return 0;
        }

        private static unsafe int sys_open(sbyte* file, int flags, int mode)
        {
            var filename = new string(file);
            var stream = VirtualFileSystem.GetFile(filename);
            Debug.Write("fopen: %s\n", filename);

            if (stream == null)
                return -1;

            var Process = Scheduler.RunningProcess;
            var files = Process.Files;
            int count = files.Count;

            int fd = -1;
            for (int index = 0; index < count; index++)
            {
                if (files[index] == null)
                {
                    files[index] = stream;
                    fd = index;
                }
            }

            if (fd == -1)
            {
                files.Add(stream);
                fd = count;
            }

            return fd;
        }

        /// <summary>
        /// Defined in Syscalls.h
        /// </summary>
        internal enum Function : uint
        {
            SYS_exit = 1,
            SYS_fork = 2,
            SYS_read = 3,
            SYS_write = 4,
            SYS_open = 5,
            SYS_close = 6,
            SYS_wait4 = 7,
            SYS_creat = 8,
            SYS_link = 9,
            SYS_unlink = 10,
            SYS_execv = 11,
            SYS_chdir = 12,
            SYS_mknod = 14,
            SYS_chmod = 15,
            SYS_chown = 16,
            SYS_seek = 19,
            SYS_getpid = 20,
            SYS_isatty = 21,
            SYS_fstat = 22,
            SYS_time = 23,
            SYS_ARG = 24,
            SYS_kill = 37,
            SYS_stat = 38,
            SYS_pipe = 42,
            SYS_brk = 45,
            SYS_execve = 59,
            SYS_gettimeofday = 78,
            SYS_truncate = 129,
            SYS_ftruncate = 130,
            SYS_argc = 172,
            SYS_argnlen = 173,
            SYS_argn = 174,
            SYS_utime = 201,
            SYS_wait = 202
        };
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          thread (task) switch support functions
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

using Atomix.Kernel_H.Devices;

namespace Atomix.Kernel_H.Core
{
    internal static class Task
    {
        [NoException]
        [Assembly(false)]
        internal static void Switch()
        {
            new Literal("int 0x75");
            new Ret { Offset = 0x0 };
        }

        [NoException]
        [Assembly(false)]
        [Plug("__ISR_Handler_75", Architecture.x86)]
        private static void Handler()
        {
            // Clear Interrupts
            new Cli ();

            // Push all the Registers
            new Pushad ();

            // Push ESP
            new Push { DestinationReg = Register.ESP };
            new Call { DestinationRef = "__Switch_Task__", IsLabel = true };

            // Get New task ESP
            new Mov { DestinationReg = Register.ESP, SourceReg = Register.EAX };

            // Load Registers
            new Popad ();

            // Enable Interrupts
            new Sti ();

            // Return
            new Iret ();
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MT = Kernel_alpha.Multitasking;
using Kernel_alpha.x86.Intrinsic;

namespace Kernel_alpha
{
    public class Thread
    {
        protected int aProcessid;
        protected int SleepCounter;

        #region Constructors
        public int ProcessID
        { get { return aProcessid; } }

        public State State
        {
            get
            {
                return (State)MT.Tasks[aProcessid].state;
            }
            set
            {
                MT.Tasks[aProcessid].state = (ushort)value;
            }
        }
        #endregion

        public Thread(int pid)
        {
            this.aProcessid = pid;
        }

        public void Start()
        {
            this.State = State.Alive;
        }

        /// <summary>
        /// Stop Refrenced Thread
        /// </summary>
        public void Stop()
        {
            this.State = State.Dead;
            IRQ.Timer();
        }

        /// <summary>
        /// Die Current Thread
        /// </summary>
        public static void Die()
        {
            MT.Tasks[MT.CurrentTask].state = (int)State.Dead;
            //As we have done our code, so let other thread to start...So we fire IRQ0
            IRQ.Timer();
        }

        public static void Sleep(uint Cycles)
        {
            MT.Tasks[MT.CurrentTask].state = (int)Cycles; //Cycles should be positive =P
            IRQ.Timer();
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          System Hardware Timer (IRQ0)
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc;
using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Arch.x86;

namespace Atomix.Kernel_H.Devices
{
    internal static class Timer
    {
        internal static uint TicksFromStart;

        internal static void Setup()
        {
            Debug.Write("Initializing interval timer\n");

            /* Set Timer Frequency to 100Hz */
            SetFrequency(100);
        }

        [Label("__Timer_Handler__")]
        private static uint Handler(uint aOldStack)
        {
            TicksFromStart++;
            return Scheduler.SwitchTask(aOldStack);
        }

        private static void SetFrequency(int Hz)
        {
            int divisor = 1193180 / Hz;
            PortIO.Out8(0x43, 0x36);                            /* Set our command byte 0x36 */
            PortIO.Out8(0x40, (byte)(divisor & 0xFF));          /* Set low byte of divisor */
            PortIO.Out8(0x40, (byte)(divisor >> 8));            /* Set high byte of divisor */

            /* Enable Timer IRQ (Clear mask) */
            byte value = (byte)(PortIO.In8(0x21) & 0xFE);
            PortIO.Out8(0x21, value);
        }

        [NoException]
        [Assembly(false)]
        [Plug("__ISR_Handler_20", Architecture.x86)]
        private static void IRQ0()
        {
            // Clear Interrupts
            new Cli();

            // Push all the Registers
            new Pushad();

            // Tell CPU that we have recieved IRQ
            new Mov { DestinationReg = Register.AL, SourceRef = "0x20", Size = 8 };
            new Out { DestinationRef = "0x20", SourceReg = Register.AL };

            // Push ESP
            new Push { DestinationReg = Register.ESP };
            new Call { DestinationRef = "__Timer_Handler__", IsLabel = true };

            // Get New task ESP
            new Mov { DestinationReg = Register.ESP, SourceReg = Register.EAX };

            // Load Registers
            new Popad();

            // Enable Interrupts
            new Sti();

            new Iret();
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class TypeImpl
    {
        [Plug("System_Void__System_Type__cctor__")]
        public static void Cctor()
        {
            return;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class UInt32
    {
        [Plug("System_String_System_UInt32_ToString__")]
        public static string ToString(ref uint aThis)
        {
            return Number.ToString32Bit(aThis, false);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Atomix.CompilerExt;
using Atomix.CompilerExt.Attributes;

namespace Atomix.mscorlib
{
    public static class UInt64
    {
        [Plug("System_String_System_UInt64_ToString__")]
        public static string ToString(ref ulong aThis)
        {
            ulong x = aThis;
            return Number.ToString64Bit(x, false);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Kernel_alpha.x86;
using Kernel_alpha.Lib;

namespace Kernel_alpha.Drivers.Video.VBE
{
    public static unsafe class VBE2_0
    {
        public static VBE_Mode_Info* ModeInfo;
        private static UInt32* LinearFrameBuffer;
        public static ushort Xres;
        public static ushort Yres;

        public static void Setup()
        {
            ModeInfo = (VBE_Mode_Info*)Multiboot.VBE_Mode_Info;
            LinearFrameBuffer = (UInt32*)ModeInfo->physbase;
            Xres = ModeInfo->Xres;
            Yres = ModeInfo->Yres;

            /*
            for (uint i = ModeInfo->physbase; i <= ModeInfo->physbase + 0xFF0000; i+= 0x1000)
            {
                Paging.DMAFrame(Paging.GetPage(i, (UInt32*)Paging.Current_Directory, true), false, true, i);
            }

            Paging.ReloadDirectory();*/
        }

        public static void Clear(uint c)
        {
            uint p = 0;
            for (ushort x = 0; x < Xres; x++)
            {
                for (ushort y = 0; y < Yres; y++)
                {
                    LinearFrameBuffer[p++] = c;
                }
            }
        }

        public static void SetPixel(ushort x, ushort y, uint c)
        {
            if (x >= Xres || y >= Yres)
                return;

            LinearFrameBuffer[(uint)(x + (y * Xres))] = c;
        }

        public static uint GetPixel(ushort x, ushort y)
        {
            if (x >= Xres || y >= Yres)
                return 0;

            return LinearFrameBuffer[(uint)(x + (y * Xres))];
        }

        #region Struct
        [StructLayout(LayoutKind.Explicit, Size = 50)]
        public unsafe struct VBE_Mode_Info
        {
            [FieldOffset(0)]
            public UInt16 attributes;
            [FieldOffset(2)]
            public byte winA;
            [FieldOffset(3)]
            public byte winB;
            [FieldOffset(4)]
            public UInt16 granularity;
            [FieldOffset(6)]
            public UInt16 winsize;
            [FieldOffset(8)]
            public UInt16 segmentA;
            [FieldOffset(10)]
            public UInt16 segmentB;
            [FieldOffset(12)]
            public UInt32 realFctPtr;
            [FieldOffset(16)]
            public UInt16 pitch;
            [FieldOffset(18)]
            public UInt16 Xres;
            [FieldOffset(20)]
            public UInt16 Yres;
            [FieldOffset(22)]
            public byte Wchar;
            [FieldOffset(23)]
            public byte Ychar;
            [FieldOffset(24)]
            public byte planes;
            [FieldOffset(25)]
            public byte bpp;
            [FieldOffset(26)]
            public byte banks;
            [FieldOffset(27)]
            public byte memory_model;
            [FieldOffset(28)]
            public byte bank_size;
            [FieldOffset(29)]
            public byte image_pages;
            [FieldOffset(30)]
            public byte reserved0;
            [FieldOffset(31)]
            public byte red_mask;
            [FieldOffset(32)]
            public byte red_position;
            [FieldOffset(33)]
            public byte green_mask;
            [FieldOffset(34)]
            public byte green_position;
            [FieldOffset(35)]
            public byte blue_mask;
            [FieldOffset(36)]
            public byte blue_position;
            [FieldOffset(37)]
            public byte rsv_mask;
            [FieldOffset(38)]
            public byte rsv_position;
            [FieldOffset(39)]
            public byte directcolor_attributes;
            [FieldOffset(40)]
            public UInt32 physbase;
            [FieldOffset(44)]
            public UInt32 reserved1;
            [FieldOffset(48)]
            public UInt16 reserved2;
        }
        #endregion
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          VBE 2.0 Driver
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;
using System.Runtime.InteropServices;

using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Arch.x86;

using Atomixilc.Machine;
using Atomixilc.Attributes;
using Atomixilc.Machine.x86;

namespace Atomix.Kernel_H.Drivers.Video
{
    internal static unsafe class VBE
    {
        internal static int Xres;
        internal static int Yres;
        internal static uint BytesPerPixel;
        internal static uint SecondaryBuffer;
        internal static uint VirtualFrameBuffer;
        private static VBE_Mode_Info* ModeInfoBlock;

        internal static void Init()
        {
            Debug.Write("VBE Init()\n");
            ModeInfoBlock = (VBE_Mode_Info*)(Multiboot.VBE_Mode_Info + 0xC0000000);
            Xres = ModeInfoBlock->Xres;
            Yres = ModeInfoBlock->Yres;
            BytesPerPixel = (uint)ModeInfoBlock->bpp / 8;
            SecondaryBuffer = Paging.AllocateSecondayBuffer();
            VirtualFrameBuffer = Paging.AllocateMainBuffer(ModeInfoBlock->physbase);

            /* Print Debug Info */
            Debug.Write("Virtual Frame Buffer: %d\n", VirtualFrameBuffer);
            Debug.Write("Secondary Frame Buffer: %d\n", SecondaryBuffer);
            Debug.Write("Resolution: %dx", (uint)Xres);
            Debug.Write("%dx", (uint)Yres);
            Debug.Write("%d\n", BytesPerPixel);
        }

        internal static void SetPixel(int x, int y, uint c)
        {
            byte *buffer = (byte*)(((x + (y * Xres)) * BytesPerPixel) + SecondaryBuffer);
            buffer[0] = (byte)(c >> 0);
            buffer[1] = (byte)(c >> 8);
            buffer[2] = (byte)(c >> 16);
        }

        internal static uint GetPixel(int x, int y)
        {
            byte* buffer = (byte*)(((x + (y * Xres)) * BytesPerPixel) + SecondaryBuffer);
            return (uint)(buffer[2] << 16 | buffer[1] << 8 | buffer[0]);
        }

        [Assembly(true)]
        internal static void Clear(uint color)
        {
            new Mov { DestinationReg = Register.EDI, SourceRef = "static_Field__System_UInt32_Atomix_Kernel_H_Drivers_Video_VBE_SecondaryBuffer", SourceIndirect = true };
            new Mov { DestinationReg = Register.ECX, SourceRef = "0x100000" };
            new Mov { DestinationReg = Register.EAX, SourceReg = Register.EBP, SourceDisplacement = 0x8, SourceIndirect = true };
            new Cli ();
            new Literal ("rep stosd");
            new Sti ();
        }

        [Assembly(true)]
        internal static void Update()
        {
#warning [VBE] : fixed size memory copy
            //Copy 4MB of data from Secondary Buffer to Virtual Frame Buffer
            new Mov { DestinationReg = Register.ESI, SourceRef = "static_Field__System_UInt32_Atomix_Kernel_H_Drivers_Video_VBE_SecondaryBuffer", SourceIndirect = true };
            new Mov { DestinationReg = Register.EDI, SourceRef = "static_Field__System_UInt32_Atomix_Kernel_H_Drivers_Video_VBE_VirtualFrameBuffer", SourceIndirect = true };
            new Mov { DestinationReg = Register.ECX, SourceRef = "0x100000" };
            new Cli ();
            new Literal ("rep movsd");
            new Sti ();
        }

        [StructLayout(LayoutKind.Explicit, Size = 50)]
        public unsafe struct VBE_Mode_Info
        {
            [FieldOffset(0)]
            public UInt16 attributes;
            [FieldOffset(2)]
            public byte winA;
            [FieldOffset(3)]
            public byte winB;
            [FieldOffset(4)]
            public UInt16 granularity;
            [FieldOffset(6)]
            public UInt16 winsize;
            [FieldOffset(8)]
            public UInt16 segmentA;
            [FieldOffset(10)]
            public UInt16 segmentB;
            [FieldOffset(12)]
            public UInt32 realFctPtr;
            [FieldOffset(16)]
            public UInt16 pitch;
            [FieldOffset(18)]
            public UInt16 Xres;
            [FieldOffset(20)]
            public UInt16 Yres;
            [FieldOffset(22)]
            public byte Wchar;
            [FieldOffset(23)]
            public byte Ychar;
            [FieldOffset(24)]
            public byte planes;
            [FieldOffset(25)]
            public byte bpp;
            [FieldOffset(26)]
            public byte banks;
            [FieldOffset(27)]
            public byte memory_model;
            [FieldOffset(28)]
            public byte bank_size;
            [FieldOffset(29)]
            public byte image_pages;
            [FieldOffset(30)]
            public byte reserved0;
            [FieldOffset(31)]
            public byte red_mask;
            [FieldOffset(32)]
            public byte red_position;
            [FieldOffset(33)]
            public byte green_mask;
            [FieldOffset(34)]
            public byte green_position;
            [FieldOffset(35)]
            public byte blue_mask;
            [FieldOffset(36)]
            public byte blue_position;
            [FieldOffset(37)]
            public byte rsv_mask;
            [FieldOffset(38)]
            public byte rsv_position;
            [FieldOffset(39)]
            public byte directcolor_attributes;
            [FieldOffset(40)]
            public UInt32 physbase;
            [FieldOffset(44)]
            public UInt32 reserved1;
            [FieldOffset(48)]
            public UInt16 reserved2;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using Kernel_alpha.x86.Intrinsic;
using Kernel_alpha.Drivers.Video.VGA;
using Kernel_alpha.Lib;

namespace Kernel_alpha.Drivers.Video
{
    public unsafe class VGAScreen
    {
        #region IO Ports
        private readonly IOPort AttributeController_Index;
        private readonly IOPort AttributeController_Read;
        private readonly IOPort AttributeController_Write;

        private readonly IOPort MiscellaneousOutput_Write;

        private readonly IOPort Sequencer_Index;
        private readonly IOPort Sequencer_Data;

        private readonly IOPort DACIndex_Read;
        private readonly IOPort DACIndex_Write;
        private readonly IOPort DAC_Data;

        private readonly IOPort GraphicsController_Index;
        private readonly IOPort GraphicsController_Data;
        private readonly IOPort CRTController_Index;
        private readonly IOPort CRTController_Data;
        private readonly IOPort Instat_Read;
        #endregion

        private const byte NumSeqRegs = 5;
        private const byte NumCRTCRegs = 25;
        private const byte NumGCRegs = 9;
        private const byte NumACRegs = 21;

        private MemoryBlock08 VideoMemory;

        private ushort width;
        private ushort height;

        public ushort Width
        { get { return width; } }

        public ushort Height
        { get { return height; } }

        public VGAScreen()
        {
            AttributeController_Index = new IOPort(0x3C0);
            AttributeController_Read = new IOPort(0x3C1);
            AttributeController_Write = new IOPort(0x3C0);
            MiscellaneousOutput_Write = new IOPort(0x3C2);
            Sequencer_Index = new IOPort(0x3C4);
            Sequencer_Data = new IOPort(0x3C5);
            DACIndex_Read = new IOPort(0x3C7);
            DACIndex_Write = new IOPort(0x3C8);
            DAC_Data = new IOPort(0x3C9);
            GraphicsController_Index = new IOPort(0x3CE);
            GraphicsController_Data = new IOPort(0x3CF);
            CRTController_Index = new IOPort(0x3D4);
            CRTController_Data = new IOPort(0x3D5);
            Instat_Read = new IOPort(0x3DA);

            VideoMemory = new MemoryBlock08(0xA0000);
        }

        public void SetMode0()
        {
            WriteRegister(modes.g_640x480x16);
            width = 640;
            height = 480;

            byte[] xHex = new byte[] { 0x00, 0x33, 0x66, 0x99, 0xCC, 0xFF };
            int c = 0;
            for (byte i = 0; i < 6; i++)
                for (byte j = 0; j < 6; j++)
                    for (byte k = 0; k < 6; k++)
                    {
                        SetPaletteEntry(c, xHex[i], xHex[j], xHex[k]);
                        c++;
                    }
        }

        private void WriteRegister(byte[] registers)
        {
            int xIdx = 0;
            byte i;

            /* write MISCELLANEOUS reg */
            MiscellaneousOutput_Write.Byte = registers[xIdx];
            xIdx++;

            /* write SEQUENCER regs */
            for (i = 0; i < NumSeqRegs; i++)
            {
                Sequencer_Index.Byte = i;
                Sequencer_Data.Byte = registers[xIdx];
                xIdx++;
            }

            /* unlock CRTC registers */
            CRTController_Index.Byte = 0x03;
            CRTController_Data.Byte = (byte)(CRTController_Data.Byte | 0x80);
            CRTController_Index.Byte = 0x11;
            CRTController_Data.Byte = (byte)(CRTController_Data.Byte & 0x7F);

            /* make sure they remain unlocked */
            registers[0x03] |= 0x80;
            registers[0x11] &= 0x7f;

            /* write CRTC regs */
            for (i = 0; i < NumCRTCRegs; i++)
            {
                CRTController_Index.Byte = i;
                CRTController_Data.Byte = registers[xIdx];
                xIdx++;
            }

            /* write GRAPHICS CONTROLLER regs */
            for (i = 0; i < NumGCRegs; i++)
            {
                GraphicsController_Index.Byte = i;
                GraphicsController_Data.Byte = registers[xIdx];
                xIdx++;
            }

            /* write ATTRIBUTE CONTROLLER regs */
            for (i = 0; i < NumACRegs; i++)
            {
                var xDoSomething = Instat_Read.Byte;
                AttributeController_Index.Byte = i;
                AttributeController_Write.Byte = registers[xIdx];
                xIdx++;
            }

            /* lock 16-color palette and unblank display */
            var xNothing = Instat_Read.Byte;
            AttributeController_Index.Byte = 0x20;
        }

        public void SetPaletteEntry(int index, byte r, byte g, byte b)
        {
            DACIndex_Write.Byte = (byte)index;
            DAC_Data.Byte = (byte)(r >> 2);
            DAC_Data.Byte = (byte)(g >> 2);
            DAC_Data.Byte = (byte)(b >> 2);
        }

        public void SetPixel_8(uint x, uint y, byte color)
        {
            var xOffset = (uint)((y * Width) + x);
            VideoMemory[xOffset] = color;
        }
        public void SetPixel_640_480(uint x, uint y, byte color)
        {
            int wd_in_bytes = width / 8;
            int off = (int)((wd_in_bytes * y) + (int)(x / 8));
            int posx = (int)((x & 7) * 1);
            int mask = 0x80 >> posx;
            int pmask = 1;
            for (int p = 0; p < 4; p++)
            {
                Setplane(p);
                if((pmask & color) != 0)
                {
                    VideoMemory[(uint)off] |= (byte)mask;
                }
                else
                {
                    VideoMemory[(uint)off] &= (byte)~mask;
                }
                pmask <<= 1;
            }
        }

        private void Setplane(int p)
        {
            byte pmask;
            int p2 = p & 3;
            pmask = (byte)(1 << p2);

            GraphicsController_Index.Byte = 4;
            GraphicsController_Data.Byte = (byte)p2;

            Sequencer_Index.Byte = 2;
            Sequencer_Data.Byte = pmask;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Virtual File System
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomixilc.Lib;

using Atomix.Kernel_H.Lib;
using Atomix.Kernel_H.Core;

namespace Atomix.Kernel_H.IO.FileSystem
{
    internal static class VirtualFileSystem
    {
        static IDictionary<string, GenericFileSystem> MountedFS;

        internal static void Setup()
        {
            MountedFS = new IDictionary<string, GenericFileSystem>(Internals.GetHashCode, string.Equals);
        }

        internal static GenericFileSystem GetFS(string aDevice)
        {
            if (!MountedFS.ContainsKey(aDevice))
                return null;
            return MountedFS[aDevice];
        }

        internal static Stream GetFile(string aPath)
        {
            var paths = Marshal.Split(aPath, '/');
            var FileSystem = GetFS(paths[0]);
            if (FileSystem == null)
                return null;
            var xStream = FileSystem.GetFile(paths, 1);
            return xStream;
        }

        internal static bool CreateFile(string aPath)
        {
            var paths = Marshal.Split(aPath, '/');
            var FileSystem = GetFS(paths[0]);
            if (FileSystem == null)
                return false;
            var xValue = FileSystem.CreateFile(paths, 1);
            return xValue;
        }

        internal static bool MountDevice(string aDeviceName, GenericFileSystem aFS)
        {
            if (!aFS.IsValid)
                return false;

            if (aDeviceName == null)
                aDeviceName = GetDeviceLabel();

            if (MountedFS.ContainsKey(aDeviceName))
                return false;

            MountedFS.Add(aDeviceName, aFS);
            Debug.Write("Directory Mounted: %s\n", aDeviceName);
            return true;
        }

        static uint mDeviceLabelCounter = 0;
        private static string GetDeviceLabel()
        {
			string suffix = Convert.ToString(mDeviceLabelCounter++);
            string Label = ("disk") + suffix;
            return Label;
        }
    }
}
﻿using System;
using Kernel_alpha.x86;
using Kernel_alpha.x86.Intrinsic;
using Kernel_alpha.Drivers.Video.Vmware;
using Kernel_alpha.Lib;

namespace Kernel_alpha.Drivers.Video
{
    public unsafe class VMWareSVGAII
    {
        private PCIDevice Device;

        private IOPort IndexPort;
        private IOPort ValuePort;

        private MemoryBlock32 FB_Memory;
        private MemoryBlock32 FIFO_Memory;

        private UInt32 VersionID;
        private UInt32 Capabilities;
        private UInt32 Width;
        private UInt32 Height;
        private UInt32 BPP;
        private UInt32 Pitch;

        public VMWareSVGAII()
        {
            Device = PCI.GetDeviceVendorID(misc.PCI_VENDOR_ID_VMWARE, misc.PCI_DEVICE_ID_VMWARE_SVGA2);

            if (Device == null)
                throw new Exception("Device Not Found");

            Device.EnableMemory(true);

            //IO Ports
            var IOBase = Device.BaseAddressBar[0].BaseAddress;
            IndexPort = new IOPort((ushort)(IOBase + (ushort)IOPortOffset.Index));
            ValuePort = new IOPort((ushort)(IOBase + (ushort)IOPortOffset.Value));

            //Memory Block
            FB_Memory = new MemoryBlock32(Device.BaseAddressBar[1].BaseAddress);
            FIFO_Memory = new MemoryBlock32(Device.BaseAddressBar[2].BaseAddress);

           //Version Check
            VersionID = (UInt32)Versions.SVGA_ID_2;
            do
            {
                WriteRegister(Registers.SVGA_REG_ID, VersionID);
                if (ReadRegister(Registers.SVGA_REG_ID) == VersionID)
                    break;
                else
                    VersionID--;
            }
            while (VersionID >= (UInt32)Versions.SVGA_ID_0);

            if (VersionID < (UInt32)Versions.SVGA_ID_0)
                throw new Exception("Error negotiating SVGA device version.");

            //Memory Block Length
            FB_Memory.Length = ReadRegister(Registers.SVGA_REG_FB_SIZE);
            FIFO_Memory.Length = ReadRegister(Registers.SVGA_REG_MEM_SIZE);

            //Memory Block Length Check
            if (FB_Memory.Length < 0x100000)
                throw new Exception("FB size very small, probably incorrect.");

            if (FIFO_Memory.Length < 0x20000)
                throw new Exception("FIFO size very small, probably incorrect.");

            if (VersionID >= (UInt32)Versions.SVGA_ID_1)
                Capabilities = ReadRegister(Registers.SVGA_REG_CAPABILITIES);
        }

        public void SetMode(uint aWidth, uint aHeight, uint aBPP)
        {
            Width = aWidth;
            Height = aHeight;
            BPP = aBPP;

            WriteRegister(Registers.SVGA_REG_WIDTH, Width);
            WriteRegister(Registers.SVGA_REG_HEIGHT, Height);
            WriteRegister(Registers.SVGA_REG_BITS_PER_PIXEL, BPP);
            WriteRegister(Registers.SVGA_REG_ENABLE, 1);//True

            Pitch = ReadRegister(Registers.SVGA_REG_BYTES_PER_LINE);

            InitializeFIFO();
        }

        private unsafe void InitializeFIFO()
        {
            //FIFO Registers
            FIFO_Memory[(uint)FIFO.SVGA_FIFO_MIN] = (uint)Registers.SVGA_FIFO_NUM_REGS * sizeof(uint);
            FIFO_Memory[(uint)FIFO.SVGA_FIFO_MAX] = FIFO_Memory.Length;
            FIFO_Memory[(uint)FIFO.SVGA_FIFO_NEXT_CMD] = FIFO_Memory[(int)FIFO.SVGA_FIFO_MIN];
            FIFO_Memory[(uint)FIFO.SVGA_FIFO_STOP] = FIFO_Memory[(int)FIFO.SVGA_FIFO_MIN];
            /*if (HasFIFOCap((int)FIFO.SVGA_FIFO_CAPABILITIES) && IsFIFORegValid((int)FIFO.SVGA_FIFO_GUEST_3D_HWVERSION))
            {
                FIFO_Memory[(int)FIFO.SVGA_FIFO_GUEST_3D_HWVERSION] = SVGA3D_HWVERSION_CURRENT;
            }*/

            //Enable FIFO
            WriteRegister(Registers.SVGA_REG_CONFIG_DONE, 1);//True
        }

        public void Update(uint x, uint y, uint width, uint height)
        {
            WriteToFifo((uint)FIFO.Update);
            WriteToFifo(x);
            WriteToFifo(y);
            WriteToFifo(width);
            WriteToFifo(height);
            WaitForFifo();
        }

        public void Clear(uint color)
        {
            for (ushort y = 0; y < Height; y++)
            {
                for (ushort x = 0; x < Width; x++)
                {
                    SetPixel(x, y, color);
                }
            }
            Update(0, 0, Width, Height);
        }

        private void WriteToFifo(uint value)
        {
            if (((GetFIFO(FIFO.SVGA_FIFO_NEXT_CMD) == GetFIFO(FIFO.SVGA_FIFO_MAX) - 4) && GetFIFO(FIFO.SVGA_FIFO_STOP) == GetFIFO(FIFO.SVGA_FIFO_MIN)) ||
                (GetFIFO(FIFO.SVGA_FIFO_NEXT_CMD) + 4 == GetFIFO(FIFO.SVGA_FIFO_STOP)))
                WaitForFifo();

            SetFIFO((FIFO)GetFIFO(FIFO.SVGA_FIFO_NEXT_CMD), value);
            SetFIFO(FIFO.SVGA_FIFO_NEXT_CMD, GetFIFO(FIFO.SVGA_FIFO_NEXT_CMD) + 4);

            if (GetFIFO(FIFO.SVGA_FIFO_NEXT_CMD) == GetFIFO(FIFO.SVGA_FIFO_MAX))
                SetFIFO(FIFO.SVGA_FIFO_NEXT_CMD, GetFIFO(FIFO.SVGA_FIFO_MIN));
        }

        public void SetPixel(ushort x, ushort y, uint color)
        {
            FB_Memory[(UInt32)(((uint)(y * Width) + x) * 4)] = color;
        }

        private uint GetFIFO(FIFO cmd)
        {
            if (Device != null)
                return FIFO_Memory[(uint)cmd];
            return 0;
        }

        private uint SetFIFO(FIFO cmd, uint value)
        {
            if (Device != null)
                return FIFO_Memory[(uint)cmd] = value;
            return 0;
        }

        private void WaitForFifo()
        {
            WriteRegister(Registers.SVGA_REG_SYNC, 1);
            while (ReadRegister(Registers.SVGA_REG_BUSY) != 0) { }
        }

        private bool HasFIFOCap(int cap)
        {
            return (FIFO_Memory[(int)FIFO.SVGA_FIFO_CAPABILITIES] & cap) != 0;
        }

        private bool IsFIFORegValid(int reg)
        {
            return FIFO_Memory[(int)FIFO.SVGA_FIFO_MIN] > (reg << 2);
        }

        #region IO Ports
        private UInt32 ReadRegister(UInt32 Index)
        {
            IndexPort.DWord = Index;
            return ValuePort.DWord;
        }

        private UInt32 ReadRegister(Registers Index)
        {
            IndexPort.DWord = (UInt32)Index;
            return ValuePort.DWord;
        }

        private void WriteRegister(UInt32 Index, UInt32 Value)
        {
            IndexPort.DWord = Index;
            ValuePort.DWord = Value;
        }

        private void WriteRegister(Registers Index, UInt32 Value)
        {
            IndexPort.DWord = (UInt32)Index;
            ValuePort.DWord = Value;
        }
        #endregion
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          Window Class
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

using System;

using Atomix.Kernel_H.Core;
using Atomix.Kernel_H.Devices;
using Atomix.Kernel_H.Arch.x86;
using Atomix.Kernel_H.Lib.Cairo;

namespace Atomix.Kernel_H.Gui
{
    internal class Window
    {
        internal uint Buffer;
        internal string HashID;

        internal int ID;
        internal int ClientID;

        internal int X;
        internal int Y;

        internal int Width;
        internal int Height;

        internal uint Surface;

        internal Window(int aClientID, int aXpos, int aYpos, int aWidth, int aHeight)
        {
            ClientID = aClientID;
            X = aXpos;
            Y = aYpos;

            Width = aWidth;
            Height = aHeight;

            HashID = GenerateNewHashID();
            Buffer = SHM.Obtain(HashID, (uint)(aWidth * aHeight * 4), true);

            Surface = Cairo.ImageSurfaceCreateForData(aWidth * 4, aHeight, aWidth, ColorFormat.ARGB32, Buffer);
        }

        internal static string GenerateNewHashID()
        {
            // TODO: memory get more and more fragmented this way
            // come up with better idea
            string tid = Convert.ToString(Timer.TicksFromStart);
            string xid = "win." + tid;

            return xid;
        }
    }
}
﻿/*
* PROJECT:          Atomix Development
* LICENSE:          BSD 3-Clause (LICENSE.md)
* PURPOSE:          FAT Helper
* PROGRAMMERS:      Aman Priyadarshi (aman.eureka@gmail.com)
*/

namespace Atomix.Kernel_H.IO.FileSystem.FAT.Find
{
    internal class WithName : Comparison
    {
        internal string Name;

        internal WithName(string aName)
        {
            Name = aName;
        }

        internal override bool Compare(byte[] data, int offset, FatType type)
        {
            switch ((FileNameAttribute)data[offset + (int)Entry.DOSName])
            {
                case FileNameAttribute.LastEntry:
                case FileNameAttribute.Deleted:
                case FileNameAttribute.Escape:
                    return false;
                default:
                    break;
            }

            int index;
            for (index = 7; index >= 0 && data[offset + index] == ' '; index--) ;
            index++;

            int dot = Name.IndexOf('.');
            if (dot == -1)
                dot = Name.Length;

            if (dot != index)
                return false;

            for (index = 0; index < dot; index++)
            {
                if ((data[offset + index] & 0xDF) != (Name[index] & 0xDF))
                    return false;
            }

            for (index = 10; index >= 8 && data[offset + index] == ' '; index--) ;
            index -= 7;

            int index2 = Name.Length - dot - 1;
            if (index2 < 0) index2 = 0;

            if (index2 != index)
                return false;

            dot++;
            for (index = 0; index < index2; index++)
            {
                if ((data[offset + index + 8] & 0xDF) != (Name[dot + index] & 0xDF))
                    return false;
            }

            return true;
        }
    }
}
